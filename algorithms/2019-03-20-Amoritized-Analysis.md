# 均摊分析

## 均摊分析 VS 传统时间复杂度分析

![](/images/2019-03-20-23-39-51.png)

传统时间复杂度

* 给定的一个算法，以及同样长度为`N`的不同输入数据（依赖于数据的好坏）－－－比如上图中的右边各种排序算法的结果
  * Best
  * Average
  * Worst
* #(number) of ops is same for the same input()

均摊分析（Amoritized Analysis）

* 对一种数据结构连续的操作
  * 一些操作`Fast`
  * 一些操作`Slow`
* 进行了`N`个操作后的平均花费是多少呢？（这就是均摊分析）

均摊分析可以帮助我们了解对一个数据结构进行n次操作的真实代价。对于相同的操作，有时候可以非常快，例如在O(1)时间内完成，而有时候则需要O(n)。我们当然可以说这个操作最坏情况下的时间复杂度是O(n)，但是这并不能真实反映它的实际复杂度。通过均摊分析，我们可以证明，**尽管有些操作在最坏情况下是O(n)的时间复杂度，但是均摊下来只需要O(1)。**

## 为什么要做均摊分析？

均摊分析是很有用的，例如，对扩张表，如果低于一半元素进行收缩，那么不是个好想法。可以根据聚集分析法轻松分析出最坏情况下（n/2处不断增加和减少）的每个操作平摊分析代价为O（n）。

# 计算均摊分析时间

计算均摊分析的三种方法：聚集分析，基站分析和势能法

## 聚集分析

聚集分析的思路是，计算n次操作的最坏代价，然后除以n。缺点是对操作类型多样的序列比较难分析。

## 记账法

记账法的思路是，对每一个操作进行分析，然后计算总体代价。（总结一最后介绍的思路）

## 势能法

势能法的思路是，认为每一个操作，除了自身的消耗为1以外，还对整体的一个“势”这个概念进行了影响，所以每一步操作的总代价是1加上这一步和上一步的势能差。势函数可以自己定义。例如，在表扩张中，我们可以定义势函数自变量是i，表示第i次操作，表达式为:2*第i次操作后表中的实际元素个数－第i次操作后表的大小(表可以比实际元素大)。这样定义的好处在于，在第i次操作是扩张时候，势函数大小刚好为0，如果不扩张，那么每次都累加势能（例如：当表中有4个元素，但表大小为8，那么继续加入元素，有2＊5-8=2，2＊6-8=4 ...）。只要找到合适的势函数，则可以轻松的用势能法计算出操作序列的上界（即平摊代价）。