---
title: Leetcode Bit-Manipulation Summary 
date: 2019-02-06 12:40:43
updated: 2019-02-06 12:40:43
categories: 
- [Leetcode]
tags: Leetcode
mathjax: true
top:
---

# 基本原理

0s 表示一串 0，1s 表示一串 1, 对这几种情况, 可以得下以下的操作:

| 符号 | 描述 | 运算规则                                                        | 示例                                  |
| ---- | ---- | --------------------------------------------------------------- | ------------------------------------- |
| &    | 与   | 两个位都为1时，结果才为1                                        | x & 1s = x, x & x = x, x & 0s = 0     |
| \|   | 或   | 两个位都为0时，结果才为0                                        | x \| 0s = x, x \| 1s = 1s, x \| x = x |
| ^    | 异或 | 两个位相同为0，相异为1                                          | x ^ x = 0, x ^ 1s = ~x, x ^ 0s = x    |
| ~    | 取反 | 0变1，1变0                                                      |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                       |
| \>\> | 右移 | 各二进位全部右移若干位，对无符号数，高位补0, 有符号位（补0或１) |

* 位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。
* `x ^ 1s = ~x`, 翻转某一位
* `x ^ x = 0`, 删除重复的数据, 复位到0
* `x & 0s = 0` 和  `x & 1s = x`, 实现掩码操作
* `x | 0s = x 和 x | 1s = 1s` 用来设置值
* n&(n-1) 去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110  **100**  ，减去 1 得到 10110**011**，这两个数相与得到 10110**000**。
* n&(-n) 得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于二进制表示 10110  **100**  ，-n 得到 01001**100**，相与得到 00000**100**。
* n-n&(~n+1) 去除 n 的位级表示中最高的那一位。


# 常用位操作技巧

## 判断奇偶

只需要根据最末位是`0`还是`1`判断, 如果为 `0` 为偶数, 为 `1` 就是奇数.

```cpp
//判断是偶数
if (a % 2 == 0)
if ((a & 1) == 0)
```

## 交换双数

可以用位操作来实现交换两数而不用第三方变量. 

```cpp
a ^= b; // a=(a^b);
b ^= a; // b=b^(a^b)==b^b^a=a
a ^= b; // a=(a^b)^a
```

## 变换符号 & 求绝对值

变换符号就是正数变成负数，负数变成正数. 如对于-11和11，可以通过下面的变换方法将-11变成11.

`1111 0101(二进制) –取反-> 0000 1010(二进制) –加1-> 0000 1011(二进制)`

同样可以这样的将11变成-11

`0000 1011(二进制) –取反-> 0000 0100(二进制) –加1-> 1111 0101(二进制)`

因此变换符号只需要取反后加1即可。完整代码如下：

```cpp
int SignReversal(int a) { return ~a + 1; }
```

位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样：

`1111 1010(二进制) –取反->0000 0101(二进制) -加1-> 0000 0110(二进制)`

来得到6。因此先移位来取符号位，int i = a >> 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：

```cpp
int my_abs(int a) {
  int i = a >> 31;
  return i == 0 ? a : (~a + 1);
}
```

现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，a与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：

```cpp
int my_abs(int a) {
  int i = a >> 31;
  return ((a ^ i) - i);
}
```

## 高级应用：压缩空间

计算100以内的素数, 使用位操作的方式来保存结果. 使用一个 `int` 的数组, 然后使用里面的每一个位置来表示得到的结果

```cpp
const int MAXN = 100;
int flag[MAXN / 32 + 1];
int primes[MAXN / 3 + 1], pi;
void GetPrime_1() {
  int i, j;
  pi = 0;
  memset(flag, 0, sizeof(flag));
  for (i = 2; i < MAXN; i++)
    if (!((flag[i / 32] >> (i % 32)) & 1)) {
      primes[pi++] = i;
      for (j = i; j < MAXN; j += i) flag[j / 32] |= (1 << (j % 32));
    }
}
```

## 高低位交换

## 二进制逆序

## 二进制中1的个数

## 缺失的数字

# Mash 计算


# C++位操作