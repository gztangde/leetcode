<!-- TOC -->

- [算法设计与分析](#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90)
- [非递归算法时间复杂度分析](#%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)
  - [O(1)](#o1)
  - [O(n)-O(n^m)](#on-onm)

<!-- /TOC -->

# 算法设计与分析

从算法是否递归调用来分析，我们可以大致將算法分为递归算法与非递归算法。非递归算法时间复杂度分析较为简单，通常是计算算法中基本语句执行次数，一般都是一个关于问题规模n的表达式，然后用渐近符号`Θ、O、o、Ω、ω`表示出算法的时间复杂度。 

递归算法是采用分治的方法，把一个“大问题”分解出若干个相似的“小问题”求解。在分析算法复杂度时，关键是**根据递归过程建立递推关系式，然后求解递推关系式，得到算法执行的时间表达式**（一般都与问题规模n相关），最后用渐近符号`Θ、O、o、Ω、ωΘ、Ο、o、Ω、ω`表示出算法的时间复杂度。 

# 非递归算法时间复杂度分析

## O(1)

如果算法的执行时间不随着问题规模n的增加而增长，它的基本语句执行的次数是固定的，总的时间由一个常数来限界。此类算法的时间复杂度是$O(1)$.

## O(n)-O(n^m)

当有若干个循环语句时，时间复杂度是由嵌套层数最多的循环语句中的基本语句的执行次数决定.

Example:

```cpp
void fun(int n) {
  int x = 0;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
      for (int k = 1; k <= j; k++) {
        x++;  //基本语句
      }
    }
  }
}
```

$f(n) = \sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^j1 = \sum_{k=1}^j\frac{i(i+1)}{2} = ... = O(n^3)$