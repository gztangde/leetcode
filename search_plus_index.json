{"./":{"url":"./","title":"All Leetcode Questions","keywords":"","body":"All Leetcode Problems I have solved 405 / 1005 problems. I use this page to record the questions which I did on the Leetcode. Last Updated: 2019-05-02 18:26:12 Here's a list of absolute, must-have knowledge. For each of these topics, make sure you understand how to use and implement then and, where applicable, the space and time. table th:nth-of-type(1) { width: 30%; } table th:nth-of-type(2) { width: 30%; } table th:nth-of-type(3) { width: 40%; } Data Structures Algorithm Concepts Vector/Array/Matrix, string Breadth-First Search Bit Manipulation Linked-List Depth-First Search Memory(Stack vs Heap) Tree, Tries, & Graphs Binary-Search Recursion Stack & Queues Sort Dynamic Programming Hash-Table Merge Sorting Big O time & Space Heaps Quick Sorting Greedy Divide-And-Conquer Other algorithm will include: Math, Two Points, Recursion, Divide-And-Conquer, Combinations and Permutations This table include: Question Number, Questions Name, Question Difficulty, Question Type, And when I did it. table th:nth-of-type(1) { width: 30px; } table th:nth-of-type(2) { width: 70%; } # Title Difficulty Topics 1 Two-Sum Easy Array 2 Add-Two-Numbers Medium Linked 3 Longgest-Substring-Without-Repeating-Characters Medium String 4 Median-of-Two-Sorted-Arrays Hard Array 5 Longest-Palindromic-Substring Medium String 7 Reverse-Integer Easy Array 8 String-to-Integer Medium String 9 Palindrome-Number Easy Math 10 Regular-Expression-Match Hard String 11 Container-With-Most-Water Medium Math 12 Integer-to-Roman Medium Math 13 Roman-to-Integer Easy Array 14 Longest-Common-Prefix Easy Null 15 3Sum Easy Array 16 3Sum-Closest Medium Array 17 Letter-Combinations-of-a-Phone-Number Medium Null 18 4Sum Medium Array 19 Remove-Nth-Node-From-End-Of-List Medium Two 20 Valid-Parentheses Easy Stack 21 Merge-Two-Sorted-Lists Easy Linked 22 Generate-Parentheses Null Null 23 Merge-K-Sorted-Lists Hard Linked 24 Swap-Nodes-In-Pairs Medium Linked 25 Reverse-Nodes-In-K-Group Hard Linked 26 Remove-Duplicates-From-Sorted-Array Null Null 27 Remove-Element Easy Array 28 Implement-StrStr Easy String 29 Divide-Two-Integers Medium Null 31 Next-Permutation Medium Array 32 Longest-Valid-Parentheses Hard Dynamic 33 Search-In-Rotated-Sorted-Array Null Null 34 Find-First-And-Last-Position-Of-Element-In-Sorted-Array Medium Array 35 Search-Insert-Position Null Null 36 Valid-Sudoku Medium HashTable 37 Sudoku-Solver Hard Hash 38 Count-And-Say Null Null 39 Combination-Sum Null Null 40 Combination-Sum-II Null Null 41 First-Missing-Positive Medium Array 42 Trapping-Rain-Water Hard Null 43 Multiply-String Medium Null 44 Wildcard-Matching Hard Null 45 Jump-Game-II Hard Greedy 46 Permutations Medium Backtracking 47 Permutations-II Medium Backtracking 48 Rotate-Image Medium Array 49 Group-Anagrams Easy Hash 50 Powerx-n Medium Math 53 Maximum-Subarray Easy Array 54 Spiral-Matrix Null Null 55 Jump-Game Medium Array 56 Merge-Intervals Medium Array 57 Insert-Interval Medium Null 58 Length-of-Last-Word Null Null 59 Spiral-Matrix-II Null Null 60 Permutation-Sequence Medium Math 61 Rotate-List Medium Linked 62 Unique-Paths Medium Array 63 Unique-Paths-II Medium Array 64 Minimum-Path-Sum Medium Array 65 Valid-Number Hard Math 66 Plus-One Easy Array 67 Add-Binary Easy String 69 Sqrt-x-3 Easy Math 70 Climbing-Stairs Easy DP 72 Edit-Distance Hard String 73 Set-Matrix-Zeroes Medium Array 74 Search-a-2D-Matrix Medium Array 75 Sort-Colors Medium Array 76 Minimum-Window-Substring Medium Hard 77 Combinations Null Null 78 Subsets Medium Null 79 Word-Search Medium Array 80 Remove-Duplicates-From-Sorted-Array-II Null Null 81 Search-In-Rotated-Sorted-Array-II Null Null 82 Remove-Duplicates-From-Sorted-List-II Medium Linked 83 Remove-Duplicates-From-Sorted-List Easy Linked 84 Largest-Rectangle-in-histogram Medium Array 85 Maximal-Rectangle Hard Array 86 Partition-List Medium Linked 87 Scramble-String Hard String 88 Merge-Sorted-Array Easy Array 89 Gray-Code Medium Backtracking 90 Subset-II Medium Null 91 Decode-Ways Medium String 92 Reverse-Linked-List-II Medium Linked 93 Restore-IP-Addresses Null Null 94 Binary-Tree-Inorder-Traversal Medium Tree 95 Unique-Binary-Search-Trees-II Medium Dynamic 96 Unique-Binary-Search-Trees Medium Tree 97 Interleaving-String Hard String 98 Validate-Binary-Search-Tree Medium Tree 99 Recover-Binary-Search-Tree Hard Tree 100 Same-Tree Easy Tree 101 Symmetrix-Tree Easy Tree 102 Binary-Tree-Level-Order-Traversal Medium Tree 103 Binary-Tree-Zigzag-Level-Order-Traversal Medium Tree 104 Maximum-Depth-of-Binary-Tree Easy Tree 105 Construct-Binary-Tree-From-Preorder-and-Inorder-Traversal Medium Tree 106 Construct-Binary-Tree-From-Inorder-And-Postorder-Traversal Medium Tree 107 Binary-Tree-Level-Order-Traversal-II Medium Null 108 Convert-Sorted-Array-To-Binary-Search-Tree Easy Tree 109 Convert-Sorted-List-to-Binary-Search-Tree Medium Linked 110 Balanced-Binary-tree Easy Tree 111 Minimum-Depth-of-Binary-Tree Easy Tree 112 Path-Sum Medium Tree 113 Path-Sum-II Medium Tree 114 Flatten-Binary-Tree-To-Linked-List Medium Tree 115 Distinct-Subsequences Hard String 116 Populating-Next-Right-Pointers-In-Each-Node Medium Tree 117 Populating-Next-Right-Pointers-In-Each-Node-II Medium Tree 118 Pascal-Triangle Null Null 119 Pascal-Triangle-II Null Null 120 Triangle Medium Array 121 Best-Time-to-Buy-and-Sell-Stock Null Null 122 Best-Time-To-Buy-and-Sell-Stock-II Null Null 123 Best-Time-To-buy-and-sell-Stock-III Hard Dynamic 124 Binary-Tree-Maximum-Path-Sum Hard Tree 125 Valid-Palindrome Easy Null 128 Longest-Consecutive-Sequence Null Null 129 Sum-Root-to-Leaf-Numbers Medium Tree 131 Palindrome-Partitioning Medium Backtracking 132 Palindrome-Partitioning-II Hard Dynamic 133 Clone-Graph Medium Depth 134 Gas-Station Medium Greedy 136 Single-Number Medium HashTable 137 Single-Number-II Medium Bit 138 Copy-List-With-Random-Pointer Medium HashTable 139 Word-Break Medium Dynamic 141 Linked-List-Cycle Easy Linked 142 Linked-List-Cycle-II Medium Linked 143 Reorder-List Medium Linked 144 Binary-Tree-Preorder-Traversal Medium Tree 145 Binary-Tree-Postorder-Travesal Hard Tree 146 LRU-Cache Medium Design 147 Insertion-Sort-List Medium Linked 148 Sort-List Medium Linked 150 Evaluate-Reverse-Polish-Notation Medium Stack 153 Find-Minimum-in-Rotated-Sorted-Array Medium Null 154 Find-Minimum-in-Rotated-Sorted-Array-II Hard Null 155 Min-Stack Easy Stack 160 Intersection-of-Two-Linked-Lists Easy Linked 161 One-Edit-Distance Medium Null 162 Find-Peak-Element Medium Null 164 Maximum-Gap Hard Sort 167 Two-Sum-II-Input-Array-Is-Sorted Null Null 168 Excel-Sheet-Column-Title Easy Null 169 Majority-Element Easy Array 171 Excel-Sheet-Column-Number Easy Math 172 Factorial-Trailing-Zeroes Easy Math 173 Binary-Search-Tree-Iterator Medium Stack 174 Dungeon-Game Hard Binary 179 Largest-Number Medium Null 189 Rotate-Array Null Null 190 Reverse-Bits Easy Bit 198 House-Robber Easy Dynamic 199 Binary-Tree-Right-Side-View Medium Tree 200 Number-of-Islands Medium Null 206 Reverse-Linked-List Easy Linked 209 Minimum-Size-Subarray-Sum Medium Null 212 Word-Search-II Hard Backtracking 213 House-Robber-II Medium Null 215 Kth-Largest-Element-in-an-Array Medium Null 216 Combination-Sum-III Null Null 217 Contains-Duplicate Easy Array 222 Count-Complete-Tree-Nodes Medium Tree 225 Implement-Stack-using-Queues Easy Stack 226 Invert-Binary-Tree Medium Tree 230 Kth-Smallest-Element-in-a-BST Medium Null 231 Power-of-Two Easy Math 234 Palindrome-Linked-List Easy Linked 235 Lowest-Common-Ancestor-of-a-Binary-Search-Tree Easy Null 236 Lowest-Common-Ancestor-of-a-Binary-Tree Medium Tree 240 Search-a-2D-Matrix-II Medium Null 241 Different-Ways-to-Add-Parentheses Medium DP 242 Valid-Anagram Easy Sort 252 Meeting-Rooms Easy Null 253 Meeting-Rooms-II Medium Null 257 Binary-Tree-Paths Easy Tree 260 Single-Number-III Medium Null 268 Misssing-Number Null Null 274 H-Index Medium Hash 275 H-Index-II Medium Array 277 Find-the-Celebrity Medium Null 278 First-Bad-Version Easy Binary 283 Move-Zeroes Medium Array 287 Find-the-Duplicate-Number Medium Array 300 Longest-Increasing-Subsequence Medium Dynamic 301 Remove-Invalid-Parentheses Hard DFS 303 Range-Sum-Query-Immutable Easy Dynamic 307 Range-Sum-Query-Mutable Medium Null 312 Burst-Balloons Hard Dynamic 315 Count-of-Smaller-Numbers-After-Self Medium Null 318 Maximum-Product-of-Word-Lengths Medium Bit 324 Wiggle-Sort-II Medium Sort 325 Maximum-Size-Subarray-Sum-Equal-k Medium Null 337 House-Robber-III Medium Tree 338 Counting-Bits Medium Null 342 Power-of-Four Easy Bit 344 Reverse-String Easy Null 345 Reverse-Vowels-of-a-String Easy Null 347 Top-K-Frequent-Elements Medium Bubble 349 Intersection-of-two-Arrays Easy Hash 350 Intersection-Of-Two-Arrays-II Easy Hash 357 Count-Numbers-with-Unique-Digits Medium Math 371 Sum-of-Two-Integers Medium Bit 374 Guess-Number-Higher-Or-Lower Easy Binary 378 Kth-Smallest-Element-in-a-Sorted-Matrix Medium Binary 383 Ransom-Note Null Null 385 Mini-Parser Null Null 387 First-Unique-Character-In-A-String Null Null 389 Find-the-Difference Easy Hash 404 Sum-of-Left-Leaves Easy Tree 406 Queue-Reconstruction-by-Height Medium Greedy 416 Partition-Equal-Subset-Sum Medium Null 426 Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List Medium Null 429 N-ary-Tree-Level-Order-Traversal Easy Tree 434 Number-of-Segments-in-a-String Null Null 437 Path-Sum-III Easy Tree 438 Find-All-Anagrams-in-a-String Easy Hash 442 Find-All-Duplicates-In-An-Array Medium Array 443 String-Compression Null Null 445 Add-Two-Numbers-II Medium Linked 448 Find-All-Numbers-Disappeared-In-An-Array Easy Array 449 Serialize-and-Deserialize-BST Medium Tree 450 Delete-Node-in-a-BST Medium Tree 451 Sort-Characters-By-Frequency Medium Hash 459 Repeated-Substring-Pattern Null Null 461 Hamming-Distance Medium Bit 464 Can-I-Win Medium Dynamic 476 Number-Complement Easy Bit 485 Max-Consecutive-Ones Easy Array 489 Robot-Room-Cleaner Medium Null 494 Target-Sum Medium Dynamic 501 Find-Mode-in-Binary-Search-Tree Easy Tree 503 Next-Greater-Element-II Medium Stack 506 Relative-Ranks Easy Binary 509 Fibonacci-Number Medium Recursion 513 Find-Bottom-Left-Tree-Value Medium Tree 515 Find-Largest-Value-in-Each-Tree-Row Medium Tree 520 Detect-Capital Null Null 521 Longest-Uncommon-Subsequence-I Null Null 522 Longest-Uncommon-Subsequence-II Null Null 524 Longest-Word-in-Dictionary-through-Deleting Medium String 537 Complex-Number-Multiplication Null Null 538 Convert-BST-to-Greater-Tree Easy Tree 539 Minimum-Time-Difference Null Null 540 Single-Element-in-a-Sorted-Array Medium Binary 541 Reverse-String-II Null Null 543 Diameter-of-Binary-Tree Easy Tree 547 Friend-Circles Medium Null 551 Student-Attendance-Record-I Null Null 553 Optimal-Division Null Null 557 Reverse-Words-in-a-String-III Null Null 559 Maximum-Depth-of-N-ary-Tree Easy Tree 560 Subarray-Sum-Equals-K Medium Array 561 Array-Partition-I Easy Array 563 Binary-Tree-Tilt Easy Tree 566 Reshape-the-Matrix Easy Array 567 Permutation-in-String Null Null 572 Subtree-of-Another-Tree Easy Tree 581 Shortest-Unsorted-Continuous-Subarray Easy Null 583 Delete-Operation-For-Two-String Null Null 583 Delete-Operation-for-Two-Strings Medium String 589 N-ary-Tree-Preorder-Traversal Easy Tree 590 N-ary-Tree-Postorder-Traversal Easy Tree 599 Minimum-Index-Sum-of-Two-Lists Easy Hash 606 Construct-String-from-Binary-Tree Null Null 609 Find-Duplicate-File-in-System Null Null 617 Merge-Two-Binary-Trees Easy Tree 621 Task-Scheduler Medium Array 622 Design-Circular-Queue Medium Null 632 Smallest-Range Hard Hash 636 Exclusive-Time-of-Functions Medium Null 637 Average-of-Levels-in-Binary-Tree Medium Tree 641 Design-Circular-Deque Medium Null 645 Set-Mismatch Easy Hash 647 Palindromic-Substrings Null Null 657 Robot-Return-To-Origin Null Null 668 Kth-Smallest-Number-in-Multiplication-Table Hard Null 669 Trim-a-Binary-Search-Tree Easy Tree 671 Second-Minimum-Node-In-a-Binary-Tree Easy Tree 673 Number-of-Longest-Increasing-Subsequence Medium Dynamic 674 Longest-Continuous-Increasing-Subsequence Easy Array 680 Valid-Palindrome-II Null Null 682 Baseball-Game Medium Null 684 Redundant-Connection Medium Null 686 Repeated-String-Match Null Null 687 Longest-Univalue-Path Easy Tree 689 Maximum-Sum-of-3-Non-Overlapping-Subarrays Hard Array 693 Binary-Number-with-Alternating-Bits Medium Bit 695 Max-Area-of-Island Medium Null 696 Count-Binary-Substrings Null Null 697 Degree-of-an-Array Easy Array 704 Binary-Search Medium Null 709 To-Lower-Case Null Null 710 Random-Pick-with-Blacklist Hard Sort 712 Minimum-ASCII-Delete-Sum-for-Two-Strings Medium Null 717 1-bit-and-2-bit-characters Null Null 718 Maximum-Length-of-Repeated-Subarray Medium Null 719 Find-K-th-Smallest-Pair-Distance Hard Array 720 Longest-Word-in-Dictionary Easy Hash 724 Find-Pivot-Index Null Null 726 Number-of-Atoms Hard Hash 727 Minimum-Window-Subsequence Medium Null 729 My-Calendar-I Medium Array 734 Sentence-Similarity Medium Null 736 Parse-Lisp-Expression Hard String 737 Sentence-Similarity-II Medium Null 739 Daily-Temperatures Medium Hash 744 Find-Smallest-Letter-Greater-Than-Target Easy Binary 746 Min-Cost-Climbing-Stairs Easy Array 747 Largest-Number-At-Least-Twice-Of-Others Null Null 761 Special-Binary-String Medium Null 763 Partition-Labels Medium Two 766 Toeplitz-Matrix Easy Array 767 Reorganize-String Medium String 771 Jewels-and-Stones Easy Hash 778 Swim-in-Rising-Water Hard Null 784 Letter-Case-Permutation Easy Backtracking 786 K-th-Smallest-Prime-Fraction Hard Binary 788 Rotated-Digits Null Null 791 Custom-Sort-String Null Null 792 Number-of-Matching-Subsequences Medium String 793 Preimage-Size-of-Factorial-Zeroes-Function Hard Binary 804 Unique-Morse-Code-Words Null Null 819 Most-Common-Word Null Null 824 Goat-Latin Null Null 830 Positions-of-Large-Groups Easy Array 832 Flipping-an-Image Medium Array 833 Find-And-Replace-in-String Medium Null 841 Keys-and-Rooms Medium Null 844 Backspace-String-Compare Easy Null 852 Peak-Index-in-a-Mountain-Array Easy Binary 856 Score-Of-Parentheses Null Null 859 Buddy-Strings Null Null 862 Shortest-Subarray-with-Sum-at-Least-K Medium Null 865 Smallest-Subtree-with-all-the-Deepest-Nodes Medium Null 867 Transpose-Matrix Easy Array 875 Koko-Eating-Bananas Medium Null 884 Uncommon-Words-from-Two-Sentences Medium Hash 885 Spiral-Matrix-III Medium Math 888 Fair-Candy-Swap Easy Array 890 Find-And-Replace-Pattern Null Null 892 Surface-Area-of-3D-Shapes Medium Math 893 Groups-Of-Special_equivalent-Strings Null Null 896 Monotonic-Array Easy Array 897 Increasing-Order-Search-Tree Easy Tree 905 Sort-Array-By-Parity Easy Array 908 Smallest-Range-I Easy Math 911 Online-Election Medium Binary 914 X-of-a-Kind-in-a-Deck-of-Cards Easy Array 915 Partition-Array-into-Disjoint-Intervals Medium Array 917 Reverse-Only-Letters Easy String 921 Minimum-Add-to-Make-Parentheses-Valid Medium Null 922 Sort-Array-By-Parity-II Easy Array 925 Long-Pressed-Name Easy Two 929 Unique-Email-Addresses Easy String 933 Number-of-Recent-Calls Easy Queue 937 Reorder-Log-Files Easy Null 941 Valid-Mountain-Array Easy Math 942 DI-String-Match Easy Math 943 Find-the-Shortest-Superstring Hard Null 946 Validate-Stack-Sequences Medium Stack 949 Largest-Time-for-Given-Digits Easy Math 951 Flip-Equivalent-Binary-Trees Medium Tree 953 Verifying-an-Alien-Dictionary Easy Hash 957 Prison-Cells-After-N-Days Medium Null 958 Check-Completeness-of-a-Binary-Tree Medium Null 961 N-Repeated-Element-in-Size-2N-Array Easy Hash 962 Maximum-Width-Ramp Medium Null 963 Minimum-Area-Rectangle-II Medium Math 964 Least-Operators-to-Express-Number Hard Dynamic 965 Univalued-Binary-Tree Easy Tree 967 Numbers-With-Same-Consecutive-Differences Medium Null 969 Pancake-Sorting Medium Array 970 Powerful-Integers Easy Math 973 K-Closest-Points-to-Origin Easy Math 974 Subarray-Sums-Divisible-by-K Medium Array 975 Odd-Even-Jump Medium Null 976 Largest-Perimeter-Triangle Easy Array 977 Squares-of-a-Sorted-Array Medium Null 978 Longest-Turbulent-Subarray Medium Array 979 Distribute-Coins-in-Binary-Tree Hard Tree 980 Unique-Paths-III Hard Dynamic 981 Time-Based-Key-Value-Store Medium Null 984 String-Without-AAA-or-BBB Medium Null 985 Sum-of-Even-Numbers-After-Queries Easy Null 986 Interval-List-Intersections Medium Null 987 Vertical-Order-Traversal-of-a-Binary-Tree Medium Tree 988 Smallest-String-Starting-From-Leaf Medium Null 989 Add-to-Array-Form-of-Integer Easy Null 990 Satisfiability-of-Equality-Equations Medium Null 992 Subarrays-with-K-Different-Integers Hard Null 993 Cousins-in-Binary-Tree Easy Null 994 Rotting-Oranges Medium Null 996 Number-of-Squareful-Arrays Hard Null 1005 Maximize-Sum-Of-Array-After-K-Negations Easy Null 1006 Clumsy-Factorial Medium Null 1012 Complement-of-Base-10-Integer Easy Null 1013 Pairs-of-Songs-With-Total-Durations-Divisible-by-60 Medium Null 1014 Capacity-To-Ship-Packages-Within-D-Days Medium Null 1020 Partition-Array-Into-Three-Parts-With-Equal-Sum Easy Null 1021 Best-Sightseeing-Pair Medium Null 1022 Smallest-Integer-Divisible-by-K Medium Null Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"summary/2019-01-13-Leetcode-Template-Summary.html":{"url":"summary/2019-01-13-Leetcode-Template-Summary.html","title":"Leetcode Template","keywords":"","body":"一些 Leetcode 里面经常用到的函数模板 类型定义简化 using namespace std; typedef long long LL; typedef vector VI; #define REP(i,s,t) for(int i=(s);i 一些常用的模板函数 From Leetcode 用户natsugiri template inline void amin(T &x, const T &y) { if (y inline void amax(T &x, const T &y) { if (x void rprintf(const char *fmt, Iter begin, Iter end) { for (bool sp = 0; begin != end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); } putchar('\\n'); } 如果你并不知道你需要申请的 int 类型在机器上的空间大小的话, 就需要使用 sizeof 函数来判断. int *c = (int*)malloc(100 * sizeof(int)) Stack 的应用, 在递归的时候就会使用到这种情况. Programming Practice: The interviewer says: \"Write for me a program in C++ that takes as input a list of names, and prints out each name that appears in the list multiple times.\" 在使用 Linked List 的时候,不要使用下面这种方式, 这样会导致内存泄露 Node* temp = new Node; temp = n; 在使用 Linked List 的时候, 应该检查当前结点, 不要使用下一个结点作为检查 while(temp->next != nullptr) { temp = temp->next; } 这种写的办法, 如果Linked list 是空的话, 这样代码会崩溃. 应该写成: while(temp != nullptr) { } 如何测试你的代码的运行时间: seq 20000 > | input : time ./a.out Computer sciencist Abstraction Don't think about everything at once. Don't worry about irrelevant low-level details when thinking about a high-level idea. However, this doesn't mean you can ignore the low-level details -- these may have a large impact on performance, and can sometimes cause unexpected behavior. It often helps to know as much of technology Stack as possible ... Column A Column B Column C iPens X1智能触控手写笔] 6880 C1 A2 B2 C2 A3 B3 C3 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/2019-03-05-How-to-count-complexity.html":{"url":"summary/2019-03-05-How-to-count-complexity.html","title":"Count Time Complexity","keywords":"","body":" 算法设计与分析 非递归算法时间复杂度分析 O(1) O(n)-O(n^m) 递归算法的时间复杂度分析 该文大部分内容参考了博客:算法导论------递归算法的时间复杂度求解 算法设计与分析 从算法是否递归调用来分析，我们可以大致將算法分为递归算法与非递归算法。非递归算法时间复杂度分析较为简单，通常是计算算法中基本语句执行次数，一般都是一个关于问题规模n的表达式，然后用渐近符号Θ、O、o、Ω、ω表示出算法的时间复杂度。 递归算法是采用分治的方法，把一个“大问题”分解出若干个相似的“小问题”求解。在分析算法复杂度时，关键是根据递归过程建立递推关系式，然后求解递推关系式，得到算法执行的时间表达式（一般都与问题规模n相关），最后用渐近符号Θ、O、o、Ω、ωΘ、Ο、o、Ω、ω表示出算法的时间复杂度。 非递归算法时间复杂度分析 O(1) 如果算法的执行时间不随着问题规模n的增加而增长，它的基本语句执行的次数是固定的，总的时间由一个常数来限界。此类算法的时间复杂度是$O(1)$. O(n)-O(n^m) 当有若干个循环语句时，时间复杂度是由嵌套层数最多的循环语句中的基本语句的执行次数决定. Example: void fun(int n) { int x = 0; for (int i = 1; i $f(n) = \\sum{i=1}^n\\sum{j=1}^i\\sum{k=1}^j1 = \\sum{k=1}^j\\frac{i(i+1)}{2} = ... = O(n^3)$ 在计算过程中会使用到一些多项式的求和技巧知识。 递归算法的时间复杂度分析 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/2019-02-10-Leetcode-Arrays-And-Strings-Summary.html":{"url":"summary/2019-02-10-Leetcode-Arrays-And-Strings-Summary.html","title":"Arrays and Strings","keywords":"","body":"Any array questions and string questions are often Interchangeable. That is, a question that using an arrsy may be asked instead as a string questions. Hash Table A data structure that maps keys to values for highly efficient lookup. Think about how to implementing a hash table. We can use an array of linked lists and a hash code function. To insert a key (Which might be a string or essentially any other data type) and value. We do the following Firstly, compute the key's hash code, which will usually be a int or long. (Note that two different keys could have the same hash code as there may be an infinite number of keys and a finite number of ints.) Then, map the hash code to an index in the array. This could be done with something like hash(key) % array_lenght. Two different hash codes could, of course, map to the same index. At the index, there is a linked list of keys and values. Store the key and value in this index. We mush use a linked list because of collisions: you could have two different keys with the smae hash code. or two different hash codes that map to the same index. Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/2019-03-20-Data-Structure-Binary-Indexed-Tree.html":{"url":"summary/2019-03-20-Data-Structure-Binary-Indexed-Tree.html","title":"Binary Indexed Tree","keywords":"","body":"Fenwick Tree is mainly designed for solving the single point update range sum problems. e.g. what’s the sum between i-th and j-th element while the values of the elements are mutable. Init the tree (include building all prefix sums) takes O(nlogn) Update the value of an element takes O(logn) Query the range sum takes O(logn) Space complexity: O(n) class FenwickTree { public: FenwickTree(int n) : sums_(n + 1, 0) {} void update(int i, int delta) { while (i 0) { sum += sums_[i]; i -= lowbit(i); } return sum; } private: static inline int lowbit(int x) { return x & (-x); } vector sums_; }; Relative problems Leetcode 307. Range Sum Query – Mutable Leetcode 315. Count of Smaller Numbers After Self Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/Leetcode-Parentheses-Summary.html":{"url":"summary/Leetcode-Parentheses-Summary.html","title":"Parentheses Summary","keywords":"","body":" 括号问题小结 LC.20 Valid Parentheses, 验证括号合法 LC.22 Generate Parentheses, 生成合法括号 LC.32 Longest Valid Parentheses, 最长的合法括号长度 LC.678 Valid Parenthesis String, 括号加正则--判断是否合法 LC.921 Minimum Add to Make Parentheses Valid, 最小添加次数，合法 LC.241 Different Ways to Add Parentheses, 表达式中添加括号 LC.301 Remove Invalid Parentheses, 删除不合法的括号位置 LC.856 Score of Parentheses, 括号的度 括号问题小结 LC.20 Valid Parentheses, 验证括号合法 class Solution { public: bool isValid(string s) { std::stack parentheses; for (int i = 0; i LC.22 Generate Parentheses, 生成合法括号 // Runtime: 16 ms, faster than 49.46% of C++ online submissions for Generate Parentheses. // Memory Usage: 17.4 MB, less than 100.00% of C++ online submissions for Generate Parentheses. class Solution { public: vector generateParenthesis(int n) { vector ans; generateParenthesisDFS(n, n, \"\", ans); return ans; } private: void generateParenthesisDFS(int left_n, int right_n, string out, vector& ans) { if (left_n > right_n) return; if (left_n == 0 && right_n == 0) { ans.emplace_back(out); } else { if (left_n > 0) generateParenthesisDFS(left_n - 1, right_n, out + \"(\", ans); if (right_n > 0) generateParenthesisDFS(left_n, right_n - 1, out + \")\", ans); } } }; LC.32 Longest Valid Parentheses, 最长的合法括号长度 class Solution { public: int longestValidParentheses(string s) { int res = 0, left = 0; stack m; for (int i = 0; i LC.678 Valid Parenthesis String, 括号加正则--判断是否合法 Input: \"()\", Output: True Input: \"(*)\", Output: True Input: \"(*))\", Output: True class Solution { public: bool checkValidString(string s) { stack left, star; for (int i = 0; i star.top()) return false; left.pop(); star.pop(); } return left.empty(); } }; LC.921 Minimum Add to Make Parentheses Valid, 最小添加次数，合法 class Solution { public: int minAddToMakeValid(string s) { int ans = 0; stack sta; for (int i = 0; i LC.241 Different Ways to Add Parentheses, 表达式中添加括号 // Author: Huahua namespace leetcode { int add(int a, int b) { return a + b; } int minus(int a, int b) { return a - b; } int multiply(int a, int b) { return a * b; } } // namespace leetcode class Solution { public: vector diffWaysToCompute(string input) { return ways(input); } private: unordered_map> m_; const vector& ways(const string& input) { if (m_.count(input)) return m_[input]; vector res; for (int i = 0; i & l = ways(left); const vector& r = ways(right); std::function f; switch (op) { case '+': f = leetcode::add; break; case '-': f = leetcode::minus; break; case '*': f = leetcode::multiply; break; } for (int a : l) for (int b : r) res.emplace_back(f(a, b)); } } if (res.empty()) res.emplace_back(std::stoi(input)); m_[input] = res; return m_[input]; } }; LC.301 Remove Invalid Parentheses, 删除不合法的括号位置 // Runtime: 8 ms, faster than 97.09% of C++ online submissions for Remove Invalid Parentheses. // Memory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Remove Invalid Parentheses. // Solution: DFS // Step 1. Count how many parentheses we need to remove // Step 2. dfs function --- Try to remove each parentheses. class Solution { public: vector removeInvalidParentheses(string s) { vector ans; int l_cnt = 0, r_cnt = 0; // l_cnt and r_cnt is the number \"()\" which we need to remove; for (char& c : s) { if (c == '(') ++l_cnt; else if (c == ')') l_cnt == 0 ? ++r_cnt : --l_cnt; } dfs(s, 0, l_cnt, r_cnt, ans); if (ans.empty()) ans.emplace_back(\"\"); return ans; } private: void dfs(string& s, int start, int l_cnt, int r_cnt, vector& ans) { if (l_cnt == 0 && r_cnt == 0) { if (isValidParentheses(s)) ans.emplace_back(s); return; } for (int i = start; i start && s[i] == s[i - 1]) continue; if (s[i] == '(' || s[i] == ')') { string cur = s; cur.erase(i, 1); if (r_cnt > 0 && s[i] == ')') dfs(cur, i, l_cnt, r_cnt - 1, ans); else if (l_cnt > 0 && s[i] == '(') dfs(cur, i, l_cnt - 1, r_cnt, ans); } } } }; // Judge the s is valid parentheses, if not, return false. Otherwise, return true. bool isValidParentheses(string& s) { int cnt = 0; for (char& a : s) { if (a == '(') cnt++; else if (a == ')') cnt--; if (cnt LC.856 Score of Parentheses, 括号的度 class Solution { public: int scoreOfParentheses(string S) { int res = 0; std::stack par_stack; bool flag = false; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/2019-01-12-Leetcode-Tree-Summary.html":{"url":"summary/2019-01-12-Leetcode-Tree-Summary.html","title":"Tree And Graph","keywords":"","body":" Summary Definition of a Binary Tree Node Binary Search Tree Balanced Binary Tree Tree Traversal How to Create a BST Key to solve the tree problem. Templates Template 1: One root Template 2: Two root Tree Problems 1.Binary Tree Traversal 2.Build Binary Tree 3. Binary search Tree 4. Recursion (Binary Tree) All the pictures in this post are coming from the video: 花花酱 LeetCode Binary Trees 二叉树 - 刷题找工作 SP12 Summary This page talk about the followed information: The definition of a Binary Tree Node Binary Search Tree Balanced Binary Tree Binary Tree Traversal Pre-Order In-Order (Important: It have been sorted) Post-Order How to create a BST Key To Tree Problems: Recursion Templates: Single root/Two rootse Time Complexity: O(n) / Space Complexity: O(hight) For the Space Complexity, it may be equal to n if this tree only have the left node or right node. Definition of a Binary Tree Node There are some tips for the definition of a Binary Tree Node: You need build your own destruction function for the Struct TreeNode because the C++ new the Tree in the head. So there may be memory leak. This destruction function will delete all node in the tree by Recursion way. For example, when you delete the root node, it will run delete left firstly. After that, it will delete all the children node for the left node. 　如果使用图的思想来看待这一个树的结构的话，那这就是一个有向，无环的图形． 树可以有很多个子节点, 但是二叉树最多只能有一个左孩子和一个右孩子. The tree have the structure in logic like the above, but how the tree saved in the memory. Is it also like a tree graph? Of course, it isn't. The structure of the tree in the memory like the followed graph. In the memory, the tree's data are unordered. There is a point in the stack to find the root of the tree in the memory. So, if you want use a tree to sort the data, it is not effective because the tree's data is not continuous in the memory. How to do the Binary Tree Traversal If you want to do the preorder for the tree, the function will use the point for the root node which is saved in the stack to find the left node firstly and push the left node information in the stack. After that, deal with the right side. Like the above graph shows. When they finish one part, then pop the node in the stack. If you lose the root point in the stack, then no one can deal with the tree's data in the memory. This is a memory leak for c++; Binary Search Tree We want use a Binary Search Tree to do some element search work, so we hope the Binary Search tree is also a balanced tree. Because it may work faster than the tree like the first picture even though it is also a Binary search tree. Time Complexity O(h) worst case: O(h) = O(n) Best case: O(h) = O(log(n)) Balanced Binary Tree The height of left / right substrees are at most 1 So, not all Balanced Binary Tree can be used for the BST. We often want find a perfect BST in the balanced Tree to do some search work. ( O(h) = O(log n) ) Tree Traversal After we get a Good BST, we can use this tree to do the tree traversal. The preorder, inorder, postorder are the recursion function. There is just one different feature for these three method. It is when the function to handle the root node in the tree. In this part, when you change the function print, you can deal with the root node as the order of the output array. For a BST tree, the inorder function can give a sorted array as the output data. We often use the inorder tree with the BST tree because the BST have this feature to get a sorted array data after the inorder function. For the first line, all of them is the code to deal with the boundary for the recursion function. This is a feature for the recursion function. How to Create a BST In this funciton, the recursion function is the insert function. In this function, there are a few works we need to do: Deal with the boundary. If the root == null, it build a now node and add this node for it's father left node or right node. To make the decision whether we need to go through the left way or right way. After finish this part, return the root node. This part is talking about how to create an unbalanced BST. However, most times, we hope we can build a balanced BST to do the search work. (Deal with their height.) Key to solve the tree problem. There is a different way to solve the tree problem, you need to think about it as the recursive way. When you solve the tree problem, you need to think about how to use the left subtree output and the right-subtree output to build the output for question. (How you can use the recursive function return value to solve the problem.) Use the recursive way to think about this question. Templates Template 1: One root There are four steps for this template: Boundary conditions. Deal with the root value. recursive call funciton compare ouput value There are some problems like the followed. The Depth of Binary Tree (Leetcode 104) public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } Balanced Binary Tree(Leetcode 110) ```java java private boolean result = true; public boolean isBalanced(TreeNode root) { maxDepth(root); return result; } public int maxDepth(TreeNode root) { if (root == null) return 0; int l = maxDepth(root.left); int r = maxDepth(root.right); if (Math.abs(l - r) > 1) result = false; return 1 + Math.max(l, r); } ``` The Diameter of Binary Tree(Leetcode 543) Template 2: Two root There are four steps for this template: Boundary conditions. Deal with the root value, it may fit with some conditions. recursive call funciton compare ouput value Tree Problems 1.Binary Tree Traversal 树的遍历有两种: 深度优先遍历和宽度优先遍历。 深度优先遍历又可以分为两种：先根遍历和后根遍历。 树的先根遍历是：先访问树的根节点，然后依次先根遍历根的各个子树。树的先根遍历的结果与对应二叉树的先序遍历的结果是相同的。 数的后根遍历是： 先依次后根遍历树根的各个子树，然后访问根结点。树的后根遍历的结果与对应二叉树的后根遍历的结果是相同的。 在深度遍历里面有下面几种情况： 前序遍历：根结点 ---> 左子树 ---> 右子树 中序遍历：左子树---> 根结点 ---> 右子树 后序遍历：左子树 ---> 右子树 ---> 根结点 使用下图作为一个例子： 前序遍历: A->B->C->D->E->F->G->H->I->J->K->M->L 中序遍历: C->B->E->D->F->A->H->G->J->I->M->K->L 后序遍历: C->E->F->D->B->H->J->M->L->K->I->G->A 有以下这些问题: Preorder, Inorder, Postorder, N-arr Tree Preorder, N-arr Tree Postorder 方案: 递归或使用堆栈的非递归实现, 而多个子节点的实现,只需要将其装换为循环递归调用即可. Level Order, Level Order II, Zigzag Level Order, Vertical Order, N-arr Tree Level Order Recover Binary Search Tree Same Tree Symmetric Tree Balanced Binary Tree Flatten Binary Tree to Linked list Population Next Right Pointers in Each Node II 2.Build Binary Tree From Preorder and Inorder Traversal From Inorder and Postorder Traversal 3. Binary search Tree Unique Binary Search Trees Unique Binary Search Trees II Validate Binary Search Tree Covert Sorted Array to Binary Search Tree) Convert Sorted List to Binary Search Tree 4. Recursion (Binary Tree) Minimum Depth, Maximum Depth Path Sum, Path Sum II, Maximum Path Sum, Path Sum III Populating Next Right Pointers in Each Node Sum Root to Leaf Numbers Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/2019-02-03-Leetcode-Tree-Build.html":{"url":"summary/2019-02-03-Leetcode-Tree-Build.html","title":"Build Binary Tree","keywords":"","body":"这种题目是构造一个二叉树, 题目给的输入是其他数据结构. 相关题目有以下几种情况: Convert Sorted Array To Binary Search Tree Convert Sorted List to Binary Search Tree Construct Binary Tree From Preorder and Inorder Traversal Construct Binary Tree From Inorder And Postorder Traversal Introduce 第一道题目: Convert Sorted Array To Binary Search Tree 数组是有序的, 我们每一次取中点作为根结点, 然后递归构建左右子树就好. 递归的写法: 要把根root先new出来 然后它的左节点接到递归左边部分的返回值，右节点接到递归右边部分的返回值 最后将root返回回去 部分示例代码: int mid = (start + end) / 2; TreeNode* root = new TreeNode(nums[mid]); root->left = sortedArrayToBST(nums, start, mid - 1); root->right = sortedArrayToBST(nums, mid + 1, end); return root; 第二道题目:Convert Sorted List to Binary Search Tree 这道题目是將有序的 Array 换成了 List, 但都是有序的, 这道题目和上一道 Convert Sorted Array To BST 是一样的, 多出来的步骤是找到 List的长度 以及得到nth结点信息的过程. 部分示例代码: TreeNode* sortedListToBst(ListNode* head, int len) { if (len == 0) return nullptr; if (len == 1) return new TreeNode(head->val); ListNode* mid = getnthnode(head, len / 2 + 1); ListNode* mid_r = getnthnode(head, len / 2 + 2); TreeNode* root = new TreeNode(mid->val); root->left = sortedListToBst(head, len / 2); root->right = sortedListToBst(mid_r, (len - 1) / 2); return root; } Construct Binary Tree From Preorder and Inorder Traversal和题目Construct Binary Tree From Inorder And Postorder Traversal 是比较一样的. 如果给定了先序和中序，并且里面的元素不重复，可以得到这样几个条件： 先序的第一个元素一定是跟 可以更加先序里面的根节点到中序里面找到对应的节点，因为没有重复元素 根据中序里面找到的根节点可以将其分为左右两个部分，分别对左右两个部分递归调用原函数 如果题目给定了后序和中序，并且里面的元素不重复，可以得到这样几个条件： 后序的最后一个元素一定是跟节点 可以在后序里面的根节点到中序里面找到对应的节点，因为没有重复元素 根据中序里面找到的根节点可以将其分为左右两个部分，分别对左右两个部分递归调用原函数 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/2019-01-23-Leetcode-Sorting-Summary.html":{"url":"summary/2019-01-23-Leetcode-Sorting-Summary.html","title":"Sorting","keywords":"","body":"Time complexity of different sorting algorithms. You can go to wiki to see basic idea of them. Algorithm Average Time Worst Time Space Bubble Sort n^2 n^2 1 Selection Sort n^2 n^2 1 Insertion SOrt n^2 n^2 Quick Sort n log(n) n^2 Merge Sort n log(n) n log(n) depends BinSort, Radix Sort and CountSort use different set of assumptions than the rest, and so they are not \"general\" sorting methods. There is a link about the 15 sorting: 15 Sorting Algorithms in 6 Minutes 1. 冒泡排序 (Bubble Sort) 冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。 步骤 从左开始比较相邻的两个元素x和y，如果 x > y 就交换两者 执行比较和交换，直到到达数组的最后一个元素 重复执行1和2，直到执行n次，也就是n个最大元素都排到了最后 void bubble_sort(vector &nums) { for (int i = 0; i nums[j + 1]) { nums[j] += nums[j + 1]; nums[j + 1] = num[j] - nums[j + 1]; nums[j] -= num[j + 1]; } } } } 由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是(a1 + an) * n / 2），也就是 O(n^2)。空间复杂度是O(n)。 2. 插入排序（Insertion Sort） 插入排序的原理是从左到右，把选出的一个数和前面的数进行比较，找到最适合它的位置放入，使前面部分有序。 步骤 从左开始，选出当前位置的数x，和它之前的数y比较，如果x 对x之前的数都执行1步骤，直到前面的数字都有序 选择有序部分后一个数字，插入到前面有序部分，直到没有数字可选择 void insert_sort(vector &nums) { for (int i = 1; i 0; j--) { if (nums[j] 因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是O(n^2)。空间复杂度是O(n)。 3. 选择排序（Selection Sort） 选择排序的原理是，每次都从乱序数组中找到最大（最小）值，放到当前乱序数组头部，最终使数组有序。 步骤 从左开始，选择后面元素中最小值，和最左元素交换 从当前已交换位置往后执行，直到最后一个元素 void selection_sort(vector &nums) { for (int i = 0; i 每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是O(n^2)。空间复杂度是O(n)。 4. 希尔排序（Shell Sort） 希尔排序从名字上看不出来特点，因为它是以发明者命名的。它的另一个名字是“递减增量排序算法“。这个算法可以看作是插入排序的优化版，因为插入排序需要一位一位比较，然后放置到正确位置。为了提升比较的跨度，希尔排序将数组按照一定步长分成几个子数组进行排序，通过逐渐减短步长来完成最终排序。 例子 例如 [10, 80, 70, 100, 90, 30, 20] 如果我们按照一次减一半的步长来算， 这个数组第一次排序时以3为步长，子数组是： 10 80 70 90 30 20 100 这里其实按照列划分的4个子数组，排序后结果为 10 30 20 90 80 70 100 也就是 [10, 30 20 90 80 70 100] 然后再以1为步长生成子数组 10 30 20 .. 这个时候就是一纵列了，也就是说最后一定是以一个数组来排序的。 步骤 计算当前步长，按步长划分子数组 子数组内插入排序 步长除以2后继续12两步，直到步长最后变成1 void shell_sort(vector &nums) { for (int gap = nums.size() >> 1; gap > 0; gap >>= 1) { // times for (int i = gap; i = 0 && nums[j] > temp; j -= gap) { nums[j + gap] = nums[j]; } nums[j + gap] = temp; } } } 希尔排序的时间复杂度受步长的影响，具体分析在维基百科。 5. 归并排序（Merge Sort - Divide and Conquer） 归并排序是采用分治法（Divide and Conquer）的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。 步骤 把当前数组分化成n个单位为1的子数组，然后两两比较合并成单位为2的n/2个子数组 继续进行这个过程，按照2的倍数进行子数组的比较合并，直到最终数组有序 void merge_array(vector &nums, int b, int m, int e, vector &temp) { int lb = b, rb = m, tb = b; while (lb != m && rb != e) if (nums[lb] &nums, int b, int e, vector &temp) { int m = (b + e) / 2; if (m != b) { merge_sort(nums, b, m, temp); merge_sort(nums, m, e, temp); merge_array(nums, b, m, e, temp); } } 这个实现中加了一个temp，是和原数组一样大的一个空间，用来临时存放排序后的子数组的。 复杂度分析 在merge_array过程中，实际的操作是当前两个子数组的长度，即2m。又因为打散数组是二分的，最终循环执行数是logn。所以这个算法最终时间复杂度是O(nlogn)，空间复杂度是O(n)。 归并排序中, 我们可以考虑不申请空间的实现方式. 6. 快速排序（Quick Sort - Divide and Conquer） Get the kth element. 快速排序也是利用分治法实现的一个排序算法。快速排序和归并排序不同，它不是一半一半的分子数组，而是选择一个基准数，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同步骤，直到整个数组有序。 因此快速排序又可以称之为: 划分交换排序(Partition-Exchange Sort). 步骤 用一个基准数将数组分成两个子数组 将大于基准数的移到右边，小于的移到左边 递归的对子数组重复执行1，2，直到整个数组有序 解法: 不需要辅助空间 void quick_sort(vector &nums, int b, int e) { if (b = nums[b] && lb 快速排序也是一个不稳定排序，时间复杂度看维基百科。空间复杂度是O(n)。 参考博客: 白话经典算法系列之六 快速排序 快速搞定 7. 堆排序（Heap Sort -- Top K elements） 堆排序经常用于求一个数组中最大k个元素时。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为当前堆中最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前k大元素，或者使堆有序。 在了解算法之前，首先了解在一维数组中节点的下标： i节点的父节点 parent(i) = floor((i-1)/2) i节点的左子节点 left(i) = 2i + 1 i节点的右子节点 right(i) = 2i + 2 步骤 构造最大堆（Build Max Heap）：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到比较到根节点。重复执行到最后一个元素。 最大堆调整（Max Heapify）：调整最大堆即将根节点移除后重新整理堆。整理方法为将根节点和最后一个节点交换，然后把堆看做n-1长度，将当前根节点逐步移动到其应该在的位置。 堆排序（HeapSort）：重复执行2，直到所有根节点都已移除。 void heap_sort(vector &nums) { int n = nums.size(); for (int i = n / 2 - 1; i >= 0; i--) { // build max heap max_heapify(nums, i, nums.size() - 1); } for (int i = n - 1; i > 0; i--) { // heap sort int temp = nums[i]; num[i] = nums[0]; num[0] = temp; max_heapify(nums, 0, i); } } void max_heapify(vector &nums, int beg, int end) { int curr = beg; int child = curr * 2 + 1; while (child 相关问题 Kth-Largest-Element-in-an-Array Leetcode 767. Reorganize String 堆执行一次调整需要O(logn)的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是O(nlogn)。空间复杂度是O(n)。 8. Bubble sort(Iterative Refinement) 桶排序，也叫做箱排序，是一种排序算法，也是排序算法中最快、最简单的排序算法。其中的思想是我们首先要知道所有待排序的范围，然后需要有在这个范围的同样数量的桶，接着把元素放到对应的桶中，最后按顺序输出。 这时间上是简易版的桶排序，试想一下，如果要排序的范围是0-100万，使用桶排序方法进行排序，那么我们要准备100万个桶，这显然对于计算机的开销肯定很大，所以，桶排序在有这时间最快的优势，同时也有这及其耗费内存的缺点。 相关问题 Leetcode-347-Top-K-Frequent-Elements Leetcode 451. Sort Characters By Frequency 9. 荷兰国旗问题 荷兰国旗包含三种颜色：红、白、蓝。 有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。 它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色 相关问题 Sort Colors 自定义比较函数的书写方式 方法1：声明外部比较函数 bool Less(const Student& s1, const Student& s2) { return s1.name 注意：比较函数必须写在类外部（全局区域）或声明为静态函数 当comp作为类的成员函数时，默认拥有一个this指针，这样和sort函数所需要使用的排序函数类型不一样。 否则，会出现错误 方法2：重载类的比较运算符 bool operator 方法3：声明比较类 struct Less { bool operator()(const Student& s1, const Student& s2) { return s1.name Related Problems Merge Sorted Array Merge Two Sorted Lists Merge k Sorted Lists Insertion Sort Lists Sort Lists First Missing Positive Sort Colors Leetcode 969. Pancake Sorting Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/2019-02-18-Leetcode-Search-problems.html":{"url":"summary/2019-02-18-Leetcode-Search-problems.html","title":"Search Combination","keywords":"","body":"Combination Leetcode 17. Letter Combinations of a Phone Number 这就是一对一翻译的情况，没有特殊处理 class Solution { public: vector letterCombinations(string digits) { if (digits.empty()) return {}; vector ans; string cur; string dict[] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; letterCombinationsDFS(digits, dict, 0, cur, ans); return ans; } void letterCombinationsDFS(const string& digits, string dict[], int index, string& out, vector& ans) { if (index == digits.length()) { ans.emplace_back(out); return; } for (char c : dict[digits[index] - '0']) { out.push_back(c); letterCombinationsDFS(digits, dict, index + 1, out, ans); out.pop_back(); } } }; Leetcode 77. Combinations 计算一个数组里面可能的所有组合，这道题目唯一的要求就是同一个位置的数据不出现多遍就好 // Runtime: 104 ms, faster than 71.52% of C++ online submissions for Combinations. // Memory Usage: 11.7 MB, less than 100.00% of C++ online submissions for Combinations. class Solution { public: vector> combine(int n, int k) { vector> ans; vector out; ans.reserve(k); combineDFS(n, k, 1, out, ans); return ans; } private: void combineDFS(int n, int k, int index, vector& out, vector>& ans) { if (k == 0) { ans.emplace_back(out); return; } for (int i = index; i Leetcode 39. Combination Sum 同一个数据可以多次使用 class Solution { public: vector> combinationSum(vector& candidates, int target) { if (candidates.empty()) return {{}}; sort(candidates.begin(), candidates.end()); vector> ans; vector out; combinationSumDFS(candidates, target, 0, out, ans); return ans; } void combinationSumDFS(vector& candidates, int target, int index, vector& out, vector>& ans) { if (target == 0) { ans.emplace_back(out); return; } for (int i = index; i target) break; out.push_back(candidates[i]); combinationSumDFS(candidates, target - candidates[i], i, out, ans); out.pop_back(); } } }; Leetcode 40. Combination Sum II 同一个数据不可以多次使用 class Solution { public: vector> combinationSum2(vector& candidates, int target) { vector> ans; sort(candidates.begin(), candidates.end()); vector out; combinationSum2DFS(candidates, target, 0, out, ans); return ans; } private: void combinationSum2DFS(vector& c, int target, int index, vector& out, vector>& ans) { if (target == 0) { ans.emplace_back(out); return; } for (int i = index; i index && c[i] == c[i - 1]) continue; if (c[i] > target) break; out.emplace_back(c[i]); combinationSum2DFS(c, target - c[i], i + 1, out, ans); out.pop_back(); } } }; Leetcode 216. Combination Sum III Given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. (The solution set must not contain duplicate combinations.) class Solution { public: vector> combinationSum3(int k, int n) { vector> ans; vector out; combinationSum3DFS(k, n, 1, out, ans); return ans; } private: void combinationSum3DFS(int k, int target, int index, vector& out, vector>& ans) { if (out.size() == k) { if (target == 0) ans.emplace_back(out); return; } for (int i = index; i Leetcode 78. Subsets // Runtime: 8 ms, faster than 100.00% of C++ online submissions for Subsets. // Memory Usage: 9 MB, less than 100.00% of C++ online submissions for Subsets. class Solution { public: vector> subsets(vector& nums) { if (nums.empty()) return {{}}; sort(nums.begin(), nums.end()); vector> ans; vector out; ans.emplace_back(out); subsetsDFS(nums, 0, out, ans); return ans; } private: void subsetsDFS(vector& nums, int index, vector& out, vector>& ans) { if (index == nums.size()) return; for (int i = index; i Leetcode 90. Subsets II class Solution { public: vector> subsetsWithDup(vector& nums) { if (nums.empty()) return {{}}; vector> ans; sort(nums.begin(), nums.end()); vector out; ans.emplace_back(out); subsetsWithDupDFS(nums, 0, out, ans); return ans; } private: void subsetsWithDupDFS(vector& nums, int index, vector& out, vector>& ans) { if (index == nums.size()) return; for (int i = index; i index && nums[i] == nums[i - 1]) continue; out.emplace_back(nums[i]); ans.emplace_back(out); subsetsWithDupDFS(nums, i + 1, out, ans); out.pop_back(); } } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/2019-01-15-Algorithms-Binary-Search.html":{"url":"summary/2019-01-15-Algorithms-Binary-Search.html","title":"Binary Search","keywords":"","body":" All the pictures in this post are coming from the video: 花花酱 LeetCode Binary Search - 刷题找工作 SP5 Summary What is Binary Search? Why we need Binary Search. Template Template 1: Unique and sorted elements Template 2: Repetitive and sorted elements Relative Questions Upper Bound Find First And Last Position Of Element In Sorted Array(LC.34) Search Insert Position(LC.35) Binary Search(LC.704) Time Based Key Value Store(LC.981) Sqrt x 3(LC.69) Rotated & Peak Search In Rotated Sorted Array(LC.33) Search In Rotated Sorted Array II(LC.81) Find Minimum in Rotated Sorted Array(LC.153)) Find Minimum in Rotated Sorted Array II(LC.154) Find Peak Element(LC.162) Peak Index in a Mountain Array(LC.852) Summary Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you've narrowed down the possible locations to just one. For example, binary search in the guessing game. Here, try it for a number from 1 to 300. You should need no more than 9 guesses. Here's a step-by-step description of using binary search to play the guessing game: Let min = 1 min=1 and max = nmax=n. Guess the average of maxmax and minmin, rounded down so that it is an integer. If you guessed the number, stop. You found it! If the guess was too low, set minmin to be one larger than the guess. If the guess was too high, set maxmax to be one smaller than the guess. Go back to step two. The feature for the Binary Search is: Fast, Fast, Fast. O(log(n)) What is Binary Search? The requirment for the Binary Search is the sorted input data. Each node needs to make decision go to left or right. For the Binary Search method, the input data will include three partition: Mid, left array, right array. If the mid number is less than the target number, then go to right array to find the target number. If the mid number is larger than the target number, then go to left array to find the target number. When you go to the left or right way, you can choose the recursive function or not recursive function to solve it. The answer for this question is that the last mid point is the target number which you want to find if there is a target number in the array. If there is no target number in the array, when you find the last mid number and then you can return false or use this number to do something. Why we need Binary Search. There are some states for the above picture: The O(eval) is the time to compare the mid number with the target number and the search space need to move to left part or right part. It may be: O(1), O(n), or O(logn). SO, you can use the input dataset range to choose which mothod you can use to solve this problem. There are two tips which you can use to think which method is good for you to solve this problem. Template Template 1: Unique and sorted elements Include the left data, but not include the right side. def binary_search(1,r): while l As the above picture, if the input element is unique and sorted, then we can easily use this template to deal with these similar problems. Like the example 1. If the Input data's element is not unique. And it have repetitive numbers. Template 2: Repetitive and sorted elements The lower_bound function will return the first index of i, such that A[i] >= x, So, when you find it, you need to check out if this A[i] may not = x. If the index > len, then there is no number > this. Example Leetcode 69 It is not way to find the real number to fit the requrtment. So, we can find the number the first time bigger than the input. Relative Questions 二分查找算法在实际使用中可能会出现各种变体，我们要抓住有序的特点，一旦发现输入有有序的特点，我们就可以考虑是否可以运用二分查找算法来解决该问题。 Questions: Search In Rotated Sorted Array Search In Rotated Sorted Array II Search Insert Position Online Election Preimage Size of Factorial Zeroes Function K th Smallest Prime Fraction Find Smallest Letter Greater Than Target Find K th Smallest Pair Distance Relative Ranks Find K th Smallest Pair Distance Search a 2D Matrix Sqrt x 3 Upper Bound Find First And Last Position Of Element In Sorted Array(LC.34) 问题：在一个有序的数组中，找到一个元素的第一个位置以及最后一个位置。 class Solution { public: vector searchRange(vector& nums, int target) { vector res(2, -1); int left = 0, right = nums.size() - 1; while (left Search Insert Position(LC.35) 在一个有序数组中找到一个位置，插入 target 的数字，插入之后，数组依旧保持有序 class Solution { public: int searchInsert(vector& nums, int target) { if (nums.back() Binary Search(LC.704) Problem: Given a sorted (in ascending order) integer array nums of n elements and a targetvalue, write a function to search target in nums. If target exists, then return its index, otherwise return -1. Time complexity: O(log n), Space complexity: O(1) class Solution { public: int search(vector& nums, int target) { int left = 0, right = nums.size(); while (left Time Based Key Value Store(LC.981) Solution: HashTable + Map class TimeMap { public: /** Initialize your data structure here. */ TimeMap() {} void set(string key, string value, int timestamp) { s_[key].emplace(timestamp, std::move(value)); } string get(string key, int timestamp) { auto m = s_.find(key); if (m == s_.end()) return \"\"; auto it = m->second.upper_bound(timestamp); if (it == begin(m->second)) return \"\"; return prev(it)->second; } private: unordered_map> s_; }; Sqrt x 3(LC.69) Time Complexity: O(log n), Space Complexity: O(1) class Solution { public: int mySqrt(int x) { if (x Rotated & Peak Search In Rotated Sorted Array(LC.33) Time complexity: O(log n) Space complexity: O(1) class Solution { public: int search(vector& nums, int target) { int left = 0, right = nums.size(); while (left != right) { const int mid = left + (right - left) / 2; // Find the Target at the mid index. if (nums[mid] == target) return mid; // There are sorted elements in the left part. if (nums[left] target && nums[left] = target ? left = mid + 1 : right = mid; } } return -1; } }; Search In Rotated Sorted Array II(LC.81) Time complexity: O(logn) Space complexity: O(1) class Solution { public: bool search(vector& nums, int target) { int left = 0, right = nums.size(); while (left != right) { const int mid = left + (right - left) / 2; // Find the Target at the mid index. if (nums[mid] == target) return true; // There are sorted elements in the left part. if (nums[left] target) { right = mid; } else { left = mid + 1; } } else if (nums[left] == nums[mid]) { left++; } else { // There are sorted elements in the right part. if (nums[mid] = target) { left = mid + 1; } else { right = mid; } } } return false; } }; Find Minimum in Rotated Sorted Array(LC.153)) Time Complexity: O(log n), Space Complexity:O(1) class Solution { public: int findMin(vector& nums) { int left = 0, right = nums.size() - 1; if (nums[left] left value, then move the right part search. if (nums[mid] > nums[left]) left = mid; else right = mid; } return min(nums[left], nums[right]); } }; Find Minimum in Rotated Sorted Array II(LC.154) class Solution { public: int findMin(vector& nums) { int left = 0, right = nums.size() - 1, ans = nums[0]; if (nums[left] left value, then move the right part search. if (nums[left] nums[mid]) right = mid; else ++left; } return min(ans, min(nums[left], nums[right])); } }; Find Peak Element(LC.162) 题目要求是 O(log n) 的时间复杂度，考虑使用类似于二分查找法来缩短时间。由于只是需要找到任意一个峰值，那么我们在确定二分查找折半后中间那个元素后，和紧跟的那个元素比较下大小，如果大于，则说明峰值在前面，如果小于则在后面。这样就可以找到一个峰值了。 class Solution { public: int findPeakElement(vector& A) { // Binary Search int left = 0, right = A.size() - 1; while (left Peak Index in a Mountain Array(LC.852) Time complexity: O(log n), Space Complexity: O(1) class Solution { public: int peakIndexInMountainArray(vector& A) { // Binary Search int left = 0, right = A.size(); while (left A[mid + 1]) right = mid; // For the left part else left = mid + 1; } return left; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/2019-01-10-Leetcode-Recursion-And-Dynamic-Programming.html":{"url":"summary/2019-01-10-Leetcode-Recursion-And-Dynamic-Programming.html","title":"Recursion And Dynamic Programming","keywords":"","body":"Recursion and Dynamic Programming There are a large number of recursive problems, many follow similar patterns. A goof hint: A problem is recursive is that it can be build off of subproblems. A good candidate for recursion: Design an algorithm to compute the n-th... Write code to list the first n ... Implement a method to compute all ... First of the thing: Recognize recursive problems How to approach Three of the most common approaches to develop an algorithm are bottom-up, Top-Down-Approach and Half-and-half. Bottom-Up approach Start with knowing how to solve the problem from a simple case, one element, two elements, three elements ... and so on. The key here is to think about how you can build the solution for one case off of the previous case (Or multiple previous case.) Top-Down Approach Think about how we can divide the problem for case N into subproblems. Be careful overlap between the cases. Half-And-Half Approach(Often) Divide the data set in half. For example, binary search works with a half-and-half approach. When we look for an elements in a sorted array, we first figure out which half of the array contains the value. Then we recurse and search fro it in that half. Merge Sort is also a half-and-half approach. We sort each half of the array and then merge together the sorted halves. All recursive algorithms can be implemented iteratively, although sometimes the code to do so is much more complex. Dynamic Programming & Memoization For example-Fibonacci Numbers.(Leetcode 509. Fibonacci Number) int fibonacci(int i) { if (i == 0) return 0; if (i == 1) return 1; return fibonacci(i - 1) + fibonacci(i - 2); } Optimize(Top-Down Dynamic Programming(Or Memoization) int fibonacci(int n) { return fibonacci(n, new int[n + 1]; } int fibonacci(int i, int [] memo) { if (i == 0 || i == 1) return i; if (memo[i] == 0) { memo[i] = fibonacci(i - 1, memo) + fibonacci(i - 2, memo); } return memo[i]; } Buttom-Up Dynamic Programming int fibonacci(int n) { if (n == 0) return 0; else if (n == 1) return 1; int [] memo = new int[n]; memo[0] = 0; memo[1] = 1; for(int i = 2; i We don't need the meno[n], we use a, b: int fibonacci(int n) { if (n == 0) return 0; int a = 0, b = 1; for (int i = 2; i Relative Questions Q1. Climbing Stairs / Triple Step. (Leetcode 70. Climbing-Stairs) Q2. Robot in a Grid. Imagine a robot sitting on the upper left hand corner of an NxN grid. The robot can only move in two directions: right and down. How many possible paths are there for the robot? (Leetcode 64. Unique Paths) Q3. Magic Index. Q4. Power set. Write a method that returns all subsets of a set.(Leetcode 78. Subsets) Q5. Recursive Multiply. Q6. Tower of Hanoi. Q7. Permutations without Dups. Q8. Permutations with Dups. Q9. Parens. Q10. Paint Fill. Q11. Coins. Q12. Eight Queens. Q13. Stack of Boxes. Q14. Boolean Evaluation. Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"summary/Leetcode-Array-String-Summary.html":{"url":"summary/Leetcode-Array-String-Summary.html","title":"Summary","keywords":"","body":"Array & String Summary Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"Leetcode-209-Minimum-Size-Subarray-Sum.html":{"url":"Leetcode-209-Minimum-Size-Subarray-Sum.html","title":"Minimum Size Subarray Sum","keywords":"","body":"Leetcode 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example: Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). Difficulty:Medium Category: Solution Time complexity: O(n), Space complexity: O(1) class Solution { public: int minSubArrayLen(int s, vector& nums) { int n = nums.size(), left = 0, right = 0, ans = INT_MAX; int sum = 0; for (right = 0; right = s) { ans = min(ans, right - left + 1); sum -= nums[left++]; } } return ans == INT_MAX ? 0 : ans; } }; Relative problem Leetcode 76. Minimum Window Substring Leetcode 209. Minimum Size Subarray Sum Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-325-Maximum-Size-Subarray-Sum-Equal-k.html":{"url":"Leetcode-325-Maximum-Size-Subarray-Sum-Equal-k.html","title":"Maximum Size Subarray Sum Equals k","keywords":"","body":"Leetcode 325. Maximum Size Subarray Sum Equals k Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead. Example 1: Given nums = [1, -1, 5, -2, 3], k = 3,return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest) Example 2: Given nums = [-2, -1, 2, 1], k = 1,return 2. (because the subarray [-1, 2] sums to 1 and is the longest) Follow Up:Can you do it in O(n) time? Difficulty:Medium Category: Analyze 这道题给我们一个一维数组nums，让我们求和为k最大子数组，默认子数组必须连续，题目中提醒我们必须要在O(n)的时间复杂度完成. Solution 该方案来自于博客文章：Maximum Size Subarray Sum Equals k 最大子数组之和为k class Solution { public: int maxSubArrayLen(vector& nums, int k) { // sum: 累加 int sum = 0, res = 0; unordered_map m; // [value -> lastindex] for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-560-Subarray-Sum-Equals-K.html":{"url":"Leetcode-560-Subarray-Sum-Equals-K.html","title":"Subarray Sum Equals K","keywords":"","body":"Leetcode 560. Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input: nums = [1,1,1], k = 2, Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. Difficulty:Medium Category:Array, Hash-Table Solution class Solution { public: int subarraySum(vector& nums, int k) { int ans = 0; const int len = nums.size(); vector sum(len + 1, 0); // s[i] is the sum from 0 to i - 1; for (int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-862-Shortest-Subarray-with-Sum-at-Least-K.html":{"url":"Leetcode-862-Shortest-Subarray-with-Sum-at-Least-K.html","title":"Shortest Subarray with Sum at Least K","keywords":"","body":"Question Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1. Example 1: Input: A = [1], K = 1 Output: 1 Example 2: Input: A = [1,2], K = 4 Output: -1 Example 3: Input: A = [2,-1,2], K = 3 Output: 3 Note: 1 -10 ^ 5 1 Difficulty:Medium Category: Solution Solution 1: Error---Time Limit Exceeded Runtime: 7164 ms, faster than 2.70% of C++ online submissions for Shortest Subarray with Sum at Least K. Memory Usage: 7.3 MB, less than 54.72% of C++ online submissions for Shortest Subarray with Sum at Least K. class Solution { public: int shortestSubarray(vector& A, int K) { int ans = INT_MAX; A.insert(A.begin(), 0); const int n = A.size(); for (int i = 1; i = K) { ans = min(j + 1 - i, ans); break; } } } if (ans == INT_MAX) return -1; return ans; } }; Solution 2 解法来源于: C++/Java/Python O(N) Using Deque-Using-Deque) class Solution { public: int shortestSubarray(vector A, int K) { int n = A.size(), res = n + 1; vector B(n + 1, 0); for (int i = 0; i d; for (int i = 0; i 0 && B[i] - B[d.front()] >= K) { res = min(res, i - d.front()); d.pop_front(); } // If B[i] 0 && B[i] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-978-Longest-Turbulent-Subarray.html":{"url":"Leetcode-978-Longest-Turbulent-Subarray.html","title":"Longest Turbulent Subarray","keywords":"","body":"Question A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if: For i , A[k] > A[k+1] when k is odd, and A[k] when k is even; OR, for i , A[k] > A[k+1] when k is even, and A[k] when k is odd. That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray. Return the length of a maximum size turbulent subarray of A. Example 1: Input: [9,4,2,10,7,8,8,1,9] Output: 5 Explanation: (A[1] > A[2] A[4] Example 2: Input: [4,8,12,16] Output: 2 Example 3: Input: [100] Output: 1 Note: 1 0 Difficulty:Medium Category: Array Solution class Solution { public: int maxTurbulenceSize(vector& A) { if (A.empty()) return 0; if (A.size() == 1) return 1; int len = A.size(); int cur = 1; int ans = 1; bool less = false; for (int i = 1; i A[i - 1]) { ++cur; ans = max(cur, ans); } else cur = 1; } else { less = false; if (A[i] A[i - 1]) { ++cur; ans = max(cur, ans); } else cur = 1; } else { less = false; if (A[i] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-974-Subarray-Sums-Divisible-by-K.html":{"url":"Leetcode-974-Subarray-Sums-Divisible-by-K.html","title":"Subarray Sums Divisible by K","keywords":"","body":"Question Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K. Example 1: Input: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Note: 1 -10000 2 Difficulty:Medium Category:Array Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-485-Max-Consecutive-Ones.html":{"url":"Leetcode-485-Max-Consecutive-Ones.html","title":"Max Consecutive Ones","keywords":"","body":"Question Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 Difficulty:Easy Category:Array Solution class Solution { public: int findMaxConsecutiveOnes(vector& nums) { int res = 0, temp = 0; for (int x : nums) { x ? temp++ : temp = 0; res = max(res, temp); } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-992-Subarrays-with-K-Different-Integers.html":{"url":"Leetcode-992-Subarrays-with-K-Different-Integers.html","title":"Subarrays with K Different Integers(LC.992)","keywords":"","body":"Leetcode 992. Subarrays with K Different Integers Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K. (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.) Return the number of good subarrays of A. Example 1: Input: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. Example 2: Input: A = [1,2,1,3,4], K = 3 Output: 3 Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4]. Difficulty:Hard Category: Solution Solution 1: From devidxu in leetcode Weekly contest 123. class Solution { public: int subarraysWithKDistinct(vector& A, int K) { int idx = 0, result = 0; unordered_map counter; int start = 0, end = 0; if (K == 0) return 0; while (idx & A, int& start, int& end, int k, unordered_map& counter) { // Remove the first element count-- while (start k, then we need to while (end Solution 2: class Solution { public: int subarraysWithKDistinct(vector& A, int K) { return count(A, K) - count(A, K - 1); } private: int count(vector& a, int K) { int n = a.size(); vector f(n + 1, 0); int diff = 0; int prev = 0; int ret = 0; for (int i = 0; i K) { if (--f[a[prev++]] == 0) { diff--; } } ret += i - prev + 1; } return ret; } }; Solution 3 typedef long long ll; typedef vector VI; typedef pair PII; #define REP(i, s, t) for (int i = (s); i &A, int K) { return solve(A, K) - solve(A, K + 1); } private: // Remove the first element void remove(map &cnt, int v) { if (--cnt[v] == 0) cnt.erase(v); } int solve(VI &A, int K) { int n = A.size(); map cnt; int j = 0, ans = 0; REP(i, 0, n) { cnt[A[i]]++; while (cnt.size() >= K) remove(cnt, A[j++]); ans += j; } return ans; } }; Follow up Give an array of letters and a window size k, return subarrays of size k with no duplicates Solution: Two pointers + indirection Let f(x) denote the number of subarrays with x or less distinct numbers. ans = f(K) – f(K-1) It takes O(n) Time and O(n) Space to compute f(x) // Author: Huahua // vector: 56 ms, 10.1 MB // Hashtable: 126 ms, 25 MB class Solution { public: int subarraysWithKDistinct(vector& A, int K) { // Returns the number of subarrays with k or less distinct numbers. auto subarrys = [&A](int k) { vector count(A.size() + 1); int ans = 0; int i = 0; for (int j = 0; j Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-581-Shortest-Unsorted-Continuous-Subarray.html":{"url":"Leetcode-581-Shortest-Unsorted-Continuous-Subarray.html","title":"Shortest Unsorted Continuous Subarray(LC.581)","keywords":"","body":"Question Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length. Example 1: Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Note: Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means . Difficulty:Easy Category: Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-1020-Partition-Array-Into-Three-Parts-With-Equal-Sum.html":{"url":"Leetcode-1020-Partition-Array-Into-Three-Parts-With-Equal-Sum.html","title":"Partition Array Into Three Parts With Equal Sum(LC.1020)","keywords":"","body":"Question Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i+1 with (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) Example 1: Input: [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 Example 2: Input: [0,2,1,-6,6,7,9,-1,2,0,1] Output: false Example 3: Input: [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 Note: 3 -10000 Difficulty:Easy Category: Solution Time complexity: O(n), Space complexity: O(1) class Solution { public: bool canThreePartsEqualSum(vector& A) { int sum = 0; for (int& a : A) sum += a; if (sum % 3 != 0) return false; int target = sum / 3; int preSum = 0, ind1 = -1, ind2 = -1; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-1-Two-Sum.html":{"url":"Leetcode-1-Two-Sum.html","title":"Two Sum-HashTable","keywords":"","body":"Question Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.Example: Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Difficulty:Easy Category:Array Analyze 这道题目给了我们一个数组以及一个目标数target, 让我们在数组中找到这两个数字, 使其和为target. 这道题目的输入保证了一定会找到这样的一对数据,所以就不用判断输入数据不符合的情况了. O(n^2) runtime, O(1) space – Brute force 如果使用暴力搜索，那么时间复杂度为O(n^2))，这会造成Time Limit Exceeded. 所以需要使用O(n)的算法来实现。 O(n) runtime, O(n) space – Hash table 先遍历一遍数组，建立HashMap数据 第二遍遍历，开始查找，如果找到，则记录下来 Solution Solution 1 class Solution { public: vector twoSum(vector& nums, int target) { unordered_map numsMap; vector ans; ans.reserve(2); for (int i = 0; i i) { ans.emplace_back(i); ans.emplace_back(numsMap[diff]); return ans; } } return ans; } }; 优化: 合并两个for循环语句 class Solution { public: vector twoSum(vector& nums, int target) { unordered_map numsMap; for (int i = 0; i 当然,我们將if (numsMap.find(diff) != numsMap.end()) 修改为if (m_.count(diff))也是可以的,都是判断在HashTable里面是否有该元素. Solution 2 这道题目我们可以选择先进行排序的方式来处理: Step 1: Sort the numbers (We'll soon see how this can be done in $O(N \\log N)$ time). Step 2: For each number X in the array, use Binary Search to see 42 - X is also present in the array. Total Time: $N * O(\\log n) = O(N \\log N)$. Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-167-Two-Sum-II-Input-Array-Is-Sorted.html":{"url":"Leetcode-167-Two-Sum-II-Input-Array-Is-Sorted.html","title":"Two Sum II Input Array Is Sorted","keywords":"","body":"Question Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. Analyze 这道题目完全可以使用Two-Sum的解法代码一模一样的来解决这个题目的: Two-Sum class Solution { public: vector twoSum(vector& numbers, int target) { unordered_map numsMap; for (int i = 0; i 但是这一个题目是排序之后的,所有我们要寻找一些更快捷的方式来解决该题目. 使用二分搜索的方式 solution class Solution { public: vector twoSum(vector& numbers, int target) { vector res; res.reserve(2); for (int i = 0; i val) right = mid - 1; else if (numbers[mid] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-Interview-Amazon-OA2-2Sum-Closest.html":{"url":"Leetcode-Interview-Amazon-OA2-2Sum-Closest.html","title":"2Sum Closest(Interview)","keywords":"","body":"// 2Sum Closest int twoSumClosest(vector& nums, int target) { sort(nums.begin(), nums.end()); int diff = INT_MAX, res; int i = 0, j = nums.size() - 1; while (i target) j--; else break; } return res; } Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:19 "},"Leetcode-15-3Sum.html":{"url":"Leetcode-15-3Sum.html","title":"3Sum","keywords":"","body":"3Sum Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Difficulty:Easy Category:Array Solution 思路1：夹逼法(时间复杂度O(n^2)) 先排序，然后查每一个数后面两数之和为当前数相反数的所有可能。 思路2（未实现） 不排序，先做2数和的倒排索引，查每一个数是否有相应的2数和为其相反数。O(n^3) Solution 1: 补充知识：ArrayList in Java 需要处理数组长度小于 3 的边界情况。 class Solution { public: vector> threeSum(vector& nums) { vector> ans; if (nums.size() 0) break; if (i > 0 && nums[i] == nums[i - 1]) continue; int left = i + 1, right = nums.size() - 1; while (left 0) { --right; } else { ++left; } } } return ans; } }; 思路:求三数之和，比之前那道Two Sum要复杂一些 先Fix一个数，然后另外两个数使用Two Sum那种HashMap的解法，但是会有重复结果出现，就算使用set来去除重复也不行，会TLE，看来此题并不是考我们Two Sum的解法。 那么我们来分析一下这道题的特点，要我们找出三个数且和为0，那么除了三个数全是0的情况之外，肯定会有负数和正数。 先fix一个数，然后去找另外两个数，我们只要找到两个数且和为第一个fix数的相反数就行了，既然另外两个数不能使用Two Sum的那种解法来找，如果能更有效的定位呢？我们肯定不希望遍历所有两个数的组合吧，所以如果数组是有序的，那么我们就可以用双指针以线性时间复杂度来遍历所有满足题意的两个数组合。 思路1： 我们对原数组进行排序，然后开始遍历排序后的数组，这里注意不是遍历到最后一个停止，而是到倒数第三个就可以了。这里我们可以优化一下： 就是当遍历到正数的时候就break，为啥呢，因为我们的数组现在是有序的了，如果第一个要fix的数就是正数了，那么后面的数字就都是正数，就永远不会出现和为0的情况了。 然后我们还要加上重复就跳过的处理，处理方法是从第二个数开始，如果和前面的数字相等，就跳过，因为我们不想把相同的数字fix两次。对于遍历到的数，用0减去这个fix的数得到一个target，然后只需要再之后找到两个数之和等于target即可。 我们用两个指针分别指向fix数字之后开始的数组首尾两个数，如果两个数和正好为target，则将这两个数和fix的数一起存入结果中。然后就是跳过重复数字的步骤了，两个指针都需要检测重复数字。如果两数之和小于target，则我们将左边那个指针i右移一位，使得指向的数字增大一些。同理，如果两数之和大于target，则我们将右边那个指针j左移一位，使得指向的数字减小一些，代码如下： Solution 先排序,然后左右夹逼, 跳过重复的数据, 时间复杂度O(n^2), 空间复杂度 O(1) class Solution { public: vector> threeSum(vector& nums) { set> res; sort(nums.begin(), nums.end()); for (int k = 0; k 0) break; int target = 0 - nums[k]; int i = k + 1, j = nums.size() - 1; while (i >(res.begin(), res.end()); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-16-3Sum-Closest.html":{"url":"Leetcode-16-3Sum-Closest.html","title":"3Sum Closest","keywords":"","body":"Problem Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Difficulty:Medium Category:Array Solution class Solution { public: int threeSumClosest(vector& nums, int target) { if (nums.size() newDiff) { diff = newDiff; closest = sum; } if (sum Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-18-4Sum.html":{"url":"Leetcode-18-4Sum.html","title":"4Sum","keywords":"","body":"Question Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] Difficulty:Medium Category:Array, Hash Table, Two Points. Analyze 方案一： 对数组进行排序，然后固定两个值，寻找另外两个数值，左右夹逼的方式，这种情况的时间复杂度是O(n^3) 方案二： 使用一个Hashmap先缓存两个数的和，时间复杂度：平均O(n^2), 最差O(n^4), 空间复杂度O(n^2) Solution Solution 1（方案一）:先排序固定两个数值，然后夹逼的方式 class Solution { public: vector> fourSum(vector &nums, int target) { set> res; sort(nums.begin(), nums.end()); for (int i = 0; i i + 1 && nums[j] == nums[j - 1]) continue; int left = j + 1, right = nums.size() - 1; while (left out{nums[i], nums[j], nums[left], nums[right]}; res.insert(out); ++left; --right; } else if (sum >(res.begin(), res.end()); } }; Solution 2（方案一）:先排序固定两个数值，然后夹逼的方式 第二种代码风格，来自：《Leetcode 题解》 class Solution { public: vector> fourSum(vector &nums, int target) { vector> res; if (nums.size() target) { --d; } else { res.push_back({*a, *b, *c, *d}); ++c; --d; } } } } // Remove the repeating elements. sort(res.begin(), res.end()); res.erase(unique(res.begin(), res.end()), res.end()); return res; } }; Solution 3（方案二）:HashMap 第二种代码风格，来自：《Leetcode 题解》 class Solution { public: vector> fourSum(vector& nums, int target) { vector> res; if (nums.size() >> cache; for (size_t a = 0; a (a, b)); } } for (int c = 0; c Leetcode Question Summary 不能使用Vector emplace_back函数的情况 （方案二） 如果要放入vector里面的内容，是一个数组，那么就不能够使用emplac_back 函数，需要使用push_bach函数。 Error vector> res; res.emplace_back({*a, *b, *c, *d}); True vector> res; res.push_back({*a, *b, *c, *d}); Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-41-First-Missing-Positive.html":{"url":"Leetcode-41-First-Missing-Positive.html","title":"First Missing Positive","keywords":"","body":"Question Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Difficulty:Medium Category:Array Solution class Solution { public: int firstMissingPositive(vector& nums) { vec_sort(nums); for (int i = 0; i & nums) { // Build a array to store the numsbers const unsigned int len_n = nums.size(); for (int i = 0; i len_n || nums[i] == nums[nums[i] - 1]) break; swap(nums[i], nums[nums[i] - 1]); } } } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-448-Find-All-Numbers-Disappeared-In-An-Array.html":{"url":"Leetcode-448-Find-All-Numbers-Disappeared-In-An-Array.html","title":"Find All Numbers Disappeared In An Array","keywords":"","body":"Question Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input: [4,3,2,7,8,2,3,1] Output: [5,6] Difficulty:Easy Category:Array Analyze 这道题目可以说是： Leetcode 41. First Missing Positive题目的升级版，只需要将找到的丢失的数据一次存下来就好了，可以延续使用那一道题目的代码。 Solution class Solution { public: vector findDisappearedNumbers(vector& nums) { vector res; vec_sort(nums); for (int i = 0; i & nums) { // Build a array to store the numsbers const unsigned int len_n = nums.size(); for (int i = 0; i len_n || nums[i] == nums[nums[i] - 1]) break; swap(nums[i], nums[nums[i] - 1]); } } } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-268-Misssing-Number.html":{"url":"Leetcode-268-Misssing-Number.html","title":"Misssing Number","keywords":"","body":"Quesiton Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2 Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8 Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Solution class Solution { public: int missingNumber(vector& nums) { int sum = 0, len = nums.size(); for (int i : nums) sum += i; return len * (len + 1) / 2 - sum; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-540-Single-Element-in-a-Sorted-Array.html":{"url":"Leetcode-540-Single-Element-in-a-Sorted-Array.html","title":"Single Element in a Sorted Array","keywords":"","body":"Question Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once. Example 1: Input: [1,1,2,3,3,4,4,8,8] Output: 2 Example 2: Input: [3,3,7,7,10,11,11] Output: 10 Note: Your solution should run in O(log n) time and O(1) space. Difficulty:Medium Category:Binary-Search Solution class Solution { public: int singleNonDuplicate(vector& nums) { int left = 0, right = nums.size(); while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-136-Single-Number.html":{"url":"Leetcode-136-Single-Number.html","title":"Single Number(unsorted)","keywords":"","body":"Question Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 Difficulty:Medium Category:HashTable, BitManipulation Solution class Solution { public: int singleNumber(vector& nums) { int res = 0; for (auto i : nums) res ^= i; return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-137-Single-Number-II.html":{"url":"Leetcode-137-Single-Number-II.html","title":"Single Number II","keywords":"","body":"Question Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,3,2] Output: 3 Example 2: Input: [0,1,0,1,0,1,99] Output: 99 Difficulty:Medium Category:Bit Manipulation Solution class Solution { public: int singleNumber(vector& nums) { int res = 0; const int len_int = sizeof(int) * 8; int count[len_int]; fill_n(&count[0], len_int, 0); for (int i = 0; i > j) & 1; } } for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-260-Single-Number-III.html":{"url":"Leetcode-260-Single-Number-III.html","title":"Single Number III(LC.260)","keywords":"","body":"Question Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Input: [1,2,1,3,2,5] Output: [3,5] Note: The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? Difficulty:Medium Category: Analyze 两个不相等的元素一定有一位是不相同的, 所有当我们將所有元素都异或之后, 得到的是两个不存在重复的两个元素异或的结果: 根据 d &= -d可以得到最右边不为0的位, 这一位就是这两个不同的元素的其中一个不同的地方, 我们利用这一位, 將所有元素分成两类, 分别在进行异或一次, 就可以筛选出来不同的元素. 时间复杂度: O(n) Solution class Solution { public: vector singleNumber(vector& nums) { int diff = 0; for (int& num : nums) diff ^= num; diff &= -diff; vector ans(2, 0); for (int& num : nums) { if (num & diff) ans[0] ^= num; else ans[1] ^= num; } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-169-Majority-Element.html":{"url":"Leetcode-169-Majority-Element.html","title":"Majority Element","keywords":"","body":"Question Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2 Difficulty:Easy Category:Array Solution class Solution { public: int majorityElement(vector& nums) { std::unordered_map counts; for (int x : nums) { std::unordered_map::iterator got = counts.find(x); if (got == counts.end()) counts.insert({x, 1}); else got->second++; } for (auto& x : counts) { if (x.second > nums.size() / 2) return x.first; } return 0; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-645-Set-Mismatch.html":{"url":"Leetcode-645-Set-Mismatch.html","title":"Set Mismatch","keywords":"","body":"Question The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array. Example 1: Input: nums = [1,2,2,4] Output: [2,3] Note: The given array size will in the range [2, 10000]. The given array's numbers won't have any order. Difficulty:Easy Category:Hash-Table, Math Solution class Solution { public: vector findErrorNums(vector& nums) { for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-287-Find-the-Duplicate-Number.html":{"url":"Leetcode-287-Find-the-Duplicate-Number.html","title":"Find the Duplicate Number","keywords":"","body":"Question Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2 Example 2: Input: [3,1,3,4,2] Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(_n_2). There is only one duplicate number in the array, but it could be repeated more than once. Difficulty:Medium Category:Array, Two-Points, Binary-Search Solution Solution1: Binary Search // Time Complexity: O(nlog n) // Space Complexity: O(1) class Solution { public: int findDuplicate(vector& nums) { int left = 0, right = nums.size(); while (left Solution 2: Two-Points // Author: Huahua // Running time: 4 ms class Solution { public: int findDuplicate(vector& nums) { int slow = 0; int fast = 0; while (true) { // Each step: the slow point move one step // Each step: the fast point move two steps slow = nums[slow]; fast = nums[nums[fast]]; if (slow == fast) break; } fast = 0; while (fast != slow) { slow = nums[slow]; fast = nums[fast]; } return slow; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-442-Find-All-Duplicates-In-An-Array.html":{"url":"Leetcode-442-Find-All-Duplicates-In-An-Array.html","title":"Find All Duplicates In An Array","keywords":"","body":"Question Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? Example: Input: [4,3,2,7,8,2,3,1] Output: [2,3] Difficulty:Medium Category:Array Solution class Solution { public: vector findDuplicates(vector& nums) { vector res; vec_sort(nums); for (int i = 0; i & nums) { // Build a array to store the numsbers const unsigned int len_n = nums.size(); for (int i = 0; i len_n || nums[i] == nums[nums[i] - 1]) break; swap(nums[i], nums[nums[i] - 1]); } } } }; Similar Questions 2018-12-17-Leetcode-448-Find-All-Numbers-Disappeared-In-An-Array 2018-12-16-Leetcode-41-First-Missing-Positive Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-961-N-Repeated-Element-in-Size-2N-Array.html":{"url":"Leetcode-961-N-Repeated-Element-in-Size-2N-Array.html","title":"N Repeated Element in Size 2N Array","keywords":"","body":"Question In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times. Example 1: Input: [1,2,3,3] Output: 3 Example 2: Input: [2,1,2,5,3,2] Output: 2 Example 3: Input: [5,1,5,2,5,3,5,4] Output: 5 Note: 4 0 A.length is even Difficulty:Easy Category:Hash-Table Solution Solution 1: Ust Set class Solution { public: int repeatedNTimes(vector& A) { unordered_set rec; for (int i = 0; i Solution 2: Use Hash-Table class Solution { public: int repeatedNTimes(vector& A) { int n = A.size(); unordered_map m; for (int& a : A) { if (++m[a] >= n / 2) return a; } return 0; } }; Solution 3: Use array This solution come from https://leetcode.com/yubowenok/ Runtime: 52 ms, faster than 36.81% of C++ online submissions for N-Repeated Element in Size 2N Array. Memory Usage: 11.1 MB, less than 0.94% of C++ online submissions for N-Repeated Element in Size 2N Array. typedef long long ll; typedef vector VI; typedef pair PII; #define REP(i,s,t) for(int i=(s);i& A) { FILL(cnt, 0); int n = A.size() / 2, ans = -1; REP(i,0,2*n) { if (++cnt[A[i]] >= n) return A[i]; } } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-697-Degree-of-an-Array.html":{"url":"Leetcode-697-Degree-of-an-Array.html","title":"Degree of an Array","keywords":"","body":"Question Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: [1, 2, 2, 3, 1] Output: 2 Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2. Example 2: Input: [1,2,2,3,1,4,2] Output: 6 Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999. Difficulty:Easy Category:Array Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-26-Remove-Duplicates-From-Sorted-Array.html":{"url":"Leetcode-26-Remove-Duplicates-From-Sorted-Array.html","title":"Remove Duplicates From Sorted Array","keywords":"","body":"Question Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i Solution class Solution { public: int removeDuplicates(vector& nums) { if (nums.size() 上面的解决方案有这样几个问题： nums.size() 对上面的解答思路进行优化： Solution 2 class Solution { public: int removeDuplicates(vector& nums) { if (nums.empty()) return 0; int index = 0; for (int i = 0; i Solution 3 使用了STL里面的函数来快速的完成： class Solution { public: int removeDuplicates(vector& nums) { return distance(nums.begin(), unique(nums.begin(), nums.end())); } }; The Template for the remove the duplicates. // 删除重复的元素 templaate OutIt removeDuplicates(InIt first, InIt last, OutIt output) { while(first != last) { *output++ = *first; first = upper_bound(first, last, *first); } return output; } Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-80-Remove-Duplicates-From-Sorted-Array-II.html":{"url":"Leetcode-80-Remove-Duplicates-From-Sorted-Array-II.html","title":"Remove Duplicates From Sorted Array II","keywords":"","body":"Question Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3], Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i Solution class Solution { public: int removeDuplicates(vector& nums) { if (nums.size() Solution 2 class Solution { public: int removeDuplicates(vector& nums) { if (nums.size() Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-217-Contains-Duplicate.html":{"url":"Leetcode-217-Contains-Duplicate.html","title":"Contains Duplicate","keywords":"","body":"Question Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true Difficulty:Easy Category:Array, Hash-Table Solution class Solution { public: bool containsDuplicate(vector& nums) { std::unordered_map counts; for (int x : nums) { std::unordered_map::iterator got = counts.find(x); if (got == counts.end()) counts.insert({x, 0}); else return true; } return false; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-128-Longest-Consecutive-Sequence.html":{"url":"Leetcode-128-Longest-Consecutive-Sequence.html","title":"Longest Consecutive Sequence","keywords":"","body":"Question Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Analyze 本题目要求的是O(n)的时间复杂度，因为序列中的元素是无序的，而且要求了O(n)的时间复杂度，所以这道题尝试使用哈希表去完成。 使用哈希表unordered_map used记录每个元素是否已经使用，对每一个元素，使用该元素作为中心，向左右扩张到不能扩张位置，并将这些位置设置为True，然后记录下能够扩张的长度。 时间复杂度: O(n) Solution Solution 1: Unodered_map, expand to two side class Solution { public: int longestConsecutive(vector& nums) { int longest = 0; unordered_map used; for (int i : nums) used[i] = false; for (auto n : nums) { if (used[n]) continue; used[n] = true; int prev = n - 1, next = n + 1; while (used.find(prev) != used.end()) used[prev--] = true; while (used.find(next) != used.end()) used[next++] = true; longest = max(longest, next - prev - 1); } return longest; } }; Solution 1: unordered_set, expand to two side 对上面的解法,也可以使用unordered_set去解答,这种方案来自于Leetcode讨论区 class Solution { public: int longestConsecutive(vector &num) { unordered_set record(num.begin(), num.end()); int res = 0; for (int n : num) { if (record.find(n) == record.end()) continue; record.erase(n); int prev = n - 1, next = n + 1; while (record.find(prev) != record.end()) record.erase(prev--); while (record.find(next) != record.end()) record.erase(next++); res = max(res, next - prev - 1); } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-4-Median-of-Two-Sorted-Arrays.html":{"url":"Leetcode-4-Median-of-Two-Sorted-Arrays.html","title":"Median of Two Sorted Arrays(LC.4)","keywords":"","body":"Question There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Difficulty:Hard Category:Array Analyze The pictures in this post all come from this post: [花花酱 LeetCode 4. Median of Two Sorted Arrays] (https://zxi.mytechroad.com/blog/algorithms/binary-search/leetcode-4-median-of-two-sorted-arrays/) There are to sorted arrays. You need to find the median number in these two arrays. How we can choose the method to solve this problem. The time complexity: O(log(m+n)), So, this time complexity can give us a tips. We need to think about using the Binary Search to solve this problem. How to use the binary search to do this problem? The median number may in these position in these two arrays. And, we need to cover all conditions as the above picture. Solution Java Solution: ```java java public class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length, n = nums2.length; int l = (m + n + 1) >> 1; int r = (m + n + 2) >> 1; return (getkth(nums1, 0, nums2, 0, l) + getkth(nums1, 0, nums2, 0, r)) / 2.0; } public double getkth(int[] A, int aStart, int[] B, int bStart, in t k) { if (aStart == A.length) return B[bStart + k - 1]; if (bStart == B.length) return A[aStart + k - 1]; if (k == 1) return Math.min(A[aStart], B[bStart]); int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE; if (aStart + k / 2 - 1 **C++ Solution 1** ```cpp class Solution { public: double findMedianSortedArrays(vector& nums1, vector& nums2) { int total = nums1.size() + nums2.size(); if (total % 2 == 1) { return findMedianth(nums1, 0, nums2, 0, total / 2 + 1); } else { return (findMedianth(nums1, 0, nums2, 0, total / 2) + findMedianth(nums1, 0, nums2, 0, total / 2 + 1)) / 2; } } double findMedianth(vector& nums1, int i, vector& nums2, int j, int k) { if (nums1.size() - i > nums2.size() - j) return findMedianth(nums2, j, nums1, i, k); if (nums1.size() == i) return nums2[j + k - 1]; if (k == 1) return min(nums1[i], nums2[j]); int point_1 = min(int(nums1.size()), i + k / 2); int point_2 = j + k - point_1 + i; if (nums1[point_1 - 1] nums2[point_2 - 1]) return findMedianth(nums1, i, nums2, point_2, k - (point_2 - j)); else return nums1[point_1 - 1]; } }; Solution 2: Binary Search class Solution { public: double findMedianSortedArrays(vector& nums1, vector& nums2) { const int n1 = nums1.size(), n2 = nums2.size(); if (n1 > n2) return findMedianSortedArrays(nums2, nums1); const int k = (n1 + n2 + 1) / 2; int left = 0, right = n1; while (left = n1 ? INT_MAX : nums1[m1], m2 >= n2 ? INT_MAX : nums2[m2]); return (center1 + center2) * 0.5; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-349-Intersection-of-two-Arrays.html":{"url":"Leetcode-349-Intersection-of-two-Arrays.html","title":"Intersection of two Arrays(LC.349)","keywords":"","body":"Question Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Difficulty:Easy Category:Hash-Table, Sort, Two-Points, Binary-Search Solution class Solution { public: vector intersection(vector& nums1, vector& nums2) { set s(nums1.begin(), nums1.end()), res; for (auto i : nums2) { if (s.count(i)) res.insert(i); } return vector(res.begin(), res.end()); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-350-Intersection-Of-Two-Arrays-II.html":{"url":"Leetcode-350-Intersection-Of-Two-Arrays-II.html","title":"Intersection Of Two Arrays II(LC.350)","keywords":"","body":"Question Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Difficulty:Easy Category:Hash-Table, Two-Points, Binary-Search, Sort Solution Solution 1: HashTable Time Complexity: O(n) Space Complexity: O(n) class Solution { public: vector intersect(vector& nums1, vector& nums2) { vector ans; unordered_map cnts; for (int& num : nums1) ++cnts[num]; for (int& num : nums2) { if (cnts[num]) { ans.emplace_back(num); --cnts[num]; } } return ans; } }; Solution 2: Sorting Time Complexity: O(n log n) Space Complexity: O(n) class Solution { public: vector intersect(vector& nums1, vector& nums2) { vector res; int i = 0, j = 0; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); while (i nums2[j]) { ++j; } else { ++i; } } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-718-Maximum-Length-of-Repeated-Subarray.html":{"url":"Leetcode-718-Maximum-Length-of-Repeated-Subarray.html","title":"Maximum Length of Repeated Subarray(LC.718)","keywords":"","body":"Question Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3, 2, 1]. Note: 1 0 Difficulty:Medium Category: Solution class Solution { public: int findLength(vector& A, vector& B) { int m = A.size(), n = B.size(), ans = INT_MIN; vector> dp(m + 1, vector(n + 1, 0)); for (int i = 1; i 讨论区有通过一维的方式来实现的, 没怎么看明白: Java/C++ Clean Code - 8 lines class Solution { public: int findLength(vector& a, vector& b) { int m = a.size(), n = b.size(); vector dp(n + 1); int res = 0; for (int i = m - 1; i >= 0; i--) { for (int j = 0; j Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-888-Fair-Candy-Swap.html":{"url":"Leetcode-888-Fair-Candy-Swap.html","title":"Fair Candy Swap","keywords":"","body":"Question Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy. (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed an answer exists. Example 1: Input: A = [1,1], B = [2,2] Output: [1,2] Example 2: Input: A = [1,2], B = [2,3] Output: [1,2] Example 3: Input: A = [2], B = [1,3] Output: [2,3] Example 4: Input: A = [1,2,5], B = [2,4] Output: [5,4] Note: 1 1 1 1 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer. Difficulty:Easy Category:Array Solution class Solution { public: vector fairCandySwap(vector& A, vector& B) { int sum_a = 0, sum_b = 0; std::unordered_set set_b; for (int x : A) sum_a += x; for (int x : B) { sum_b += x; set_b.insert(x); } int diff = (sum_b - sum_a) / 2; for (int x : A) { std::unordered_set::const_iterator it = set_b.find(x + diff); if (it != set_b.end()) { return {x, x + diff}; } } return {}; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-632-Smallest-Range.html":{"url":"Leetcode-632-Smallest-Range.html","title":"Smallest Range(LC.632)","keywords":"","body":"Question You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists. We define the range [a,b] is smaller than range [c,d] if b-a or a if b-a == d-c. Example 1: Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24]. Note: The given list may contain duplicates, so ascending order means >= here. 1 k -105 value of elements For Java users, please note that the input type has been changed to List>. And after you reset the code template, you'll see this point. Difficulty:Hard Category:Hash-Table, Two-Points, String Analyze 输入是一些数组, 都是排好序的, 我们需要找到一个最小的数据范围, 使得这个范围至少能够包括每个数组中的一个数字. 我们可以考虑按照以下方式进行处理: 將这些数组合并成为一个大的数组并且保留其序号, 使用vector>, 然后排序. 这样等同于, 我们找到一个最小的窗口, 然后这个窗口里面要同时包含所有数组中的至少一个数字. 我们用两个指针 left 和 right 来确定滑动窗口的范围，我们还要用一个哈希表来建立每个数组与其数组中数字出现的个数之间的映射，变量cnt表示当前窗口中的数字覆盖了几个数组，diff为窗口的大小，我们让right向右滑动，然后判断如果right指向的数字所在数组没有被覆盖到，cnt自增1，然后哈希表中对应的数组出现次数自增1，然后我们循环判断如果cnt此时为k(数组的个数)且left不大于right，那么我们用当前窗口的范围来更新结果，然后此时我们想缩小窗口，通过将left向右移，移动之前需要减小哈希表中的映射值，因为我们去除了数字，如果此时映射值为0了，说明我们有个数组无法覆盖到了，cnt就要自减1。这样遍历后我们就能得到最小的范围了 Solution class Solution { public: vector smallestRange(vector>& nums) { vector ans; vector> v; unordered_map m; int n = nums.size(); // Merge all array in one vector, and save the index in the vector for (int i = 0; i v[right].first - v[left].first) { diff = v[right].first - v[left].first; ans = {v[left].first, v[right].first}; } if (--m[v[left].second] == 0) --cnt; ++left; } } return ans; } }; Leetcode 76. Minimum Window Substring Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-7-Reverse-Integer.html":{"url":"Leetcode-7-Reverse-Integer.html","title":"Reverse Integer","keywords":"","body":"Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows Difficulty:Easy Category:Array Analyze 数据翻转的问题, 只需要将int数据类型除以10的余数作为第一个数, 然后商继续除以10得到第二个数据. 处理过程为: res = res * 10 + (x % 10); x = x / 10; 但是在本题目中, 需要考虑正负数, 然后数据是否超出范围(溢出)的情况. 此外, 需要考虑正负号的影响. 溢出:　Int型的数值范围是 -2147483648～2147483647，那么如果我们要翻转 1000000009 这个在范围内的数得到 9000000001，而翻转后的数就超过了范围． Solution class Solution { public: int reverse(int x) { long long res = 0; while(x != 0) { res = res * 10 + (x % 10); x = x / 10; } if (res > INT_MAX || res Optimaze 最后两条语句可以合并之后书写: return (res > INT_MAX || res 判断是否溢出的时候, (参考Leetcode官方答案)可以简化为: if (abs(res) > INT_MAX / 10) return 0; 为什么可以不用检查INT_MIN, 解释过程可以参考博客 在贴出答案的同时，OJ还提了一个问题 To check for overflow/underflow, we could check if ret > 214748364 or ret 为什么不用check是否等于214748364呢，因为输入的x也是一个整型数，所以x的范围也应该在 -2147483648～2147483647 之间，那么x的第一位只能是1或者2，翻转之后res的最后一位只能是1或2，所以res只能是 2147483641 或 2147483642 都在int的范围内。但是它们对应的x为 1463847412 和 2463847412，后者超出了数值范围。所以当过程中res等于 214748364 时， 输入的x只能为 1463847412， 翻转后的结果为 2147483641，都在正确的范围内，所以不用check。 最后贴出官方给出的解答方法: class Solution { public: int reverse(int x) { int res = 0; while (x != 0) { if (abs(res) > INT_MAX / 10) return 0; res = res * 10 + x % 10; x /= 10; } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-29-Divide-Two-Integers.html":{"url":"Leetcode-29-Divide-Two-Integers.html","title":"Divide Two Integers","keywords":"","body":"Question Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. Difficulty:Medium Category: Solution 这道题目规定我们不能使用乘法，除法以及取余操作。我们可以考虑在这道题目使用 Bit Operation 以下分析来自于博文：Divide Two Integers 两数相除 这道题让我们求两数相除，而且规定我们不能用乘法，除法和取余操作，那么我们还可以用另一神器位操作Bit Operation，思路是，如果被除数大于或等于除数，则进行如下循环，定义变量t等于除数，定义计数p，当t的两倍小于等于被除数时，进行如下循环，t扩大一倍，p扩大一倍，然后更新res和m。这道题的OJ给的一些test case非常的讨厌，因为输入的都是int型，比如被除数是-2147483648，在int范围内，当除数是-1时，结果就超出了int范围，需要返回INT_MAX，所以对于这种情况我们就在开始用if判定，将其和除数为0的情况放一起判定，返回INT_MAX。然后我们还要根据被除数和除数的正负来确定返回值的正负，这里我们采用长整型long来完成所有的计算，最后返回值乘以符号即可 Solution 1: Implement class Solution { public: int divide(int dividend, int divisor) { long long m = abs((long long)dividend), n = abs((long long)divisor), res = 0; if (m = n) { long long t = n, p = 1; while (m > (t INT_MAX ? INT_MAX : res; } }; Solution 2: Recursion class Solution { public: int divide(int dividend, int divisor) { long long res = 0; long long m = abs((long long)dividend), n = abs((long long)divisor); if (m (t INT_MAX ? INT_MAX : res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-989-Add-to-Array-Form-of-Integer.html":{"url":"Leetcode-989-Add-to-Array-Form-of-Integer.html","title":"Add to Array Form of Integer(LC.989)","keywords":"","body":"Question For a non-negative integer X, the array-form of X is an array of its digits in left to right order. For example, if X = 1231, then the array form is [1,2,3,1]. Given the array-form A of a non-negative integer X, return the array-form of the integer X+K. Example 1: Input: A = [1,2,0,0], K = 34 Output: [1,2,3,4] Explanation: 1200 + 34 = 1234 Example 2: Input: A = [2,7,4], K = 181 Output: [4,5,5] Explanation: 274 + 181 = 455 Example 3: Input: A = [2,1,5], K = 806 Output: [1,0,2,1] Explanation: 215 + 806 = 1021 Example 4: Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1 Output: [1,0,0,0,0,0,0,0,0,0,0] Explanation: 9999999999 + 1 = 10000000000 Note： 1 0 0 If A.length > 1, then A[0] != 0 Difficulty:Easy Category: Analyze 这是123次周赛的比赛题目, 使用C++来解决这个问题的时候,显得十分笨重, 在后面的题目中,会同时考虑使用 Python 来刷Leetcode的题目. Solution class Solution { public: vector addToArrayForm(vector& A, int k) { // vector ans; int n = A.size(), carry = 0; for (int i = n - 1; i >= 0; --i) { if (k > 0 || carry > 0) { A[i] = A[i] + k % 10 + carry; carry = A[i] / 10; A[i] = A[i] % 10; k = k / 10; } } while (k > 0 || carry > 0) { int temp = k % 10 + carry; A.insert(A.begin(), temp % 10); carry = temp / 10; k = k / 10; } return A; } }; Solution 2: Python class Solution(object): def addToArrayForm(self, A, K): v = ''.join([str(x) for x in A]) v = int(v) v += K return [int(d) for d in str(v)] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-179-Largest-Number.html":{"url":"Leetcode-179-Largest-Number.html","title":"Largest Number","keywords":"","body":"Question Given a list of non negative integers, arrange them such that they form the largest number. Example 1: Input: [10,2] Output: \"210\" Example 2: Input: [3,30,34,5,9] Output: \"9534330\" Difficulty:Medium Category: Solution class Solution { public: string largestNumber(vector& nums) { string res = \"\"; sort(nums.begin(), nums.end(), [](int x, int y) { return to_string(x) + to_string(y) > to_string(y) + to_string(x); }); for (auto num : nums) res += to_string(num); // Deal with the situation with res == \"00000\" return res[0] == '0' ? \"0\" : res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-118-Pascal-Triangle.html":{"url":"Leetcode-118-Pascal-Triangle.html","title":"Pascal Triangle","keywords":"","body":"Question Given a non-negative integer numRows, generate the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it. Solution class Solution { public: vector> generate(int numRows) { vector> res; res.reserve(numRows); if (numRows row; row.reserve(n); for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-119-Pascal-Triangle-II.html":{"url":"Leetcode-119-Pascal-Triangle-II.html","title":"Pascal Triangle II","keywords":"","body":"Question Given a non-negative index k where k ≤ 33, return the _k_th index row of the Pascal's triangle. Note that the row index starts from 0. In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O(k) extra space? Solution // a[i][j] = a[i][0] * (i/1) * ((i-1)/2)) * ((i-2)/3) * ... * (1/i)。 class Solution { public: vector getRow(int rowIndex) { vector res; res.reserve(33); if (rowIndex Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-509-Fibonacci-Number.html":{"url":"Leetcode-509-Fibonacci-Number.html","title":"Fibonacci Number(LC.509)","keywords":"","body":"Question The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N > 1. Given N, calculate F(N). Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input: 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Note: 0 ≤ N ≤ 30. Difficulty:Medium Category: Recursion, DP Solution SOlution 1: 递归方案: //时间复杂度: O(2^n) class Solution { public: int fib(int N) { return N Solution 2: class Solution { public: int fib(int N) { vector m_(N + 1, 0); if (N Solution 3: DP class Solution { public: int fib(int N) { if (N Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-189-Rotate-Array.html":{"url":"Leetcode-189-Rotate-Array.html","title":"Rotate Array","keywords":"","body":"Question Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Solutions class Solution { public: void rotate(vector& nums, int k) { vector temp = nums; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-27-Remove-Element.html":{"url":"Leetcode-27-Remove-Element.html","title":"Remove Element","keywords":"","body":"Question Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i Difficulty:Easy Category:Array, Two Points Analyze 这道题目只需要去除与目标数值相同的元素既可， 可以有以下几种方式去实现： 方案一： 直接跳过重复的元素， 时间复杂度O(n), 空间复杂度O(1) 方案二： 使用Remove函数，时间复杂度O(n), 空间复杂度O(1) Solution Solution 1(方案一)： 直接跳过目标位置 class Solution { public: int removeElement(vector& nums, int val) { int res = 0; for (int i = 0; i Solution 1(方案一)： 使用std::remove函数以及distance函数 class Solution { public: int removeElement(vector& nums, int val) { return distance(nums.begin(), remove(nums.begin(), nums.end(), val)); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-31-Next-Permutation.html":{"url":"Leetcode-31-Next-Permutation.html","title":"Next Permutation","keywords":"","body":"Question Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 Difficulty:Medium Category:Array Analyze 这一道题目，需要找到排列中的下一个顺序（从小到大），如果当前已经是最大的一个排列方式的话，那么下一个就跳转到最小的排列方式。两种情况： 如果这不是最大的一个排列，那么找到需要交换元素的两个值，交换元素之后，再进行反转，算法如下图所示： 如果这已经是最大的排列的话，那么直接反所有的元素就可以了。 下一个排列算法流程 图片来自有：《Leetcode 题解》 第19页 Solution Solution 1 class Solution { public: void nextPermutation(vector& nums) { unsigned len = nums.size() - 1; // Find an element from the right to left. for (int i = len - 1; i >= 0; --i) { if (nums[i + 1] > nums[i]) { for (int j = len; j > i; --j) { if (nums[j] > nums[i]) { swap(nums[j], nums[i]); reverse(nums.begin() + i + 1, nums.end()); return; } } } } // If there are increate order from left to right. reverse(nums.begin(), nums.end()); return; } }; Solution 2 稍微更加简洁的代码，来自有 [LeetCode] Next Permutation 下一个排列 class Solution { public: void nextPermutation(vector& nums) { int n = nums.size(), i = n - 2, j = n - 1; while (i >= 0 && nums[i] >= nums[i + 1]) --i; if (i >= 0) { while (nums[j] Solution 3 使用函数模板的方式解决, 具有普遍通用性，来自有：《Leetcode 题解》 第20页 class Solution { public: void nextPermutation(vector &nums) { next_permutation(nums.begin(), nums.end()); } template bool next_permutation(BidiIt first, BidiIt last) { // Get a reversed range to simplify reversed traversal. const auto rfirst = reverse_iterator(last); const auto rlast = reverse_iterator(first); // Begin from the second last element to the first element. auto pivot = next(rfirst); // Find `pivot`, which is the first element that is no less than its // successor. `Prev` is used since `pivort` is a `reversed_iterator`. while (pivot != rlast && *pivot >= *prev(pivot)) ++pivot; // No such elemenet found, current sequence is already the largest // permutation, then rearrange to the first permutation and return false. if (pivot == rlast) { reverse(rfirst, rlast); return false; } // Scan from right to left, find the first element that is greater than // `pivot`. auto change = find_if(rfirst, pivot, bind1st(less(), *pivot)); swap(*change, *pivot); reverse(rfirst, pivot); return true; } }; std::bind1st function The function object returned by bind1st has its operator() defined such that it takes only one argument. This argument is used to call binary function object op with x as the fixed value for the first argument. template binder1st bind1st(const Operation& op, const T& x) { return binder1st(op, typename Operation::first_argument_type(x)); } Example: // bind1st example #include #include #include using namespace std; int main() { int numbers[] = {10, 20, 30, 40, 50, 10}; int cx; cx = count_if(numbers, numbers + 6, bind1st(equal_to(), 10)); cout Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-46-Permutations.html":{"url":"Leetcode-46-Permutations.html","title":"Permutations","keywords":"","body":"Question Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] Difficulty:Medium Category:Backtracking Analyze 这到题是找到数字的所有排列，按照顺序排序，我们在Leetcode 31. Next Permutation 这个题目是已经完成了求解给定排列的下一个排列的情况，所以这道题目，我们直接使用那道题目的函数来循环n!次求解就好。 Solution class Solution { public: vector> permute(vector& nums) { vector> res; unsigned len = nums.size(), res_size = 1; for (int i = 1; i & nums, vector>& res) { unsigned len = nums.size() - 1; // Find an element from the right to left. for (int i = len - 1; i >= 0; --i) { if (nums[i + 1] > nums[i]) { for (int j = len; j > i; --j) { if (nums[j] > nums[i]) { swap(nums[j], nums[i]); reverse(nums.begin() + i + 1, nums.end()); res.push_back(nums); return; } } } } // If there are increate order from left to right. reverse(nums.begin(), nums.end()); res.push_back(nums); return; } }; Solution 1: DFS // Runtime: 16 ms, faster than 100.00% of C++ online submissions for Permutations. // Memory Usage: 9.4 MB, less than 100.00% of C++ online submissions for Permutations. class Solution { public: vector> permute(vector& nums) { vector> ans; vector out; permuteDFS(nums, out, ans); return ans; } private: void permuteDFS(vector& nums, vector& out, vector>& ans) { if (out.size() == nums.size()) { ans.emplace_back(out); return; } for (int& num : nums) { if (find(out.begin(), out.end(), num) != out.end()) continue; out.emplace_back(num); permuteDFS(nums, out, ans); out.pop_back(); } } }; 下面这种解法, 不使用中间变量的方式来完成:(前提是给的数据是没有重复的元素的) // Runtime: 16 ms, faster than 100.00% of C++ online submissions for Permutations. // Memory Usage: 9.3 MB, less than 100.00% of C++ online submissions for Permutations. class Solution { public: vector > permute(vector &num) { vector > ans; permuteRecursive(num, 0, ans); return ans; } // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector &num, int begin, vector > &ans) { if (begin >= num.size()) { // one permutation instance ans.emplace_back(num); return; } for (int i = begin; i Updated 03/01/2019 Review(DFS, 10mins) Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-47-Permutations-II.html":{"url":"Leetcode-47-Permutations-II.html","title":"Permutations II","keywords":"","body":"Question Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] Difficulty:Medium Category:Backtracking Analyze 这到题是找到数字的所有不重复排列，按照顺序排序，我们在Leetcode 31. Next Permutation 这个题目是已经完成了求解给定排列的下一个排列的情况，所以这道题目，我们直接使用那道题目的函数来循环求解就好,当出现要循环到最开始的时候，就停止。 Solution class Solution { public: vector> permuteUnique(vector& nums) { vector> res; sort(nums.begin(), nums.end()); bool done = false; unsigned res_size = 1; for (int i = 1; i & nums, vector>& res, bool& done) { unsigned len = nums.size() - 1; // Find an element from the right to left. for (int i = len - 1; i >= 0; --i) { if (nums[i + 1] > nums[i]) { for (int j = len; j > i; --j) { if (nums[j] > nums[i]) { swap(nums[j], nums[i]); reverse(nums.begin() + i + 1, nums.end()); res.push_back(nums); return; } } } } done = true; return; } }; Solution 1: DFS // Runtime: 32 ms, faster than 72.85% of C++ online submissions for Permutations II. // Memory Usage: 10 MB, less than 100.00% of C++ online submissions for Permutations II. class Solution { public: vector> permuteUnique(vector& nums) { vector> ans; sort(nums.begin(), nums.end()); vector out; vector used(nums.size(), 0); permuteUniqueDFS(nums, used, out, ans); return ans; } private: void permuteUniqueDFS(vector& nums, vector& used, vector& out, vector>& ans) { if (out.size() == nums.size()) { ans.emplace_back(out); return; } for (int i = 0; i 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue; used[i] = 1; out.emplace_back(nums[i]); permuteUniqueDFS(nums, used, out, ans); out.pop_back(); used[i] = 0; } } }; Solution 2: 迭代 // Runtime: 28 ms, faster than 100.00% of C++ online submissions for Permutations II. // Memory Usage: 9.8 MB, less than 100.00% of C++ online submissions for Permutations II. class Solution { public: vector> permuteUnique(vector& nums) { sort(nums.begin(), nums.end()); vector> res; do { res.emplace_back(nums); } while (nextPermutation(nums, 0, nums.size() - 1)); return res; } private: bool nextPermutation(vector& v, int left, int right) { if (left >= right) return false; int i, j; i = right - 1; while (i >= left && v[i] >= v[i + 1]) --i; if (i = v[j]) --j; std::swap(v[i], v[j]); std::reverse(v.begin() + i + 1, v.begin() + right + 1); return true; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-784-Letter-Case-Permutation.html":{"url":"Leetcode-784-Letter-Case-Permutation.html","title":"Letter Case Permutation","keywords":"","body":"Question Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. Examples: Input: S = \"a1b2\" Output: [\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"] Input: S = \"3z4\" Output: [\"3z4\", \"3Z4\"] Input: S = \"12345\" Output: [\"12345\"] Note: S will be a string with length between 1 and 12. S will consist only of letters or digits. Difficulty:Easy Category:Backtracking, Bit-Manipulation Solution 　Solution 1: DFS // Runtime: 16 ms, faster than 100.00% of C++ online submissions for Letter Case Permutation. // Memory Usage: 12.9 MB, less than 100.00% of C++ online submissions for Letter Case Permutation. class Solution { public: vector letterCasePermutation(string S) { vector ans; letterCasePermutationDFS(S, 0, ans); return ans; } void letterCasePermutationDFS(string& S, int index, vector& ans) { if (index == S.length()) { ans.emplace_back(S); return; } letterCasePermutationDFS(S, index + 1, ans); if (!isalpha(S[index])) return; isupper(S[index]) ? S[index] = std::tolower(S[index]) : S[index] = std::toupper(S[index]); letterCasePermutationDFS(S, index + 1, ans); } }; 后面这一种解法对字母大小写转换的地方做了一些改变： 来源于博客：花花酱 LeetCode 784. Letter Case Permutation ASCII: Uppercase A-Z: 65 - 90 Lowercase a-z: 97 - 122 a - A = 32, a ^ (1 A; class Solution { public: vector letterCasePermutation(string S) { vector ans; dfs(S, 0, ans); return ans; } private: void dfs(string& S, int s, vector& ans) { if (s == S.length()) { ans.push_back(S); return; } dfs(S, s + 1, ans); if (!isalpha(S[s])) return; S[s] ^= (1 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-943-Find-the-Shortest-Superstring.html":{"url":"Leetcode-943-Find-the-Shortest-Superstring.html","title":"Find the Shortest Superstring","keywords":"","body":"Question Given an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is substring of another string in A. Example 1: Input: [\"alex\",\"loves\",\"leetcode\"] Output: \"alexlovesleetcode\" Explanation: All permutations of \"alex\",\"loves\",\"leetcode\" would also be accepted. Example 2: Input: [\"catg\",\"ctaagt\",\"gcta\",\"ttca\",\"atgcatc\"] Output: \"gctaagttcatgcatc\" Note: 1 1 Difficulty:Hard Category: Analyze 在这道题目的输入规模情况，可以得到， 这个规模可以 $O(n^2)$ 可以將这道题目转化为图的问题来进行求解， Solution class Solution { public: string shortestSuperstring(vector& A) { const int n = A.size(); // 预处理阶段： 计算將单词 j 接到单词 i 后面的最小 Cost 是多少 g_ = vector>(n, vector(n)); for (int i = 0; i path(n， -1); // 当前的路径---各个单词的 index best_len_ = INT_MAX; dfs(A, 0, 0, 0, path); string ans = A[best_path_[0]]; for (int k = 1; k > g_; //预处理 vector best_path_; int best_len_; // d: 当前搜素的深度， uesd: 表示那些单词已经被使用了， cur_len 当前路径所有单词的长度和 void dfs(const vector& A, int d, int used, int cur_len, vector& path) { // 剪枝处理 if (cur_len >= best_len_) return; if (d == A.size()) { // 表示所有的单词已经全部使用过了， 当前最优解 best_len_ = cur_len; best_path_ = path; return; } for (int i = 0; i Solution 1: Search(DFS) + Pruning Time complexity: O(n!) Space complexity: O(n) // Runtime: 1076 ms, faster than 7.41% of C++ online submissions for Find the Shortest Superstring. // Memory Usage: 9.7 MB, less than 100.00% of C++ online submissions for Find the Shortest Superstring. class Solution { public: string shortestSuperstring(vector& A) { const int n = A.size(); v_ = vector>(n, vector(n, 0)); for (int i = 0; i = 0; --cnt) if (A[i].substr(p_len - cnt) == A[j].substr(0, cnt)) { v_[i][j] = s_len - cnt; break; } } } vector path(n, -1); best_len = INT_MAX; shortestSuperstringDFS(A, 0, 0, 0, path); string ans = A[best_path[0]]; for (int i = 1; i > v_; vector best_path; int best_len; void shortestSuperstringDFS(vector& A, int index, int used, int cur_len, vector& path) { if (cur_len >= best_len) return; if (index == A.size()) { best_len = cur_len; best_path = path; return; } for (int i = 0; i Solution 2: DP class Solution { public: string shortestSuperstring(vector& A) { const int n = A.size(); // g[i][j] is the cost of appending word[j] after word[i], or weight of edge[i][j]. // 计算 Cost vector> g(n, vector(n)); for (int i = 0; i > dp(1 (n, INT_MAX / 2)); // 使用Parent 来记录 dp 的状态是由那一个状态转移过来的 vector> parent(1 (n, -1)); // 设置初始数值， 只访问第 i 个结点， 对应的初始数值。 for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-996-Number-of-Squareful-Arrays.html":{"url":"Leetcode-996-Number-of-Squareful-Arrays.html","title":"Number of Squareful Arrays","keywords":"","body":"Question Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square. Return the number of permutations of A that are squareful. Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i]. Example 1: Input: [1,17,8] Output: 2 Explanation: [1,8,17] and [17,8,1] are the valid permutations. Example 2: Input: [2,2,2] Output: 1 Note: 1 0 Difficulty:Hard Category: Solution 1: DFS Time complexity: O(n!) Space complexity: O(n) // Runtime: 4 ms, faster than 100.00% of C++ online submissions for Number of Squareful Arrays. // Memory Usage: 9 MB, less than 100.00% of C++ online submissions for Number of Squareful Arrays. class Solution { public: int numSquarefulPerms(vector& A) { std::sort(begin(A), end(A)); vector out; vector used(A.size(), 0); int ans = 0; permuteUniqueDFS(A, used, out, ans); return ans; } private: void permuteUniqueDFS(vector& nums, vector& used, vector& out, int& ans) { if (out.size() == nums.size()) { ++ans; return; } for (int i = 0; i 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue; if (!out.empty() && !squareful(out.back(), nums[i])) continue; used[i] = 1; out.emplace_back(nums[i]); permuteUniqueDFS(nums, used, out, ans); out.pop_back(); used[i] = 0; } } bool squareful(int x, int y) { int s = sqrt(x + y); return s * s == x + y; } }; Solution 2: DFS This solution come from the discuss Explanation: Count numbers ocuurrence. For each number i, find all possible next number j that i + j is square. Backtracking using dfs. Time ComplexityIt's O(N^N) if we have N different numbers and any pair sum is square.We can easily make case for N = 3 like [51,70,30]. Seems that no hard cases for this problem and int this way it reduces to O(N^2). // Runtime: 4 ms, faster than 100.00% of C++ online submissions for Number of Squareful Arrays. // Memory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Number of Squareful class Solution { public: int numSquarefulPerms(vector& A) { res = 0; for (int& a : A) count[a]++; // For each number i, find all possible next number j that i + j is square. for (auto& i : count) { for (auto& j : count) { int x = i.first, y = j.first, s = sqrt(x + y); if (s * s == x + y) cand[x].insert(y); } } for (auto e : count) dfs(e.first, A.size() - 1); return res; } private: unordered_map count; unordered_map> cand; int res; void dfs(int x, int len) { count[x]--; if (len == 0) res++; for (int y : cand[x]) if (count[y] > 0) dfs(y, len - 1); count[x]++; } }; Solution 3: depth This solution come from: 花花酱 LeetCode 996. Number of Squareful Arrays class Solution { public: int numSquarefulPerms(vector& A) { const int n = A.size(); // For deduplication. std::sort(begin(A), end(A)); // g[i][j] == 1 if A[i], A[j] are squareful. vector> g(n, vector(n, 0)); // dp[s][i] := number of ways to reach state s and ends with node i. vector> dp(1 (n)); for (int i = 0; i 0 && !(s & (1 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-494-Target-Sum.html":{"url":"Leetcode-494-Target-Sum.html","title":"Target Sum","keywords":"","body":"Question You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: **Input:** nums is [1, 1, 1, 1, 1], S is 3. **Output:** 5 **Explanation:** -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 There are 5 ways to assign symbols to make the sum of nums be target 3. Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. Difficulty:Medium Category:Dynamic-Programming, Depth-First-Search Solution Solution 1: DFS class Solution { public: int findTargetSumWays(vector& nums, int S) { int sum = 0, ans = 0; for (int& i : nums) sum += i; if (sum & nums, int index, int s, int& ans) { if (index == nums.size()) { if (s == 0) ++ans; return; } dfs(nums, index + 1, s - nums[index], ans); dfs(nums, index + 1, s + nums[index], ans); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-374-Guess-Number-Higher-Or-Lower.html":{"url":"Leetcode-374-Guess-Number-Higher-Or-Lower.html","title":"Guess Number Higher Or Lower","keywords":"","body":"Question We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Example : Input: n = 10, pick = 6 Output: 6 Difficulty:Easy Category:Binary-Search Solution // Forward declaration of guess API. // @param num, your guess // @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 int guess(int num); class Solution { public: int guessNumber(int n) { long int left = 1, right = n; while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-941-Valid-Mountain-Array.html":{"url":"Leetcode-941-Valid-Mountain-Array.html","title":"Valid Mountain Array","keywords":"","body":"Question Given an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if: A.length >= 3 There exists some i with 0 such that: A[0] A[i] > A[i+1] > ... > A[B.length - 1] Example 1: Input: [2,1] Output: false Example 2: Input: [3,5,5] Output: false Example 3: Input: [0,3,2,1] Output: true Note: 0 0 Difficulty:Easy Category:Math Solution // Runtimes: 36ms class Solution { public: bool validMountainArray(vector& A) { if (A.size() A[i - 1]) { if (has_down) return false; has_up = true; } else if (A[i] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-896-Monotonic-Array.html":{"url":"Leetcode-896-Monotonic-Array.html","title":"Monotonic Array","keywords":"","body":"Question An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i , A[i] . An array A is monotone decreasing if for all i , A[i] >= A[j]. Return true if and only if the given array A is monotonic. Example 1: Input: [1,2,2,3] Output: true Example 2: Input: [6,5,4,4] Output: true Example 3: Input: [1,3,2] Output: false Example 4: Input: [1,2,4,5] Output: true Example 5: Input: [1,1,1] Output: true Note: 1 -100000 Difficulty:Easy Category:Array Solution Solution 1 class Solution { public: bool isMonotonic(vector& A) { bool increate_flag = false, decreate_flag = false; int temp = 0; for (int i = 0; i A[i + 1] ? decreate_flag = true : increate_flag = true; temp = i; break; } if (increate_flag) { for (int j = temp; j = A[j + 1]) continue; return false; } } return true; } }; Solution 2 class Solution { public: bool isMonotonic(vector& A) { return increasing(A) || decreasing(A); } bool increasing(vector& A) { for (int i = 0; i A[i + 1]) return false; } return true; } bool decreasing(vector& A) { for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-977-Squares-of-a-Sorted-Array.html":{"url":"Leetcode-977-Squares-of-a-Sorted-Array.html","title":"Squares of a Sorted Array","keywords":"","body":"Question Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order. Example 1: Input: [-4,-1,0,3,10] Output: [0,1,9,16,100] Example 2: Input: [-7,-3,2,3,11] Output: [4,9,9,49,121] Note: 1 -10000 A is sorted in non-decreasing order. Difficulty:Medium Category: Solution class Solution { public: vector sortedSquares(vector& A) { for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-561-Array-Partition-I.html":{"url":"Leetcode-561-Array-Partition-I.html","title":"Array Partition I(LC.561)","keywords":"","body":"Question Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: Input: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. Difficulty:Easy Category:Array Solution class Solution { public: int arrayPairSum(vector& nums) { int res = 0, len = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-915-Partition-Array-into-Disjoint-Intervals.html":{"url":"Leetcode-915-Partition-Array-into-Disjoint-Intervals.html","title":"Partition Array into Disjoint Intervals(LC.915)","keywords":"","body":"Question Given an array A, partition it into two (contiguous) subarrays left and right so that: Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size. Return the length of left after such a partitioning(分割). It is guaranteed that such a partitioning exists. Example 1: Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6] Example 2: Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12] Note: 2 0 It is guaranteed there is at least one way to partition A as described. Difficulty:Medium Category:Array Solution Solution: Search class Solution { public: int partitionDisjoint(vector& A) { // 1) Begin with the second multiset record(A.begin() + 1, A.end()); // 2) Use the first element to init the left_max int left_max = A[0]; for (int i = 1; i left_max, // it means all the other elements is biger than the left elements. if (*record.begin() >= left_max) return i; record.erase(record.equal_range(A[i]).first); left_max = max(left_max, A[i]); } return -1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-277-Find-the-Celebrity.html":{"url":"Leetcode-277-Find-the-Celebrity.html","title":"Find the Celebrity(LC.277)","keywords":"","body":"Question 题目大意：在一群人中寻找名人，所谓名人就是每个人都认识他，他却不认识任何人，限定了只有1个或0个名人，给定了一个API函数，输入a和b，用来判断a是否认识b，让我们尽可能少的调用这个函数，来找出人群中的名人。 Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1people know him/her but he/she does not know any of them. Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \"Hi, A. Do you know B?\" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense). You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows. Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1. Difficulty:Medium Category: Analyze 建立个一维数组用来标记每个人的名人候选状态，开始均初始化为true，表示每个人都是名人候选人，然后我们一个人一个人的验证其是否为名人，对于候选者i，我们遍历所有其他人 j，如果 i 认识 j，或者 j 不认识 i，说明i不可能是名人，那么我们标记其为false，然后验证下一个候选者，反之如果 i 不认识 j，或者 j 认识 i，说明 j 不可能是名人，标记之。对于每个候选者i，如果遍历了一圈而其候选者状态仍为true，说明i就是名人，返回即可，如果遍历完所有人没有找到名人，返回-1 Solution class Solution { public: int findCelebrity(int n) { vector candidate(n, true); for (int i = 0; i 设定候选人res为0，原理是先遍历一遍，对于遍历到的人i，若候选人res认识i，则将候选人res设为i，完成一遍遍历后，我们来检测候选人res是否真正是名人，我们如果判断不是名人，则返回-1，如果并没有冲突，返回res class Solution { public: int findCelebrity(int n) { int res = 0; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-416-Partition-Equal-Subset-Sum.html":{"url":"Leetcode-416-Partition-Equal-Subset-Sum.html","title":"Partition Equal Subset Sum(LC.416)","keywords":"","body":"Leetcode 416. Partition Equal Subset Sum 题目大意： 给了我们一个数组，问我们这个数组能不能分成两个非空子集合，使得两个子集合的元素之和相同 Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. Difficulty:Medium Category: Analyze Cite: Partition Equal Subset Sum 相同子集和分割 首先，原数组所有数字和一定是偶数，不然根本无法拆成两个和相同的子集合，那么我们只需要算出原数组的数字之和，然后除以2，就是我们的target。 那么问题就转换为能不能找到一个非空子集合，使得其数字之和为target。开始我想的是遍历所有子集合，算和，但是这种方法无法通过OJ的大数据集合。于是乎，动态规划 Dynamic Programming 就是我们的不二之选。我们定义一个一维的dp数组，其中dp[i]表示原数组是否可以取出若干个数字，其和为i。那么我们最后只需要返回dp[target]就行了。初始化dp[0]为true，由于题目中限制了所有数字为正数，那么就不用担心会出现和为0或者负数的情况。关键问题就是要找出状态转移方程了，我们需要遍历原数组中的数字，对于遍历到的每个数字nums[i]，需要更新dp数组，我们的最终目标是想知道dp[target]的boolean值，就要想办法用数组中的数字去凑出target，因为都是正数，所以只会越加越大，那么加上nums[i]就有可能会组成区间 [nums[i], target] 中的某个值，那么对于这个区间中的任意一个数字j，如果 dp[j - nums[i]] 为true的话，说明现在已经可以组成 j-nums[i] 这个数字了，再加上nums[i]，就可以组成数字j了，那么dp[j]就一定为true。如果之前dp[j]已经为true了，当然还要保持true，所以还要‘或’上自身，于是状态转移方程如下 Solution class Solution { public: bool canPartition(vector& nums) { int sum = accumulate(nums.begin(), nums.end(), 0), target = sum >> 1; if (sum & 1) return false; vector dp(target + 1, false); dp[0] = true; for (int num : nums) { for (int i = target; i >= num; --i) { dp[i] = dp[i] || dp[i - num]; } } return dp[target]; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"summary/2019-02-03-Leetcode-Matrix-Summary.html":{"url":"summary/2019-02-03-Leetcode-Matrix-Summary.html","title":"Matrix","keywords":"","body":"矩阵（一般是二维数组Vector）操作的题目，一般来说不带有太多算法思想，纯粹就是二维数组下标的操作. Don't use the matrixp[x]p[y] in the code, it is easy to make the mistake. The first coordinate is usually thought of as the row number, which is in fact the y value. We should wirht matrix[r][c] to make life more easy. r = row, and c = column. Relative Problems Spiral Matrix Spiral Matrix II Rotate Image Set Matrix Zeroes Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"Leetcode-54-Spiral-Matrix.html":{"url":"Leetcode-54-Spiral-Matrix.html","title":"Spiral Matrix","keywords":"","body":"Question Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] -------# Solution class Solution { public: vector spiralOrder(vector>& matrix) { vector res; if (matrix.empty() || matrix[0].size() == 0) return res; int m = matrix.size(), n = matrix[0].size(); int p = m, q = n; int c = m > n ? (n + 1) / 2 : (m + 1) / 2; for (int i = 0; i = i; --row_bottom) // Bottom res.emplace_back(matrix[i + p - 1][row_bottom]); for (int row_left = m - i - 2; row_left > i; --row_left) // Lift res.emplace_back(matrix[row_left][i]); } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-59-Spiral-Matrix-II.html":{"url":"Leetcode-59-Spiral-Matrix-II.html","title":"Spiral Matrix II","keywords":"","body":"Question Given a positive integer n, generate a square matrix filled with elements from 1 to _n_2 in spiral order. Example: Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] Solution class Solution { public: vector> generateMatrix(int n) { vector> res(n, vector(n, 0)); int val = 1, c = (n + 1) / 2, p = n; for (int i = 0; i = i; --row_bottom) //Bottom res[i + p - 1][row_bottom] = val++; for (int row_left = n - i - 2; row_left > i; --row_left) { //Left res[row_left][i] = val++; } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-885-Spiral-Matrix-III.html":{"url":"Leetcode-885-Spiral-Matrix-III.html","title":"Spiral Matrix III","keywords":"","body":"Question On a 2 dimensional grid with R rows and C columns, we start at (r0, c0)facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid. Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited. Example 1: Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]] Example 2: Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]] Note: 1 1 0 0 Difficulty:Medium Category:Math Analyze 走的步数的规律: 右移一步，向右转 下移一步，向右转 左移两步，向右转 上移两步，向右转 右移三步，向右转 下移三步，向右转 左移四步，向右转 上移四步，向右转 记录转方向的次数为i, 所以可以得到每一次走的步数是 i/2 + 1 Solution class Solution { public: vector> spiralMatrixIII(int R, int C, int r0, int c0) { vector> ans = {{r0, c0}}; int x = 0, y = 1; for (int i = 0; ans.size() = 0 && r0 = 0 && c0 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-48-Rotate-Image.html":{"url":"Leetcode-48-Rotate-Image.html","title":"Rotate Image","keywords":"","body":"Question You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Difficulty:Medium Category:Array Solution class Solution { public: void rotate(vector>& matrix) { const unsigned int n = matrix.size(); // 1. 沿着对角线翻转一次 for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-832-Flipping-an-Image.html":{"url":"Leetcode-832-Flipping-an-Image.html","title":"Flipping an Image","keywords":"","body":"Question Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes: 1 0 Difficulty:Medium Category:Array Solution class Solution { public: vector> flipAndInvertImage(vector>& A) { if (A.empty()) return A; int m = A.size(), n = A[0].size(); for (auto& temp : A) { for (int j = 0; j Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-867-Transpose-Matrix.html":{"url":"Leetcode-867-Transpose-Matrix.html","title":"Transpose Matrix","keywords":"","body":"Question Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix. Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]] Example 2: Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]] Note: 1 1 Difficulty:Easy Category:Array Analyze How can we solve this problem in-place. In-Place Inverse Perfect Shuffle Solution class Solution { public: vector> transpose(vector>& A) { int m = A.size(), n = A[0].size(); vector> res(n, vector(m, 0)); transpose(A, res, m, n); return res; } void transpose(vector>& a, vector>& b, int rows, int cols) { for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-73-Set-Matrix-Zeroes.html":{"url":"Leetcode-73-Set-Matrix-Zeroes.html","title":"Set Matrix Zeroes(LC.73)","keywords":"","body":"Question Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Follow up: A straight forward solution using O(m__n) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? Difficulty:Medium Category:Array Solution class Solution { public: void setZeroes(vector>& matrix) { const unsigned int len_r = matrix.size(); const unsigned int len_c = matrix[0].size(); bool done_r[len_r] = {false}; bool done_c[len_c] = {false}; // Check each row for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-766-Toeplitz-Matrix.html":{"url":"Leetcode-766-Toeplitz-Matrix.html","title":"Toeplitz Matrix(LC.766)","keywords":"","body":"Question A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. Note: matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99]. Follow up: What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once? Difficulty:Easy Category:Array Solution class Solution { public: bool isToeplitzMatrix(vector>& matrix) { int m = matrix.size(), n = matrix[0].size(); if (m = 0; --i) { int val = matrix[i][0]; int p = 1; for (int j = i + 1; j Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-566-Reshape-the-Matrix.html":{"url":"Leetcode-566-Reshape-the-Matrix.html","title":"Reshape the Matrix(LC.566)","keywords":"","body":"Question In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data. You're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the rownumber and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1: Input: nums = [[1,2], [3,4]] r = 1, c = 4 Output: [[1,2,3,4]] Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. Example 2: Input: nums = [[1,2], [3,4]] r = 2, c = 4 Output: [[1,2], [3,4]] Explanation:There is no way to reshape a 2 2 matrix to a 2 4 matrix. So output the original matrix. Note: The height and width of the given matrix is in range [1, 100]. The given r and c are all positive. Difficulty:Easy Category:Array Solution class Solution { public: vector> matrixReshape(vector>& nums, int r, int c) { if (r * c != nums.size() * nums[0].size()) return nums; vector> res(r, vector(c, 0)); int p = 0, q = 0; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-36-Valid-Sudoku.html":{"url":"Leetcode-36-Valid-Sudoku.html","title":"Valid Sudoku(LC.36)","keywords":"","body":"Question Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. Example 1: Input: [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: true Example 2: Input: [ [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.'. The given board size is always 9x9. Difficulty:Medium Category:HashTable Solution class Solution { public: bool isValidSudoku(vector>& board) { bool used[9] = {false}; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-37-Sudoku-Solver.html":{"url":"Leetcode-37-Sudoku-Solver.html","title":"Sudoku Solver(LC.37)","keywords":"","body":"Question Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character '.'. A sudoku puzzle... ...and its solution numbers marked in red. Note: The given board contain only digits 1-9 and the character '.'. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. Difficulty:Hard Category:Hash-Table, Backtracking Solution class Solution { public: void solveSudoku(vector>& board) { rows_ = vector>(9, vector(10)); cols_ = vector>(9, vector(10)); boxes_ = vector>(9, vector(10)); for (int r = 0; r > rows_, cols_, boxes_; bool fill(vector>& board, int r, int c) { if (r == 9) return true; // Get the next element index int nc = (c + 1) % 9; int nr = nc == 0 ? r + 1 : r; if (board[r][c] != '.') return fill(board, nr, nc); for (int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-963-Minimum-Area-Rectangle-II.html":{"url":"Leetcode-963-Minimum-Area-Rectangle-II.html","title":"Minimum Area Rectangle II(LC.963)","keywords":"","body":"Question Given a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes. If there isn't any rectangle, return 0. Example 1: Input: [[1,2],[2,1],[1,0],[0,1]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2. Example 2: Input: [[0,1],[2,1],[1,1],[1,0],[2,0]] Output: 1.00000 Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1. Example 3: Input: [[0,3],[1,2],[3,1],[1,3],[2,1]] Output: 0 Explanation: There is no possible rectangle to form from these points. Example 4: Input: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2. Note: 1 0 0 All points are distinct. Answers within 10^-5 of the actual value will be accepted as correct. Difficulty:Medium Category:Math, Geometry Solution class Solution { public: double minAreaFreeRect(vector>& points) { int n = points.size(); bool find = false; double ans = INT_MAX; vector>& P = points; for (int a = 0; a 0 && area Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-240-Search-a-2D-Matrix-II.html":{"url":"Leetcode-240-Search-a-2D-Matrix-II.html","title":"Search a 2D Matrix II(LC.240)","keywords":"","body":"Question Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true. Given target = 20, return false. Difficulty:Medium Category: Solution 下角和右上角的数。左下角的18，往上所有的数变小，往右所有数增加，那么我们就可以和目标数相比较，如果目标数大，就往右搜，如果目标数小，就往上搜。这样就可以判断目标数是否存在。当然我们也可以把起始数放在右上角，往左和下搜，停止条件设置正确就行. class Solution { public: bool searchMatrix(vector>& matrix, int target) { if (matrix.empty() || matrix[0].empty()) return false; if (target matrix.back().back()) return false; int row = matrix.size() - 1, col = 0; while (col = 0) { int val = matrix[row][col]; if (val == target) return true; val > target ? --row : ++col; } return false; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-344-Reverse-String.html":{"url":"Leetcode-344-Reverse-String.html","title":"Reverse String","keywords":"","body":"Question Write a function that takes a string as input and returns the string reversed. Example 1: Input: \"hello\" Output: \"olleh\" Example 2: Input: \"A man, a plan, a canal: Panama\" Output: \"amanaP :lanac a ,nalp a ,nam A\" Difficulty:Easy Category: Analyze 这道题目是关于String操作，很简单的一道题目，只需要两个找到字母，然后交换就好了。 Solution class Solution { public: string reverseString(string s) { for(int left = 0, right = s.size() - 1; left Similar Question Leetcode-345-Reverse-Vowels-of-a-String Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-541-Reverse-String-II.html":{"url":"Leetcode-541-Reverse-String-II.html","title":"Reverse String II","keywords":"","body":"Question Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. Example:Input: s = \"abcdefg\", k = 2 Output: \"bacdfeg\" Restrictions: The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000] Solution class Solution { public: string reverseStr(string s, int k) { int n = s.size(), count = n/2; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-557-Reverse-Words-in-a-String-III.html":{"url":"Leetcode-557-Reverse-Words-in-a-String-III.html","title":"Reverse Words in a String III","keywords":"","body":"Question Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: \"Let's take LeetCode contest\" Output: \"s'teL ekat edoCteeL tsetnoc\" Note: In the string, each word is separated by single space and there will not be any extra space in the string. Solution class Solution { public: string reverseWords(string s) { if (s.size() == 0) return s; for (int left = 0, right = 0; right Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-917-Reverse-Only-Letters.html":{"url":"Leetcode-917-Reverse-Only-Letters.html","title":"Reverse Only Letters","keywords":"","body":"Question Given a string S, return the \"reversed\" string where all characters that are not a letter stay in the same place, and all letters reverse their positions. Example 1: Input: \"ab-cd\" Output: \"dc-ba\" Example 2: Input: \"a-bC-dEf-ghIj\" Output: \"j-Ih-gfE-dCba\" Example 3: Input: \"Test1ng-Leet=code-Q!\" Output: \"Qedo1ct-eeLg=ntse-T!\" Note: S.length 33 S doesn't contain \\ or \" Difficulty:Easy Category:String Solution // Solution: Two Points // Runtimes: 4ms class Solution { public: string reverseOnlyLetters(string S) { if (S.length() == 0) return \"\"; int left = 0, right = S.length() - 1; while (left = right) break; swap(S[left++], S[right--]); } return S; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-345-Reverse-Vowels-of-a-String.html":{"url":"Leetcode-345-Reverse-Vowels-of-a-String.html","title":"Reverse Vowels of a String","keywords":"","body":"Question Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Input: \"hello\" Output: \"holle\" Example 2: Input: \"leetcode\" Output: \"leotcede\" Note:The vowels does not include the letter \"y\". Difficulty:Easy Category: Analyze 这道题目要求交换字符串左右的元音字母a, e, i，o，u, A，E, I，O, U, 我们只用在找到左右都是元音字母的时候进行交换，然后左指针++, '右指针--'就可以继续寻找下一个了。 整体代码结构： public: string reverseVowels(string s) { int left = 0, right = s.size() - 1; while (left 主要需要实现的就是里面寻找到左右都是元音字母的过程。 Solution Solution 1 class Solution { public: string reverseVowels(string s) { int left = 0, right = s.size() - 1; while (left Solution 2 我们尝试使用C++中String类提供的函数来更简洁的完成这个查找的过程。 find_first_of Find character in string (public member function ) find_last_of Find character in string from the end (public member function ) class Solution { public: string reverseVowels(string s) { int left = 0, right = s.size() - 1; while (left Solution3 第三种方式是使用String类型里面的Find函数， 来自于博客：Reverse Vowels of a String 翻转字符串中的元音字母 把元音字母都存在一个字符串里，然后每遇到一个字符，就到元音字符串里去找，如果存在就说明当前字符是元音字符，参见代码如下： class Solution { public: string reverseVowels(string s) { int left = 0, right = s.size() - 1; string t = \"aeiouAEIOU\"; while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-520-Detect-Capital.html":{"url":"Leetcode-520-Detect-Capital.html","title":"Detect Capital","keywords":"","body":"Question Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like \"USA\". All letters in this word are not capitals, like \"leetcode\". Only the first letter in this word is capital if it has more than one letter, like \"Google\". Otherwise, we define that this word doesn't use capitals in a right way. Example 1: Input: \"USA\" Output: True Example 2: Input: \"FlaG\" Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters. Solution class Solution { public: bool detectCapitalUse(string word) { int length = word.size(); int capital_letter = 0, low_letter = 0; for (int i = 0; i = 'A' && word[i] 0 && low_letter==0) return true; if(capital_letter == 0 && low_letter>0) return true; if(capital_letter == 1 && word[0] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-833-Find-And-Replace-in-String.html":{"url":"Leetcode-833-Find-And-Replace-in-String.html","title":"Find And Replace in String(LC.833)","keywords":"","body":"Question To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y. The rule is that if x starts at position i in the original**string S**, then we will replace that occurrence of x with y. If not, we do nothing. For example, if we have S = \"abcd\" and we have some replacement operation i = 2, x = \"cd\", y = \"ffff\", then because \"cd\" starts at position 2 in the original string S, we will replace it with \"ffff\". Using another example on S = \"abcd\", if we have both the replacement operation i = 0, x = \"ab\", y = \"eee\", as well as another replacement operation i = 2, x = \"ec\", y = \"ffff\", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'. All these operations occur simultaneously. It's guaranteed that there won't be any overlap in replacement: for example, S = \"abc\", indexes = [0, 1], sources = [\"ab\",\"bc\"] is not a valid test case. Example 1: Input: S = \"abcd\", indexes = [0,2], sources = [\"a\",\"cd\"], targets = [\"eee\",\"ffff\"] Output: \"eeebffff\" Explanation: \"a\" starts at index 0 in S, so it's replaced by \"eee\". \"cd\" starts at index 2 in S, so it's replaced by \"ffff\". Example 2: Input: S = \"abcd\", indexes = [0,2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"] Output: \"eeecd\" Explanation: \"ab\" starts at index 0 in S, so it's replaced by \"eee\". \"ec\" doesn't starts at index 2 in the original S, so we do nothing. Notes: 0 0 All characters in given inputs are lowercase letters. Difficulty:Medium Category: Analyze Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-459-Repeated-Substring-Pattern.html":{"url":"Leetcode-459-Repeated-Substring-Pattern.html","title":"Repeated Substring Pattern","keywords":"","body":"Question Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. Example 1: Input: \"abab\" Output: True Explanation: It's the substring \"ab\" twice. Example 2: Input: \"aba\" Output: False Example 3: Input: \"abcabcabcabc\" Output: True Explanation: It's the substring \"abc\" four times. (And the substring \"abcabc\" twice.) Solution class Solution { public: bool repeatedSubstringPattern(string s) { int len = s.size(); for(int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-438-Find-All-Anagrams-in-a-String.html":{"url":"Leetcode-438-Find-All-Anagrams-in-a-String.html","title":"Find All Anagrams in a String","keywords":"","body":"Question Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: **Input:** s: \"cbaebabacd\" p: \"abc\" **Output:** [0, 6] **Explanation:** The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: **Input:** s: \"abab\" p: \"ab\" **Output:** [0, 1, 2] **Explanation:** The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". Difficulty:Easy Category:Hash-Table Solution class Solution { public: vector findAnagrams(string s, string p) { vector count(26, 0), rec(26, 0), ans; int len = p.length(); for (char& c : p) ++count[c - 'a']; for (int i = 0; i = len) --rec[s[i - len] - 'a']; ++rec[s[i] - 'a']; // Check the equal if (rec == count) ans.emplace_back(i - len + 1); } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-443-String-Compression.html":{"url":"Leetcode-443-String-Compression.html","title":"String Compression","keywords":"","body":"Question Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array. Follow up:Could you solve it using only O(1) extra space? Example 1: Input: [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"] Output: Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"] Explanation: \"aa\" is replaced by \"a2\". \"bb\" is replaced by \"b2\". \"ccc\" is replaced by \"c3\". Example 2: Input: [\"a\"] Output: Return 1, and the first 1 characters of the input array should be: [\"a\"] Explanation: Nothing is replaced. Example 3: Input: [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"] Output: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"]. Explanation: Since the character \"a\" does not repeat, it is not compressed. \"bbbbbbbbbbbb\" is replaced by \"b12\". Notice each digit has it's own entry in the array. Note: All characters have an ASCII value in [35, 126]. 1 . Analyze 这道题目是计算排序好的字母的每个重复个数，然后转换成其他方式输出出来，如果超过1个的字母就输入字母+个数。处理方式如下： 定义两个指针left=0 和 right=0, 移动right指针 如果right指针指向的元素等于指针left指向的元素，那么就继续移动指针right 如果right指针指向的元素不等于指针left指向的元素，那么就将指针left的值赋值给最开始的一个元素，然后left自加1;如果此时right-left ==1，那么就跳出这一次循环，如果没有，那么就将right-left赋值给char[cur++]实现将大约1的元素个数存到元素字母的后面。 返回cur Solution class Solution { public: int compress(vector& chars) { int n = chars.size(), cur = 0; for (int left = 0, right = 0; left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-125-Valid-Palindrome.html":{"url":"Leetcode-125-Valid-Palindrome.html","title":"Valid Palindrome","keywords":"","body":"Question Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: \"A man, a plan, a canal: Panama\" Output: true Example 2: Input: \"race a car\" Output: false Difficulty:Easy Category: Solution class Solution { public: bool isPalindrome(string s) { int left = 0, right = s.length(); while (left 使用两根指针遍历整个字符串即可, 假定有指针i, j, 其中i是从前往后遍历, j是从后往前遍历. 当i在j左边时继续循环, 每一次将i右移到数字/字母上, j左移到数字/字母上, 比较二者对应的字符串内的字符是否相同,不相同则原字符串不是回文串. 如果全部的比较都相同, 说明是回文串. class Solution { public: bool isPalindrome(string s) { int left = 0, right = s.length() - 1; // Move to the while (left = 0 && !isdigit(s[right]) && !isalpha(s[right])) --right; if (left == s.length()) return true; if (tolower(s[left++]) != tolower(s[right--])) return false; } return true; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-680-Valid-Palindrome-II.html":{"url":"Leetcode-680-Valid-Palindrome-II.html","title":"Valid Palindrome II","keywords":"","body":"Question Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome. Example 1: Input: \"aba\" Output: True Example 2: Input: \"abca\" Output: True Explanation: You could delete the character 'c'. Note: The string will only contain lowercase characters a-z. The maximum length of the string is 50000. Solution // O(n) Time O(1) Space class Solution { public: bool validPalindrome(string s) { int n = s.length(); int left = 0, right = n - 1; while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-647-Palindromic-Substrings.html":{"url":"Leetcode-647-Palindromic-Substrings.html","title":"Palindromic Substrings","keywords":"","body":"Question Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: Input: \"abc\" Output: 3 Explanation: Three palindromic strings: \"a\", \"b\", \"c\". Example 2: Input: \"aaa\" Output: 6 Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". Note: The input string length won't exceed 1000. Solution class Solution { public: int countSubstrings(string s) { int len = s.size(), cnt = len; for (int left = 0; left = right) return true; if (s[left] != s[right]) return false; right--; } return true; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-5-Longest-Palindromic-Substring.html":{"url":"Leetcode-5-Longest-Palindromic-Substring.html","title":"Longest Palindromic Substring","keywords":"","body":"Question Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: \"babad\"Output: \"bab\"Note: \"aba\" is also a valid answer. Example 2: Input: \"cbbd\"Output: \"bb\" Difficulty:Medium Category:String Analyze 这道题让我们求的是最长回文串，那么什么是回文串呢？ “回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。 那么这道题，我们要求解最长的回文串的话，可以使用对称验证的方式进行判断，对称验证有两种情况，回文串长度为奇数或者为偶数。如果回文串长度为奇数，那么是以一个字符作为中心的，如果回文串的长度为偶数，那么是以两个相同的字符来作为中心的。分为这两种情况分别进行遍历查找。 Solution C++实现 class Solution { public: string longestPalindrome(string s) { if (s == \"\") return s; int start = 0, left = 0, right = 0, len = 0; for (int i = 0; i = 0 && (right + diff) Solution 2: Greedy 贪婪算法，对每一个位置分别向两边扩展，计算能够扩展得到的最长回文字符。 #include #include string longestPalindrome(string s) { int best_len = 0; int start = 0; for (int i = 0; i best_len) { best_len = l; start = i - (l - 1) / 2; // Get the start index, i is the medium index, And l is the len } } return s.substr(start, best_len); // Get the substr in [start, best_len] } // Get the palindrome len from the medium to both sides. int getLen(const string& s, int l, int r) { if (s[l] != s[r]) return 1; while (l >= 0 && r Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-10-Regular-Expression-Match.html":{"url":"Leetcode-10-Regular-Expression-Match.html","title":"Regular Expression Match","keywords":"","body":"Question Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: Input: s = \"aa\"p = \"a\"Output: falseExplanation: \"a\" does not match the entire string \"aa\". Example 2: Input:s = \"aa\"p = \"a\"Output: trueExplanation: '' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input:s = \"ab\"p = \".\"Output: trueExplanation: \".\" means \"zero or more (*) of any character (.)\". Example 4: Input:s = \"aab\"p = \"cab\"Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches \"aab\". Example 5: Input:s = \"mississippi\"p = \"misisp.\"*Output: false Difficulty:Hard Category:String, DP Analyze 这道求正则表达式匹配的题和那道 Wildcard Matching 通配符匹配的题很类似，不同点在于的意义不同，在之前那道题中，表示可以代替任意个数的字符，而这道题中的表示之前那个字符可以有0个，1个或是多个，就是说，字符串ab，可以表示b或是aaab，即a的个数任意，这道题的难度要相对之前那一道大一些，分的情况的要复杂一些，需要用递归Recursion来解，大概思路如下： 若p为空，若s也为空，返回true，反之返回false 若p的长度为1，若s长度也为1，且相同或是p为'.'则返回true，反之返回false 若p的第二个字符不为*，若此时s为空返回false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配 若p的第二个字符为*，若s不为空且字符匹配，调用递归函数匹配s和去掉前两个字符的p，若匹配返回true，否则s去掉首字母 返回调用递归函数匹配s和去掉前两个字符的p的结果 Solution class Solution { public: bool isMatch(string s, string p) { if (p.empty()) return s.empty(); if (p.size() == 1) { return (s.size() == 1 && ((s[0] == p[0]) || p[0] == '.')); } if (p[1] != '*') { if (s.empty()) return false; return (s[0] == p[0] || p[0] == '.') && isMatch(s.substr(1), p.substr(1)); } while (!s.empty() && (s[0] == p[0] || p[0] == '.')) { if (isMatch(s, p.substr(2))) return true; s = s.substr(1); } return isMatch(s, p.substr(2)); } }; Others if( p.empty() && s.empty() ) return true; 和 if (p.empty()) return s.empty();的差异 如果要实现p为空，在s也为空的情况下，返回真值的情况的话，写成p.empty() && s.empty(), 那么在后面的if语句中必须有一个return false; 因为第一种书写方式，是没有处理p.empty()&& !s.empty()这种情况的，这就会出现问题。当出现这种情况的时候，没有返回值，或者返回值出错。 需要仔细理解的地方是： while (!s.empty() && (s[0] == p[0] || p[0] == '.')) { if (isMatch(s, p.substr(2))) return true; s = s.substr(1); } 当这里出现*号的时候，可能前面的字母只有0个或者有很多个，先将其作为有0个的方式去处理，那就是isMatch(s, p.substr(2)),如果有很多个的处理方式就是s = s.substr(1);之后，在判断第一位是不是还和p[0]相同 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-44-Wildcard-Matching.html":{"url":"Leetcode-44-Wildcard-Matching.html","title":"Wildcard Matching","keywords":"","body":"﻿--- title: Leetcode 44. Wildcard-Matching date: 2018-06-18 11:50:32 updated: 2018-06-18 11:50:32 categories: Leetcode tags: Leetcode notshow: true Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-709-To-Lower-Case.html":{"url":"Leetcode-709-To-Lower-Case.html","title":"To Lower Case","keywords":"","body":"Question Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase. Example 1: Input: \"Hello\" Output: \"hello\" Example 2: Input: \"here\" Output: \"here\" Example 3: Input: \"LOVELY\" Output: \"lovely\" Solution class Solution { public: string toLowerCase(string str) { int len = str.size(); for (int i = 0; i =65 && str[i] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-168-Excel-Sheet-Column-Title.html":{"url":"Leetcode-168-Excel-Sheet-Column-Title.html","title":"Excel Sheet Column Title","keywords":"","body":"Question Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 1 -> A 2 -> B 3 -> C ... 26 -> Z 27 -> AA 28 -> AB ... Example 1: Input: 1 Output: \"A\" Example 2: Input: 28 Output: \"AB\" Example 3: Input: 701 Output: \"ZY\" Difficulty:Easy Category: Solution class Solution { public: string convertToTitle(int n) { string ans = \"\"; while (n > 0) { n -= 1; char temp = 'A' + n % 26; n = n / 26; ans = temp + ans; } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-171-Excel-Sheet-Column-Number.html":{"url":"Leetcode-171-Excel-Sheet-Column-Number.html","title":"Excel Sheet Column Number","keywords":"","body":"Question Given a column title as appear in an Excel sheet, return its corresponding column number. For example: A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... Example 1: Input: \"A\" Output: 1 Example 2: Input: \"AB\" Output: 28 Example 3: Input: \"ZY\" Output: 701 Difficulty:Easy Category:Math Solution class Solution { public: int titleToNumber(string s) { int ans = 0; for (const char c : s) { ans *= 26; ans += c - 'A' + 1; } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-12-Integer-to-Roman.html":{"url":"Leetcode-12-Integer-to-Roman.html","title":"Integer to Roman","keywords":"","body":"﻿Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: \"III\" Example 2: Input: 4 Output: \"IV\" Example 3: Input: 9 Output: \"IX\" Example 4: Input: 58 Output: \"LVIII\" Explanation: C = 100, L = 50, XXX = 30 and III = 3. Example 5: Input: 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Difficulty:Medium Category:Math, String Analyze 之前那篇文章写的是罗马数字转化成整数(http://www.cnblogs.com/grandyang/p/4120857.html)， 这次变成了整数转化成罗马数字，基本算法还是一样。由于题目中限定了输入数字的范围(1 - 3999), 使得题目变得简单了不少。 例如整数 1437 的罗马数字为 MCDXXXVII， 我们不难发现，千位，百位，十位和个位上的数分别用罗马数字表示了。 1000 - M, 400 - CD, 30 - XXX, 7 - VII。所以我们要做的就是用取商法分别提取各个位上的数字，然后分别表示出来： 100 - C 200 - CC 300 - CCC 400 - CD 500 - D 600 - DC 700 - DCC 800 - DCCC 900 - CM 我们可以分为四类，100到300一类，400一类，500到800一类，900最后一类。每一位上的情况都是类似的，代码如下： -# Solution class Solution { public: string intToRoman(int num) { string res = \"\"; char roman[] = {'M', 'D', 'C', 'L', 'X', 'V', 'I'}; int integer[] = {1000, 500, 100, 50, 10, 5, 1}; for (int i = 0; i 4 && val Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-13-Roman-to-Integer.html":{"url":"Leetcode-13-Roman-to-Integer.html","title":"Roman to Integer","keywords":"","body":"﻿Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: \"III\" Example 2: Input: 4 Output: \"IV\" Example 3: Input: 9 Output: \"IX\" Example 4: Input: 58 Output: \"LVIII\" Explanation: C = 100, L = 50, XXX = 30 and III = 3. Example 5: Input: 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Difficulty:Easy Category:Array Analyze 我们需要用到map数据结构，来将罗马数字的字母转化为对应的整数值，因为输入的一定是罗马数字，那么我们只要考虑两种情况即可： 第一，如果当前数字是最后一个数字，或者之后的数字比它小的话，则加上当前数字 第二，其他情况则减去这个数字 Solution class Solution { public: int romanToInt(string s) { int res = 0; unordered_map value{{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}}; for (int i = 0; i 我们也可以每次跟前面的数字比较，如果小于等于前面的数字，我们先加上当前的数字，如果大于的前面的数字，我们加上当前的数字减去二倍前面的数字，这样可以把在上一个循环多加数减掉，参见代码如下: class Solution { public: int romanToInt(string s) { int res = 0; unordered_map m{{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}}; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-8-String-to-Integer.html":{"url":"Leetcode-8-String-to-Integer.html","title":"String to Integer","keywords":"","body":"Question Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: Input: \"42\" Output: 42 Example 2: Input: \" -42\" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign.Then take as many numerical digits as possible, which gets 42. Example 3: Input: \"4193 with words\" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: Input: \"words and 987\" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: \"-91283472332\" Output: -2147483648 Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. hefore INT_MIN (−231) is returned. Difficulty:Medium Category:String Analyze 由于输入的是字符串，所以需要题目中给出的情况: 若字符串开头是空格，则跳过所有空格，到第一个非空格字符，如果没有，则返回0. while(i 若第一个字符不是符号+/-和数字，则返回0. 若第一个非空格字符是符号+/-，则标记sign的正负. 在第一个字符是数字或者符号+/-的情况下, 如果下一个字符是数字，则转为整形存下来，若接下来再有非数字出现，则返回目前的结果。 还需要考虑边界问题，如果超过了整形数的范围，则用边界值替代当前值。 if (base > INT_MAX / 10 || (base == INT_MAX / 10 && (str[i] - '0') > 7)) { return (symbol == 1) ? INT_MAX : INT_MIN; } base = base * 10 + (str[i++] - '0'); 注意, 这里判断的时候, 是判断的base*10之前的数据情况, 所以判断base > INT_MAX / 10 || (base == INT_MAX / 10 && (str[i] - '0') > 7) 如果 base > INT_MAX/10 那么说明数据完全溢出了, 如果当前的base == INT_MAX/10那么说明有超出的风险, 需要检查最后一位数是否太大. 因为最后一位数INT的正数最大为7, 负数最小值的最小位最多为8, 所以当最小位 > 7的时候, 就可以将其判断为异常的数据, 因为异常的话, 如果为负数, 给它赋值之后, 也是负数的最小值. 是正确的. Solution class Solution { public: int myAtoi(string str) { if (str.size() == 0) return 0; int symbol = 1, base = 0, i = 0, len = str.size(); // Find the first letter: +/- while (i = '0' && str[i] INT_MAX / 10 || (base == INT_MAX / 10 && (str[i] - '0') > 7)) { return (symbol == 1) ? INT_MAX : INT_MIN; } base = base * 10 + (str[i++] - '0'); } return base * symbol; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-38-Count-And-Say.html":{"url":"Leetcode-38-Count-And-Say.html","title":"Count And Say","keywords":"","body":"Question The count-and-say sequence is the sequence of integers with the first five terms as following: 1 11 21 1211 111221 1 is read off as \"one 1\" or 11.11 is read off as \"two 1s\" or 21.21 is read off as \"one 2, then one 1\" or 1211. Given an integer n, generate the _n_th term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: Input: 1 Output: \"1\" Example 2: Input: 4 Output: \"1211\" Solution class Solution { public: string countAndSay(int n) { if (n 其实我们可以发现字符串中永远只会出现1,2,3这三个字符，假设第k个字符串中出现了4，那么第k-1个字符串必定有四个相同的字符连续出现，假设这个字符为1，则第k-1个字符串为x1111y。第k-1个字符串是第k-2个字符串的读法，即第k-2个字符串可以读为“x个1,1个1,1个y” 或者“个x,1个1,1个1,y个”，这两种读法分别可以合并成“x+1个1,1个y” 和 “个x，2个1，y个”，代表的字符串分别是“(x+1)11y” 和 \"x21y\"，即k-1个字符串为“(x+1)11y” 或 \"x21y\"，不可能为“x1111y”. Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-984-String-Without-AAA-or-BBB.html":{"url":"Leetcode-984-String-Without-AAA-or-BBB.html","title":"String Without AAA or BBB(LC.984)","keywords":"","body":"Question Given two integers A and B, return any string S such that: S has length A + B and contains exactly A 'a' letters, and exactly B 'b' letters; The substring 'aaa' does not occur in S; The substring 'bbb' does not occur in S. Example 1: Input: A = 1, B = 2 Output: \"abb\" Explanation: \"abb\", \"bab\" and \"bba\" are all correct answers. Example 2: Input: A = 4, B = 1 Output: \"aabaa\" Note: 0 0 It is guaranteed such an S exists for the given A and B. Difficulty:Medium Category: Solution 来自于讨论区的一个解法: Clean C++/python solution class Solution { public: string strWithout3a3b(int A, int B) { if (A == 0) return string(B, 'b'); else if (B == 0) return string(A, 'a'); else if (A == B) return \"ab\" + strWithout3a3b(A - 1, B - 1); else if (A > B) return \"aab\" + strWithout3a3b(A - 2, B - 1); else return strWithout3a3b(A - 1, B - 2) + \"abb\"; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-72-Edit-Distance.html":{"url":"Leetcode-72-Edit-Distance.html","title":"Edit Distance(LC.72)","keywords":"","body":"Question Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = \"horse\", word2 = \"ros\" Output: 3 Explanation: horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e') Example 2: Input: word1 = \"intention\", word2 = \"execution\" Output: 5 Explanation: intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u') Difficulty:Hard Category:String, Dynamic-Programming Analyze 在这道题目中，使用动态规划的方式来求解。设状态f[i][j]表示A[0,i]和B[0,j]之间的最小编辑距离，假设两个string分别为word1和word2. 如果word1[i-1] == word2[j-1], 则f[i][j] = f[i-1][j-1], 这就是表示A[0, i]和B[0,j]之间的编辑距离为f[i][j]. 如果word1[i-1] != word2[j-1], 则 如果word1[i-1]替换为word2[j-1]，那么f[i][j] = f[i-1][j-1] + 1 如果word1[i-1]后添加word2[j-1]，那么f[i][j] = f[i][j-1] + 1 如果word1[i-1]删除，那么f[i][j] = f[i-1][j] + 1 Solution class Solution { public: int minDistance(string word1, string word2) { const size_t m = word1.length(); const size_t n = word2.length(); int f[m + 1][n + 1]; for (size_t i = 0; i Related Question Leetcode 72. Edit Distance Leetcode 712. Minimum ASCII Delete Sum for Two Strings Leetcode 583. Delete Operation for Two Strings Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-161-One-Edit-Distance.html":{"url":"Leetcode-161-One-Edit-Distance.html","title":"One Edit Distance(LC.161)","keywords":"","body":"Question Given two strings S and T, determine if they are both one edit distance apart. Difficulty:Medium Category: Analyze 判断两个字符串的编辑距离(删除或替代)是否为1，分三种情况考虑： 两个字符串的长度之差大于1，那么直接返回False 两个字符串的长度之差等于1，那么长的那个字符串去掉一个字符，剩下的应该和短的字符串相同(删除的方式) 两个字符串的长度之差等于0，那么两个字符串对应位置的字符只能有一处不同，也不能完全相同(替换的方式得到相同字符串)。 Solution class Solution { public: bool isOneEditDistance(string s, string t) { if (s.size() = 2) return false; else if (diff == 1) { for (int i = 0; i 我们实际上可以让代码写的更加简洁，只需要对比两个字符串对应位置上的字符，如果遇到不同的时候，这时我们看两个字符串的长度关系，如果相等，那么我们比较当前位置后的字串是否相同，如果s的长度大，那么我们比较s的下一个位置开始的子串，和t的当前位置开始的子串是否相同，反之如果t的长度大，那么我们比较t的下一个位置开始的子串，和s的当前位置开始的子串是否相同。如果循环结束，都没有找到不同的字符，那么此时我们看两个字符串的长度是否相差1，参见代码如下： class Solution { public: bool isOneEditDistance(string s, string t) { for (int i = 0; i Follow up 如果你只能够使用 remove 的编辑方式的话，那么能不能够在最多只修改两边一个字符的情况下得到相同的字符串呢。 class Solution { public: bool isOneEditDistance(string s, string t) { if (s.size() = 2) return false; else if (diff == 1) { for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-28-Implement-StrStr.html":{"url":"Leetcode-28-Implement-StrStr.html","title":"Implement StrStr","keywords":"","body":"Question Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = \"hello\", needle = \"ll\" Output: 2 Example 2: Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf()). Difficulty:Easy Category:String, Two Points Solution class Solution { public: int strStr(string haystack, string needle) { if (needle.empty()) return 0; int len_m = haystack.size(), len_n = needle.size(); if (len_m Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-67-Add-Binary.html":{"url":"Leetcode-67-Add-Binary.html","title":"Add Binary","keywords":"","body":"Question Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = \"11\", b = \"1\" Output: \"100\" Example 2: Input: a = \"1010\", b = \"1011\" Output: \"10101\" Difficulty:Easy Category:String Analyze 这道题目需要设置两个指针分别在指向两个string的最后一位，然后在设置一个标志位carry, 每次如果最低位的和大约2的话，就carry = sum / 2得到需要进位的部分，继续指针左移，计算下一个，最后的时候，如果carry还没有为0, 那就在string res的前面加上1，就是1 + res。 Solution Time complexity: O(max(len_a, len_b)) Space complexity: O(n) class Solution { public: string addBinary(string a, string b) { string ans; int len_a = a.length() - 1, len_b = b.length() - 1; int carry = 0; while (len_a >= 0 || len_b >= 0) { int m = len_a >= 0 ? a[len_a--] - '0' : 0; int n = len_b >= 0 ? b[len_b--] - '0' : 0; int sum = m + n + carry; ans = to_string(sum % 2) + ans; carry = sum / 2; } return carry == 1 ? to_string(carry) + ans : ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-14-Longest-Common-Prefix.html":{"url":"Leetcode-14-Longest-Common-Prefix.html","title":"Longest Common Prefix","keywords":"","body":"﻿Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Difficulty:Easy Category: Analyze 这道题让我们求一系列字符串的共同前缀，没有什么特别的技巧，无脑查找即可，我们定义两个变量i和j，其中i是遍历搜索字符串中的字符，j是遍历字符串集中的每个字符串。这里将单词上下排好，则相当于一个各行长度有可能不相等的二维数组，我们遍历顺序和一般的横向逐行遍历不同，而是采用纵向逐列遍历，在遍历的过程中，如果某一行没有了，说明其为最短的单词，因为共同前缀的长度不能长于最短单词，所以此时返回已经找出的共同前缀。我们每次取出第一个字符串的某一个位置的单词，然后遍历其他所有字符串的对应位置看是否相等，如果有不满足的直接返回res，如果都相同，则将当前字符存入结果，继续检查下一个位置的字符，参见代码如下： Solution class Solution { public: string longestCommonPrefix(vector& strs) { if (strs.empty()) return \"\"; string res = \"\"; for (int i = 0; i = strs[j].size() || strs[j][i] != c) return res; } res.push_back(c); } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-65-Valid-Number.html":{"url":"Leetcode-65-Valid-Number.html","title":"Valid Number","keywords":"","body":"﻿Validate if a given string is numeric. Some examples:\"0\" => true\" 0.1 \" => true\"abc\" => false\"1 a\" => false\"2e10\" => true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. Update (2015-02-10):The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. Difficulty:Hard Category:Math, String Analyze 在字符串中, 所有的字符可以分为六类: 空格，符号，数字，小数点，自然底数e和其他字符;只要出现了其他字符就可以return false, 出现其他几个字符是可以的, 在这里我们设置num, dot, exp, sign分别表示数字，小数点，自然底数和符号是否出现，另外设置numberAfterE表示自然底数后面是否有数字出现, 这几种情况下详细分析: 空格： 我们需要排除的情况是，当前位置是空格而后面一位不为空格，但是之前有数字，小数点，自然底数或者符号出现时返回false。 符号：符号前面如果有字符的话必须是空格或者是自然底数，标记sign为true。 数字：标记num为true, 如果前面出现了自然底数, 那么标记numAfterE为true。 小数点：如果之前出现过小数点或者自然底数，返回false，否则标记dot为true。 自然底数：如果之前出现过自然底数或者之前从未出现过数字，返回false，否则标记exp为true，numAfterE为false。 其他字符：返回false。 最后返回num && numAfterE即可。 Solution class Solution { public: bool isNumber(string s) { bool num = false, dot = false, numberAfterE = true, exp = false, sign = false; int len = s.size(); for (int i = 0; i 0 && s[i - 1] != 'e' && s[i - 1] != 'E' && s[i - 1] != ' ') return false; sign = true; } else if (s[i] == 'e' || s[i] == 'E') { if (!num || exp) return false; exp = true; numberAfterE = false; } else if (s[i] == '.') { if (dot || exp) return false; dot = true; } else if (s[i] >= '0' && s[i] Non-regex version class Solution { public: bool isNumber(string s) { int n = s.length(); int left = 0, right = n - 1; // Deal with the space while (left right) return false; while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-929-Unique-Email-Addresses.html":{"url":"Leetcode-929-Unique-Email-Addresses.html","title":"Unique Email Addresses(LC.929)","keywords":"","body":"Question Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\"forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? Example 1: Input: [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"] Output: 2 Explanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails Note: 1 1 Each emails[i] contains exactly one '@' character. Difficulty:Easy Category:String Solution class Solution { public: int numUniqueEmails(vector& emails) { unordered_set rec; for (auto& email : emails) { std::size_t found = email.find(\"@\"); string local = email.substr(0, found), domain = email.substr(found + 1); found = local.find(\"+\"); while (found != std::string::npos) { local = local.substr(0, found); found = local.find(\"+\"); } found = local.find(\".\"); while (found != std::string::npos) { local.erase(found); found = local.find(\".\"); } rec.insert(local + \"@\" + domain); } return rec.size(); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-3-Longgest-Substring-Without-Repeating-Characters.html":{"url":"Leetcode-3-Longgest-Substring-Without-Repeating-Characters.html","title":"Longgest Substring Without Repeating Characters","keywords":"","body":"Question Given a string, find the length of the longest substring without repeating characters.Examples:Given \"abcabcbb\", the answer is \"abc\", which the length is 3.Given \"bbbbb\", the answer is \"b\", with the length of 1.Given \"pwwkew\", the answer is \"wke\", with the length of 3.Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Difficulty:Medium Category:String Analyze 思路：其实只需要前面出现过的重复字符的下标即可算出此段不重复子段的长度，核心操作其实是向前检索重复字符。需要注意的是最后循环完成后，需要再算一下没有计算的那段的长度，在这些子段中取最长的。O(n) Solution 1.蛮力法（Brute Force） 首先试了试暴力搜索，遍历一次字符串，遍历过程中，对每个字符都有一个 O(N^2)的处理时间，因为需要遍历该字符之后的字符串，对每个字符，需要和已有的子串相比较，如果不重复，则加入子串，不然就遍历下一个字符。加起来时间复杂度为 O(N^3)。 int lengthOfLongestSubstring(string s) { int length = s.size(); int maxlength = 0; for (int i = 0; i charSet; for (int i = start; i 2.Hash法 这类问题应该学会分析结果的特点，比如说前面的最长回文子串，是利用了回文串的对称性，那么无重复子串呢，想到无重复，可以想到可以使用 hash，当新的字符来了，有冲突，就说明前面是有重复的。 算法思想：两次循环得到所有的子串，用 hash 判断是否重复。 代码中需要注意的地方： 以字符对应的 ASCII 码作为 hash 值，visit[s[i]] = 0，说明 s[i] 这个字符还没有出现过，visit[s[i]] = 1 说明有重复。 在每次内层循环重新开始的时候，都要将 visit 初始化为 0，每次内层循环求的是 s[i...j] 之间的最长子串，要判断他们之间是否有重复，所以要确保 i...j 这个范围内的 visit 都没初始化为 0 了，否则出现 i...j 之间的字符和这个范围之外的字符重复就会导致结果出错。 int lengthOfLongestSubstring(string s) { int length = s.size(); int maxlength = 0; int i, j; for (i = 0; i maxlength) { maxlength = j - i; } break; } } if ((j == length) && (j - i > maxlength)) { maxlength = j - i; } } return maxlength; } ```c 3.Sliding Window Sliding Window方法就是使用了动态规划+HashSet。首先理解，动态规划算法的思想，将问题分解为子问题的解，找到重叠子问题和最优子结构，对需要重复计算的结果进行存储。而使用了HashSet之后，重叠子问题操作可以简单很多，只需要 2N 步就能得出结果。 ```cpp int lengthOfLongestSubstring(string s) { int length = s.size(); int maxlength = 0, i = 0, j = 0; set charSet; while (i 4.优化的Sliding Window 使用HashMap和ASCII 使用HashMap int lengthOfLongestSubstring(string s) { int length = s.size(); int maxlength = 0; map hashMap; for (int i = 0, j = 0; j (s.at(j), j + 1)); } maxlength = max(maxlength, j - i + 1); } return maxlength; } 使用ASCII int lengthOfLongestSubstring(string s) { int length = s.size(); vector vect(128, -1); int maxlength = 0, start = -1; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-434-Number-of-Segments-in-a-String.html":{"url":"Leetcode-434-Number-of-Segments-in-a-String.html","title":"Number of Segments in a String","keywords":"","body":"Question Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example: Input: \"Hello, my name is John\" Output: 5 Analyze 在给定的一段字符串中，判断出来里面的单词个数，我们只需要设置一个word开始的标志位word_flag，刚刚单词开始的时候将其设置为1，当出现空格的时候，将其变成0，这样我们就可以记录单词的格式，如果到最后一个字母的话，那就将其作为单词的结尾，给单词数量加1. Solution class Solution { public: int countSegments(string s) { int len = s.length(), count = 0, word_flag = 0; for(int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-686-Repeated-String-Match.html":{"url":"Leetcode-686-Repeated-String-Match.html","title":"Repeated String Match","keywords":"","body":"Question Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = \"abcd\" and B = \"cdabcdab\". Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times (\"abcdabcd\"). Note:The length of A and B will be between 1 and 10000. solution class Solution { public: int repeatedStringMatch(string A, string B) { int length_a = A.size(), length_b = B.size(); string temp; int n = length_b/length_a; if(length_b % length_a != 0) n = n+1; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-696-Count-Binary-Substrings.html":{"url":"Leetcode-696-Count-Binary-Substrings.html","title":"Count Binary Substrings","keywords":"","body":"Question Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example 1: Input: \"00110011\" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\". Notice that some of these substrings repeat and are counted the number of times they occur. Also, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together. Example 2: Input: \"10101\" Output: 4 Explanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's. Note: s.length will be between 1 and 50,000. s will only consist of \"0\" or \"1\" characters. Analyze Solution class Solution { public: int countBinarySubstrings(string s) { int res = 0; int pre = 0, cur = 1; for (int i = 1; i = cur) ++res; } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-791-Custom-Sort-String.html":{"url":"Leetcode-791-Custom-Sort-String.html","title":"Custom Sort String","keywords":"","body":"Question S and T are strings composed of lowercase letters. In S, no letter occurs more than once. S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string. Return any permutation of T (as a string) that satisfies this property. Example : Input: S = \"cba\" T = \"abcd\" Output: \"cbad\" Explanation: \"a\", \"b\", \"c\" appear in S, so the order of \"a\", \"b\", \"c\" should be \"c\", \"b\", and \"a\". Since \"d\" does not appear in S, it can be at any position in T. \"dcba\", \"cdba\", \"cbda\" are also valid outputs. Note: S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only. Solution class Solution { public: string customSortString(string S, string T) { string ans; vector rec(26, 0); for (char& c : T) rec[c - 'a']++; for (int i = 0; i 0) { ans += i + 'a'; rec[i]--; } } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-942-DI-String-Match.html":{"url":"Leetcode-942-DI-String-Match.html","title":"DI String Match","keywords":"","body":"Question Given a string S that only contains \"I\" (increase) or \"D\" (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1: If S[i] == \"I\", then A[i] If S[i] == \"D\", then A[i] > A[i+1] Example 1: Input: \"IDID\" Output: [0,4,1,3,2] Example 2: Input: \"III\" Output: [0,1,2,3] Example 3: Input: \"DDI\" Output: [3,2,0,1] Difficulty:Easy Category:Math Solution class Solution { public: vector diStringMatch(string S) { const int n = S.length(); vector ans(n + 1, INT_MIN); int h = n, l = 0; for (int i = 0; i 适当进行一些优化： class Solution { public: vector diStringMatch(string S) { const int n = S.length(); vector ans; ans.reserve(n+1); int h = n, l = 0; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-893-Groups-Of-Special_equivalent-Strings.html":{"url":"Leetcode-893-Groups-Of-Special_equivalent-Strings.html","title":"Groups Of Special_equivalent Strings","keywords":"","body":"Question You are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A. Example 1: Input: [\"a\",\"b\",\"c\",\"a\",\"c\",\"c\"] Output: 3 Explanation: 3 groups [\"a\",\"a\"], [\"b\"], [\"c\",\"c\",\"c\"] Example 2: Input: [\"aa\",\"bb\",\"ab\",\"ba\"] Output: 4 Explanation: 4 groups [\"aa\"], [\"bb\"], [\"ab\"], [\"ba\"] Example 3: Input: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"] Output: 3 Explanation: 3 groups [\"abc\",\"cba\"], [\"acb\",\"bca\"], [\"bac\",\"cab\"] Example 4: Input: [\"abcd\",\"cdab\",\"adcb\",\"cbad\"] Output: 1 Explanation: 1 group [\"abcd\",\"cdab\",\"adcb\",\"cbad\"] Note: 1 1 All A[i] have the same length. All A[i] consist of only lowercase letters. Solution class Solution { public: int numSpecialEquivGroups(vector& A) { std::unordered_set myset; for (string x : A) { std::string odd, even; for(int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-859-Buddy-Strings.html":{"url":"Leetcode-859-Buddy-Strings.html","title":"Buddy Strings","keywords":"","body":"Question Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B. Example 1: Input: A = \"ab\", B = \"ba\" Output: true Example 2: Input: A = \"ab\", B = \"ab\" Output: false Example 3: Input: A = \"aa\", B = \"aa\" Output: true Example 4: Input: A = \"aaaaaaabc\", B = \"aaaaaaacb\" Output: true Example 5: Input: A = \"\", B = \"aa\" Output: false Note: 0 0 A and B consist only of lowercase letters. Solution class Solution { public: bool buddyStrings(string A, string B) { int diff_num = 0; if (A.size() != B.size()) return false; for (int i = 0; i 2) return false; } if (diff_num == 1) return false; else if (diff_num == 2) { sort(A.begin(), A.end()); sort(B.begin(), B.end()); if (A == B) return true; } else { if (A.size() > 256) return true; bool result[256] = {false}; for (size_t i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-87-Scramble-String.html":{"url":"Leetcode-87-Scramble-String.html","title":"Scramble String","keywords":"","body":"Question Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = \"great\": To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node \"gr\" and swap its two children, it produces a scrambled string \"rgeat\". We say that \"rgeat\" is a scrambled string of \"great\". Similarly, if we continue to swap the children of nodes \"eat\" and \"at\", it produces a scrambled string \"rgtae\". We say that \"rgtae\" is a scrambled string of \"great\". Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. Example 1: Input: s1 = \"great\", s2 = \"rgeat\" Output: true Example 2: Input: s1 = \"abcde\", s2 = \"caebd\" Output: false Difficulty:Hard Category:String, Dynamic-Programming Solution Solution 1 递归的方案。 class Solution { public: bool isScramble(string s1, string s2) { // 1. Exclude option if (s1.length() != s2.length()) return false; if (s1 == s2) return true; // 2. Exclude the sort(s1)!=sort(s2) string str1 = s1, str2 = s2; sort(str1.begin(), str1.end()); sort(str2.begin(), str2.end()); if (str1 != str2) return false; // 3. Recursion for (unsigned int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-58-Length-of-Last-Word.html":{"url":"Leetcode-58-Length-of-Last-Word.html","title":"Length of Last Word","keywords":"","body":"Question Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: \"Hello World\" Output: 5 Solution class Solution { public: int lengthOfLastWord(string s) { int right = 0, flag_right =0; if (s.size() == 0) return 0; for (int i = s.size() -1; i >= 0; --i) { if (flag_right == 1 && s[i] == ' ') { return right - i; } else { if (s[i] != ' ' && flag_right == 0) { flag_right = 1; right = i; } } } if (flag_right == 0) return 0; else return right+1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-720-Longest-Word-in-Dictionary.html":{"url":"Leetcode-720-Longest-Word-in-Dictionary.html","title":"Longest Word in Dictionary","keywords":"","body":"Question Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Example 1: Input: words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"] Output: \"world\" Explanation: The word \"world\" can be built one character at a time by \"w\", \"wo\", \"wor\", and \"worl\". Example 2: Input: words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"] Output: \"apple\" Explanation: Both \"apply\" and \"apple\" can be built from other words in the dictionary. However, \"apple\" is lexicographically smaller than \"apply\". Note: All the strings in the input will only contain lowercase letters. The length of words will be in the range [1, 1000]. The length of words[i] will be in the range [1, 30]. Difficulty:Easy Category:Hash-Table, Trie Solution class Solution { public: vector letterCombinations(string digits) { if (digits.empty()) return {}; vector ans; string dict[] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; letterCombinationsDFS(digits, dict, 0, \"\", ans); return ans; } private: void letterCombinationsDFS(const string& digits, string dict[], int index, string out, vector& ans) { if (index == digits.size()) { ans.emplace_back(out); return; } string str = dict[digits[index] - '0']; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-583-Delete-Operation-For-Two-String.html":{"url":"Leetcode-583-Delete-Operation-For-Two-String.html","title":"Delete Operation For Two String","keywords":"","body":"Question Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. Example 1: Input: \"sea\", \"eat\" Output: 2 Explanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\". Note: The length of given words won't exceed 500. Characters in given words can only be lower-case letters. Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-953-Verifying-an-Alien-Dictionary.html":{"url":"Leetcode-953-Verifying-an-Alien-Dictionary.html","title":"Verifying an Alien Dictionary","keywords":"","body":"Question In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language. Example 1: Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted. Example 3: Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (More info). Note: 1 1 order.length == 26 All characters in words[i] and order are english lowercase letters. Difficulty:Easy Category:Hash-Table Solution Time complexity: O(n) Space complexity: O(n) class Solution { public: bool isAlienSorted(vector& words, string order) { vector m(26); // Build the map table for (int i = 0; i 0 && words[i] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-925-Long-Pressed-Name.html":{"url":"Leetcode-925-Long-Pressed-Name.html","title":"Long Pressed Name","keywords":"","body":"Question Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. Example 1: Input: name = \"alex\", typed = \"aaleex\" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed. Example 2: Input: name = \"saeed\", typed = \"ssaaedd\" Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output. Example 3: Input: name = \"leelee\", typed = \"lleeelee\" Output: true Example 4: Input: name = \"laiden\", typed = \"laiden\" Output: true Explanation: It's not necessary to long press any character. Note: name.length typed.length The characters of name and typed are lowercase letters. Difficulty:Easy Category:Two-Points, String Analyze 这道题目使用两个指针分别定位name和typed，当左边和右边不相等的时候，判断是否和上一位相等，如果和name的上一位相等，那么指针l就向右移动一位。 Solution // Solution: Two Points // Runtimes: 4ms class Solution { public: bool isLongPressedName(string name, string typed) { int l = 0, r = 0; char prev; while (l Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-387-First-Unique-Character-In-A-String.html":{"url":"Leetcode-387-First-Unique-Character-In-A-String.html","title":"First Unique Character In A String","keywords":"","body":"Question Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1. Examples: s = \"leetcode\" return 0. s = \"loveleetcode\", return 2. Note: You may assume the string contain only lowercase letters. Solution class Solution { public: int firstUniqChar(string s) { std::vector string_set(128); for(int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-884-Uncommon-Words-from-Two-Sentences.html":{"url":"Leetcode-884-Uncommon-Words-from-Two-Sentences.html","title":"Uncommon Words from Two Sentences","keywords":"","body":"Question We are given two sentences A and B. (A sentence is a string of space separated words. Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words. You may return the list in any order. Example 1: Input: A = \"this apple is sweet\", B = \"this apple is sour\" Output: [\"sweet\",\"sour\"] Example 2: Input: A = \"apple apple\", B = \"banana\" Output: [\"banana\"] Note: 0 0 A and B both contain only spaces and lowercase letters. Difficulty:Medium Category:Hash-Table Analyze 这道题目要求求解在两个string的句子里面，只出现过一次的单词，將两个string里面的单词全部放在unordered_map中统计各个单词的数量，然后输出只出现了一次的单词即可。 Solution // Runtime: 4ms class Solution { public: vector uncommonFromSentences(string A, string B) { vector ans; unordered_map rec; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-830-Positions-of-Large-Groups.html":{"url":"Leetcode-830-Positions-of-Large-Groups.html","title":"Positions of Large Groups(LC.830)","keywords":"","body":"Question In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = \"abbxxxxzyy\" has the groups \"a\", \"bb\", \"xxxx\", \"z\" and \"yy\". Call a group large if it has 3 or more characters. We would like the starting and ending positions of every large group. The final answer should be in lexicographic order. Example 1: Input: \"abbxxxxzzy\" Output: [[3,6]] Explanation: \"xxxx\" is the single large group with starting 3 and ending positions 6. Example 2: Input: \"abc\" Output: [] Explanation: We have \"a\",\"b\" and \"c\" but no large group. Example 3: Input: \"abcdddeeeeaabbbcd\" Output: [[3,5],[6,9],[12,14]] Difficulty:Easy Category:Array Solution class Solution { public: vector> largeGroupPositions(string S) { int left = 0, right = 0, len = S.length(); vector> res; while (right = 3) res.push_back({left, right - 1}); left = right; } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-792-Number-of-Matching-Subsequences.html":{"url":"Leetcode-792-Number-of-Matching-Subsequences.html","title":"Number of Matching Subsequences(LC.792)","keywords":"","body":"Question Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S. Example : Input: S = \"abcde\" words = [\"a\", \"bb\", \"acd\", \"ace\"] Output: 3 Explanation: There are three words in words that are a subsequence of S: \"a\", \"acd\", \"ace\". Note: All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000]. The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50]. Difficulty:Medium Category:String, HashTable Analyze 给你一些单词和一个字符串,判断哪些单词是这个字符串的子序列. Solution Solution 1: Brute Force class Solution { public: int numMatchingSubseq(string S, vector& words) { int ans = 0; unordered_map m; for (const string& word : words) { auto it = m.find(word); if (it == m.end()) { // Not found; bool match = isMatch(word, S); m[word] = match; ans += m[word]; } else { ans += it->second; } } return ans; } private: bool isMatch(const string& word, string& s) { int left = 0; for (const char c : word) { bool found = false; for (int i = left; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-524-Longest-Word-in-Dictionary-through-Deleting.html":{"url":"Leetcode-524-Longest-Word-in-Dictionary-through-Deleting.html","title":"Longest Word in Dictionary through Deleting(LC.524)","keywords":"","body":"Question Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. Example 1: Input: s = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"] Output: \"apple\" Example 2: Input: s = \"abpcplea\", d = [\"a\",\"b\",\"c\"] Output: \"a\" Note: All the strings in the input will only contain lower-case letters. The size of the dictionary won't exceed 1,000. The length of all the strings in the input won't exceed 1,000. Difficulty:Medium Category:String Analyze 这道题的输入是一个字符串以及一个包含了很多字符串的字典，要求在字典中找出最长的单词，对这个最长的单词的要求是: 这个单词中的每一的字母都在前面的字符串里面出现过，并且出现的顺序不能颠倒）如果找到几个字符串的长度是一样的，那么就选择最小的字符串。 代码结构： class Solution { public: string findLongestWord(string s, vector& d) { string res= \"\"; 返回值 for (string d_str : d) { //1.遍历字典中每个字符串 2。验证这个字符串在不再s中依次出现 if(d_str在s中依次出现过 && d_str的长度大于或者等于返回值) { if(d_str.size() > res.size() || d_str 步骤： 遍历字典中的单词，验证当前单词是否能由字符串s通过删除字符来得到 如果能得到，而且单词长度大于等于结果res的长度，我们再看是否需要更新结果res 两种情况是必须要更新结果res的 一个是当前单词长度大于结果res的长度 另一种是当前单词长度和res相同，但是字母顺序小于结果res，这两种情况下更新结果res即可. Solution class Solution { public: string findLongestWord(string s, vector& d) { string res = \"\"; for (string d_str : d) { int m = 0; for (int i = 0; i = res.size() ) { if( d_str.size() > res.size() || d_str Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-937-Reorder-Log-Files.html":{"url":"Leetcode-937-Reorder-Log-Files.html","title":"Reorder Log Files(LC.937)","keywords":"","body":"Question You have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs. It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order. Return the final order of the logs. Example 1: Input: [\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"] Output: [\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"] Note: 0 3 logs[i] is guaranteed to have an identifier, and a word after the identifier. Difficulty:Easy Category: Analyze 给若干行，每一行是以一个identifier开头，后面跟着以空格分隔的若干字符串，除了identifier外，一行中要不全是字母组成的字符串，要不全是数字。要求将所有“字母行”放到最上边，而且要排好序，排序的原则是除identifier外，一行与另一行进行字母序比较。若相同，则再比较identifier；而“数字行”则维持原来的先后顺序。 Log的格式是第一个单词是Log的索引，后面的都是Log的内容。有两种Log，一种内容是纯数字的，一种内容是纯英文字符的。现在要求，把所有的英文Log放到数字Log前面。而且如果是纯英文的字符Log，需要按照内容对Log进行排序，当内容相同的时候按照索引排序；如果是数字Log，保持原来的顺序。 Solution bool myCompare(string a, string b) { int i = a.find(' '); int j = b.find(' '); if (!isdigit(a[i + 1]) && !isdigit(b[j + 1])) return a.substr(i + 1) reorderLogFiles(vector& logs) { stable_sort(logs.begin(), logs.end(), myCompare); return logs; } }; Solution: Partition + Sort partition the array such that all digit logs are after all letter logs sort the letter logs part based on the log content Time complexity: O(n + aloga) Space complexity: O(n) class Solution { public: vector reorderLogFiles(vector& logs) { auto alpha_end = std::stable_partition(begin(logs), end(logs), [](const string& log){ return isalpha(log.back()); }); std::sort(begin(logs), alpha_end, [](const string& a, const string& b){ return a.substr(a.find(' ')) Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-824-Goat-Latin.html":{"url":"Leetcode-824-Goat-Latin.html","title":"Goat Latin(LC.824)","keywords":"","body":"Question A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append \"ma\" to the end of the word. For example, the word 'apple' becomes 'applema'. If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add \"ma\". For example, the word \"goat\" becomes \"oatgma\". Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1. For example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end and so on. Return the final sentence representing the conversion from S to Goat Latin. Example 1: Input: \"I speak Goat Latin\" Output: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\" Example 2: Input: \"The quick brown fox jumped over the lazy dog\" Output: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\" Analyze The input are a lots of strings. As a result, we need to convert thesr string to Goat Latin. So, we need to deal with each one string in the input. If the first letter is not vowel(aeiouAEIOU), then we need to move the first letter to the last one. We need add ma after the string. We need add the index number of a for the word in the string at the end of the word. Solution class Solution { public: string toGoatLatin(string S) { const string vowel = \"aeiouAEIOU\"; string res, word; istringstream stream(S); int index = 0; while(stream >> word){ if( vowel.find(word[0]) == std::string::npos ){ word = word.substr(1) + word[0]; } index ++; res += \" \"+ word + \"ma\" + string (index, 'a'); } return res.substr(1); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-76-Minimum-Window-Substring.html":{"url":"Leetcode-76-Minimum-Window-Substring.html","title":"Minimum Window Substring(LC.76)","keywords":"","body":"Question Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\". If there is such window, you are guaranteed that there will always be only one unique minimum window in S. Difficulty:Medium Category:Hard Solution class Solution { public: string minWindow(string s, string t) { vector r(128, 0); string ans; for (char& c : t) ++r[c]; int left = 0, cnt = 0, n = t.length(), diff = INT_MAX; for (int right = 0; right = 0) cnt++; while (cnt == n) { if (diff > right - left + 1) { diff = right - left + 1; ans = s.substr(left, diff); } if (++r[s[left]] > 0) --cnt; ++left; } } return ans; } }; Relative Questions Leetcode 632. Smallest Range Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-727-Minimum-Window-Subsequence.html":{"url":"Leetcode-727-Minimum-Window-Subsequence.html","title":"Minimum Window Subsequence(LC.727)","keywords":"","body":"Leetcode 727. Minimum Window Subsequence Given strings S and T, find the minimum (contiguous) substring W of S, so that T is a subsequence of W. If there is no such window in S that covers all characters in T, return the empty string \"\". If there are multiple such minimum-length windows, return the one with the left-most starting index. Example 1: Input: S = \"abcdebdde\", T = \"bde\" Output: \"bcde\" Explanation: \"bcde\" is the answer because it occurs before \"bdde\" which has the same length. \"deb\" is not a smaller window because the elements of T in the window must occur in order. Note: All the strings in the input will only contain lowercase letters. The length of S will be in the range [1, 20000]. The length of T will be in the range [1, 100]. Difficulty:Medium Category: Solution Solution 1: DP 该方案来源于博客： Minimum Window Subsequence 最小窗口序列 字符串且还是Hard的题，十有八九都是要用动态规划Dynamic Programming来做的，那么就直接往DP上去想吧. DP的第一步就是设计dp数组，像这种两个字符串的题，一般都是一个二维数组，想想该怎么定义。确定一个子串的两个关键要素是起始位置和长度，那么我们的dp值到底应该是定起始位置还是长度呢？That is a question! 仔细想一想，其实起始位置是长度的基础，因为我们一旦知道了起始位置，那么当前位置减去起始位置，就是长度了，所以我们dp值定为起始位置。那么 dp[i][j] 表示范围 S 中前 i 个字符包含范围 T 中前 j 个字符的子串的起始位置，注意这里的包含是子序列包含关系。然后就是确定长度了，有时候会使用字符串的原长度，有时候会多加1，看个人习惯吧，这里博主长度多加了个1。 class Solution { public: string minWindow(string S, string T) { int m = S.size(), n = T.size(), start = -1, minLen = INT_MAX; vector> dp(m + 1, vector(n + 1, -1)); for (int i = 0; i len) { minLen = len; start = dp[i][n]; } } } return (start != -1) ? S.substr(start, minLen) : \"\"; } }; Solution 2: Two Points class Solution { public: string minWindow(string S, string T) { int m = S.size(), n = T.size(), start = -1, minLen = INT_MAX, i = 0, j = 0; while (i = 0) { while (S[i--] != T[j]) ; } ++i; ++j; if (end - i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-844-Backspace-String-Compare.html":{"url":"Leetcode-844-Backspace-String-Compare.html","title":"Backspace String Compare(LC.844)","keywords":"","body":"Question Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character. Example 1: Input: S = \"ab#c\", T = \"ad#c\" Output: true Explanation: Both S and T become \"ac\". Example 2: Input: S = \"ab##\", T = \"c#d#\" Output: true Explanation: Both S and T become \"\". Example 3: Input: S = \"a##c\", T = \"#a#c\" Output: true Explanation: Both S and T become \"c\". Example 4: Input: S = \"a#c\", T = \"b\" Output: false Explanation: S becomes \"c\" while T becomes \"b\". Note: 1 1 S and T only contain lowercase letters and '#' characters. Follow up: Can you solve it in O(N) time and O(1) space? Difficulty:Easy Category: Solution class Solution { public: bool backspaceCompare(string S, string T) { stack l, r; for (char& c : S) { if (c >= 'a' && c = 'a' && c Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-763-Partition-Labels.html":{"url":"Leetcode-763-Partition-Labels.html","title":"Partition Labels(LC.763)","keywords":"","body":"Question A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts. Example 1: Input: S = \"ababcbacadefegdehijhklij\" Output: [9,7,8] Explanation: The partition is \"ababcbaca\", \"defegde\", \"hijhklij\". This is a partition so that each letter appears in at most one part. A partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits S into less parts. Note: S will have length in range [1, 500]. S will consist of lowercase letters ('a' to 'z') only. Difficulty:Medium Category:Two-Points, Greedy Analyze 分析参考博客: 花花酱 LeetCode 763. Partition Labels Solution Solution 1: Brute Force Time complexity: O(n^2), Space complexity: O(1) class Solution { public: vector partitionLabels(string S) { vector ans; size_t start = 0, end = 0; for (size_t i = 0; i Solution 2: Greedy Time complexity: O(n), Space complexity: O(26/128) class Solution { public: vector partitionLabels(string S) { vector last_index(128, 0); for (int i = 0; i ans; int start = 0, end = 0; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-49-Group-Anagrams.html":{"url":"Leetcode-49-Group-Anagrams.html","title":"Group Anagrams(LC.49)","keywords":"","body":"Question Given an array of strings, group anagrams together. Example: Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Output: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] Note: All inputs will be in lowercase. The order of your output does not matter. Difficulty:Easy Category:Hash-Table, String Solution class Solution { public: vector> groupAnagrams(vector& strs) { unordered_map> rec; for (string& s : strs) { string temp = s; sort(temp.begin(), temp.end()); rec[temp].push_back(s); } vector> ans; for (auto& m : rec) ans.emplace_back(m.second); return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-521-Longest-Uncommon-Subsequence-I.html":{"url":"Leetcode-521-Longest-Uncommon-Subsequence-I.html","title":"Longest Uncommon Subsequence I","keywords":"","body":"Question Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1. Example 1: Input: \"aba\", \"cdc\" Output: 3 Explanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings. Note: Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings. Analyze There question is so easy. We just choose the longgest one as longest uncommon subsequence of other strings in the group of two strings. Solution class Solution { public: int findLUSlength(string a, string b) { return a == b ? -1 : max(a.size(), b.size()); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-522-Longest-Uncommon-Subsequence-II.html":{"url":"Leetcode-522-Longest-Uncommon-Subsequence-II.html","title":"Longest Uncommon Subsequence II","keywords":"","body":"Question Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1. Example 1: Input: \"aba\", \"cdc\", \"eae\" Output: 3 Note: All the given strings' lengths will not exceed 10. The length of the given list will be in the range of [2, 50]. Analyze Solution class Solution { public: int findLUSlength(vector& strs) { int res = -1, len = strs.size(); int j = 0; // 1. Choose each one from the res for(int i =0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-383-Ransom-Note.html":{"url":"Leetcode-383-Ransom-Note.html","title":"Ransom Note","keywords":"","body":"Question Given an arbitrary ransom(任意的赎金) note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note:You may assume that both strings contain only lowercase letters. canConstruct(\"a\", \"b\") -> false canConstruct(\"aa\", \"ab\") -> false canConstruct(\"aa\", \"aab\") -> true Analyze 这道题目使用两个string(string ransomNote, string magazine)作为输入，如果第二个string里面包含第一个string，那么就返回true, 如果不是那么就返回来false. 使用hashmap存入所有的string magazine里面的每一个char 然后再扫描string ransomNote里面的每一个char，在存在的hashmap里面去查找是否有这一个字符，如果有，那么就把这个字符自减一，如果没有，那么放回false Solution class Solution { public: bool canConstruct(string ransomNote, string magazine) { std::unordered_map data_set; for(char c : magazine) ++data_set[c]; for(char c : ransomNote) { if( data_set.count(c) ) --data_set[c]; else { return false; } if(data_set[c] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-804-Unique-Morse-Code-Words.html":{"url":"Leetcode-804-Unique-Morse-Code-Words.html","title":"Unique Morse Code Words","keywords":"","body":"Question International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: \"a\"maps to \".-\", \"b\" maps to \"-...\", \"c\" maps to \"-.-.\", and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = [\"gin\", \"zen\", \"gig\", \"msg\"] Output: 2 Explanation: The transformation of each word is: \"gin\" -> \"--...-.\" \"zen\" -> \"--...-.\" \"gig\" -> \"--...--.\" \"msg\" -> \"--...--.\" There are 2 different transformations, \"--...-.\" and \"--...--.\". Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. Solution class Solution { public: int uniqueMorseRepresentations(vector& words) { std::string name[26]={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; std::unordered_set myset; for (vector::iterator it = words.begin(); it != words.end(); ++it) { std::string tmp = \"\"; for (char c : *it ) { tmp += name[ c- 'a']; } myset.insert (tmp); } return myset.size(); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-Interview-Amazon-OA2-Maximum-Minimum-Path.html":{"url":"Leetcode-Interview-Amazon-OA2-Maximum-Minimum-Path.html","title":"Maximum Minimum Path(Interview)","keywords":"","body":"Maximum Minimum Path 计算到目标位置的最小路径里面的(最左上角-->最右下角)，最大的那一个最小值。 给一个n*m矩阵，元素表示在该点的高度。从矩阵左上角开始爬山，爬到右下角。会有许多最短路径（长度都是n+m-2），这些路径都会有各自的最低海拔min_i，求这些min_i的最大值 Solution Solution 1: DP 这道题目的 C++ 代码来自于 Leetcode 174. Dungeon Game question. Time complexity: O(mn) Space complexity: O(n) int helper(vector>& matrix) { int n = matrix.size(); vector res(n, 0); res[0] = matrix[0][0]; for (int i = 1; i Solution 2: DFS public class MaximumMinimumPath { private int min, max, row, col; public int maxMinPath(int[][] matrix) { row = matrix.length; col = matrix[0].length; min = Integer.MAX_VALUE; max = Integer.MIN_VALUE; dfsHelper(matrix, min, 0, 0); return max; } public void dfsHelper(int[][] matrix, int min, int i, int j ){ if (i >= row || j >= col) return; if (i == row - 1 && j == col - 1) { min = Math.min(min, matrix[i][j]); max = Math.max(max, min); return; } min = Math.min(min, matrix[i][j]); dfsHelper(matrix, min, i, j + 1); dfsHelper(matrix, min, i + 1, j); } } Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:19 "},"Leetcode-819-Most-Common-Word.html":{"url":"Leetcode-819-Most-Common-Word.html","title":"Most Common Word","keywords":"","body":"Leetcode 819. Most Common Words Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn't banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase. Example: Input: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\" banned = [\"hit\"] Output: \"ball\" Explanation:s \"hit\" occurs 3 times, but it is a banned word. \"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as \"ball,\"), and that \"hit\" isn't the answer even though it occurs more because it is banned. Note: 1 . 1 . 1 . The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols. Analyze 这一道题目只需要排查被禁止的词汇,找到里面重复最高频率的词汇就可以了，处理方式如下： 在string paragraph里面找到特殊的符号，将这一些特殊的符号全部是使用空格代替，为之后更容易的分割输入做准备 使用istringstream stream(paragraph)将输入全部转换成以空格分割的输入单词word. 将每个不在禁止字符串数组里面的单词都插入到一个unordered_map，如果原来unordered_map里面没有的话，那么就存有1，如果原来里面就已经有数据了，那么就取出来对应的数据，将其加一 最后遍历unordered_map，找到currentMax = it->second; arg_max = it->first;最大的位置，然后返回。 Solution Solution 1: istringstream class Solution { public: string mostCommonWord(string paragraph, vector& banned) { const string symbols = \"!?',;.\"; std::unordered_set bannedset; std::unordered_map stringMap; string word, arg_max; unsigned currentMax = 0; for (string s : banned) bannedset.emplace(s); for (auto it = paragraph.begin(); it != paragraph.end();) { if (symbols.find(*it) != std::string::npos) { *it = ' '; } else { *it = tolower(*it); ++it; } } istringstream stream(paragraph); while (stream >> word) { if (bannedset.find(word) == bannedset.end()) { auto search = stringMap.find(word); if (search == stringMap.end()) { stringMap.insert(std::make_pair(word, 1)); } else { stringMap[word] = search->second + 1; } } } for (auto it = stringMap.begin(); it != stringMap.end(); ++it) { if (it->second > currentMax) { arg_max = it->first; currentMax = it->second; } } return arg_max; } }; Solution 2: Hashtable 使用一个set来保存需要屏蔽的词汇， 然后使用Ｈashmap统计每个单词出现的频率，如果这个单词在屏蔽名单里面出现过， 那么就不使用这个单词来计算最高的频率。分为3步： 遍历句子，将标点符号替换为空格，将大写字母转换为小写字母O（n=字符串“句子”长度） for (auto & c: p) c = isalpha(c) ? tolower(c) : ' '; 用一个unordered_set来记录“黑名单”, O（m=字符串“黑名单”长度） 遍历句子中的字符串，用unordered_map来记录各字符串出现的次数，同时需要检查是否在“黑名单”中。同时记录最高频词汇的pair, O（n） 第三步中，句子用stringstream来分割空格, 时间复杂度为O（m+n） Hashtable class Solution { public: string mostCommonWord(string paragraph, vector& banned) { // Record the banned words set unordered_set b(banned.begin(), banned.end()); unordered_map counts; const string pattern = \"!?',;. \"; int best = 0; string ans; const int n = paragraph.size(); string word; for (int i = 0; i best && !b.count(word) && word.size() > 0) { best = counts[word]; ans = word; } word.clear(); } else { word += tolower(paragraph[i]); } } return ans; } }; Follow up 如果需要返回的是几个出现最高频率的单词，应该怎么做。 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-2-Add-Two-Numbers.html":{"url":"Leetcode-2-Add-Two-Numbers.html","title":"Add Two Numbers","keywords":"","body":"Question You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Difficulty:Medium Category:Linked List, Math Solution class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode preHead(0), *p = &preHead; int carry = 0; while (l1 || l2 || carry) { int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry; carry = sum / 10; p->next = new ListNode(sum % 10); p = p->next; l1 = l1 ? l1->next : nullptr; l2 = l2 ? l2->next : nullptr; } return preHead.next; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-83-Remove-Duplicates-From-Sorted-List.html":{"url":"Leetcode-83-Remove-Duplicates-From-Sorted-List.html","title":"Remove Duplicates From Sorted List","keywords":"","body":"Question Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1->1->2 Output: 1->2 Example 2: Input: 1->1->2->3->3 Output: 1->2->3 Difficulty:Easy Category:Linked List Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (!head) return head; ListNode* prev = head; ListNode* cur = head->next; while (cur) { if (prev->val == cur->val) { prev->next = cur->next; } else { prev = cur; } cur = cur->next; } return head; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-82-Remove-Duplicates-From-Sorted-List-II.html":{"url":"Leetcode-82-Remove-Duplicates-From-Sorted-List-II.html","title":"Remove Duplicates From Sorted List II","keywords":"","body":"Question Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5 Example 2: Input: 1->1->1->2->3 Output: 2->3 Difficulty:Medium Category:Linked List Analyze 这道题目要求的是删除所有的重复项，由于链表开头可能会有重复项，被删掉的头指针会改变，而最终却还需要返回链表的头指针。所以需要定义一个新的节点，然后链上原链表，然后定义一个前驱指针和一个现指针，每当前驱指针指向新建的节点，现指针从下一个位置开始往下遍历，遇到相同的则继续往下，直到遇到不同项时，把前驱指针的next指向下面那个不同的元素。如果现指针遍历的第一个元素就不相同，则把前驱指针向下移一位 Solution Solution 1: No-Recursive class Solution { public: ListNode *deleteDuplicates(ListNode *head) { if (!head || !head->next) return head; ListNode *dummy = new ListNode(-1), *pre = dummy; dummy->next = head; while (pre->next) { ListNode *cur = pre->next; while (cur->next && cur->next->val == cur->val) { cur = cur->next; } if (cur != pre->next) pre->next = cur->next; else pre = pre->next; } return dummy->next; } }; Solution2: Recursive class Solution { public: ListNode *deleteDuplicates(ListNode *head) { if (!head) return head; if (head->next && head->val == head->next->val) { while (head->next && head->val == head->next->val) { head = head->next; } return deleteDuplicates(head->next); } head->next = deleteDuplicates(head->next); return head; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-19-Remove-Nth-Node-From-End-Of-List.html":{"url":"Leetcode-19-Remove-Nth-Node-From-End-Of-List.html","title":"Remove Nth Node From End Of List","keywords":"","body":"Question Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. Note: Given n will always be valid. Follow up: Could you do this in one pass? Difficulty:Medium Category:Two Points Solution class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *slow = head, *fast = head; while (fast && n--) fast = fast->next; if (!fast) return head->next; while (fast->next) { fast = fast->next; slow = slow->next; } slow->next = slow->next->next; return head; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-23-Merge-K-Sorted-Lists.html":{"url":"Leetcode-23-Merge-K-Sorted-Lists.html","title":"Merge K Sorted Lists","keywords":"","body":"Leetcode 23. Merge k Sorted Lists Difficulty:Hard Category:Linked-List, Divide-and-Conquer, Heap Analyze 我们在前面做过类似的合并两个Sorted List的题目, 在这里, 我们先考虑两两合并Lists, 这就是我们的Solution 1,依次两两合并List, 最终得到一个合并之后完整的List. 参考另外一道题目: Merge Two Sorted Lists 这种方式性能很不好,因为左边的List可能长度很长,而右边的Lists则长度很短,这就会使得每次计算的时间复杂度很高. 针对处理N个类似工作的过程,我们考虑使用分治法, 不停的对n个链表进行二分n/2, n/4, n/8..., 直到最后的元素个数为1或2个为止. 然后再向上进行合并. Solution Solution 1: Brute Force, Merge two list each time Time complexity: O(nk) Space complexity: O(1) // Runtime: 300ms class Solution { public: ListNode* mergeKLists(vector& lists) { if (lists.empty()) return nullptr; ListNode* p = lists[0]; for (int i = 1; i val val) { p->next = l1; l1 = l1->next; } else { p->next = l2; l2 = l2->next; } p = p->next; } p->next = l1 ? l1 : l2; return dump.next; } }; Solution 2: Divide and Conquer // Runtime: 16ms class Solution { public: ListNode* mergeKLists(vector& lists) { if (lists.empty()) return nullptr; int n = lists.size(); while (n > 1) { int k = (n + 1) / 2; for (int i = 0; i val val) { p->next = l1; l1 = l1->next; } else { p->next = l2; l2 = l2->next; } p = p->next; } p->next = l1 ? l1 : l2; return dump.next; } }; Solution 3: priority_queue 这种方案来自于博客:Merge k Sorted Lists 合并k个有序链表, 使用最小堆的结构,我们可以將k个链表的首元素加入到最小堆当中,最小堆能够自动排好序,然后我们取出来最小的元素, 然后把取出元素的链表的下一个元素继续放入最小堆当中,循环操作,直到合并完所有链表为止, 返回首元素就好. Time complexity: O(nlogk) Space complexity: O(k) struct cmp { bool operator()(ListNode* a, ListNode* b) { return a->val > b->val; } }; class Solution { public: ListNode* mergeKLists(vector& lists) { priority_queue, cmp> q; for (auto& list : lists) if (list) q.push(list); ListNode *head = nullptr, *cur = nullptr, *tmp = nullptr; while (!q.empty()) { tmp = q.top(); q.pop(); // Save the ListNode* in the list cur ? cur->next = tmp : head = tmp; cur = tmp; if (tmp->next) q.push(tmp->next); } return head; } }; Updated 1/29/2019 Add the solution 2 and solution 3 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-148-Sort-List.html":{"url":"Leetcode-148-Sort-List.html","title":"Sort List","keywords":"","body":"Question Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4 Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5 Difficulty:Medium Category:Linked-List, Sort Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { if (head == nullptr || head->next == nullptr) return head; ListNode *slow = head, *fast = head; while (fast->next != nullptr && fast->next->next != nullptr) { slow = slow->next; fast = fast->next->next; } fast = slow; slow = slow->next; fast->next = nullptr; return mergeTwoLists(sortList(head), sortList(slow)); } ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *mergelist = new ListNode(-1), *cur = mergelist; while (l1 && l2) { if (l1->val val) { cur->next = l1; l1 = l1->next; } else { cur->next = l2; l2 = l2->next; } cur = cur->next; } cur->next = l1 ? l1 : l2; return mergelist->next; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-24-Swap-Nodes-In-Pairs.html":{"url":"Leetcode-24-Swap-Nodes-In-Pairs.html","title":"Swap Nodes In Pairs","keywords":"","body":"Question Given a linked list, swap every two adjacent nodes and return its head. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. Note: Your algorithm should use only constant extra space. You may not modify the values in the list's nodes, only nodes itself may be changed. Difficulty:Medium Category:Linked List Solution class Solution { public: ListNode* swapPairs(ListNode* head) { if (head == nullptr || head->next == nullptr) return head; ListNode dummy(-1); dummy.next = head; ListNode *left = &dummy, *cur = left->next, *right = cur->next; while (right) { left->next = right; cur->next = right->next; right->next = cur; left = cur; cur = cur->next; if (cur != nullptr && cur->next != nullptr) right = cur->next; else right = nullptr; } return dummy.next; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-206-Reverse-Linked-List.html":{"url":"Leetcode-206-Reverse-Linked-List.html","title":"Reverse Linked List","keywords":"","body":"Question Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL Difficulty:Easy Category:Linked List Solution Tracking prev / curr / next node Time complexity: O(n) Space complexity: O(1) class Solution { public: ListNode* reverseList(ListNode* head) { ListNode *prev = nullptr, *cur = head, *next = nullptr; while (cur) { next = cur->next; cur->next = prev; prev = cur; cur = next; } return prev; } }; Solution 2: recursive class Solution { public: ListNode* reverseList(ListNode* head) { if (!head || !head->next) return head; ListNode* last = head->next; ListNode* right = reverseList(head->next); last->next = head; head->next = nullptr; return right; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-92-Reverse-Linked-List-II.html":{"url":"Leetcode-92-Reverse-Linked-List-II.html","title":"Reverse Linked List II","keywords":"","body":"Question Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL Difficulty:Medium Category:Linked List Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode dummy(-1); dummy.next = head; ListNode* prev = &dummy; for (int i = 0; i next; } ListNode* const start = prev; prev = start->next; ListNode* cur = prev->next; for (int i = m; i next = cur->next; cur->next = start->next; start->next = cur; cur = prev->next; } return dummy.next; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-25-Reverse-Nodes-In-K-Group.html":{"url":"Leetcode-25-Reverse-Nodes-In-K-Group.html","title":"Reverse Nodes In K Group","keywords":"","body":"Question Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 Note: Only constant extra memory is allowed. You may not alter the values in the list's nodes, only nodes itself may be changed. Difficulty:Hard Category:Linked List Solution Soulution 1：错误的解决方案，理解错误题目含义，以为是翻转前面n个节点 class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if (head == nullptr || head->next == nullptr) return head; ListNode dummy(-1); dummy.next = head; ListNode *start = &dummy, *prev = start->next, *cur = prev->next; int count = 0; while (cur && count next = cur->next; cur->next = start->next; start->next = cur; count++; cur = prev->next; } return dummy.next; } }; Soulution 2：递归 class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if (head == nullptr || head->next == nullptr || k next, *cur = prev->next; ListNode* p = prev; int len = 0; while (p) { len++; p = p->next; } if (k > len) return head; std::cout next = cur->next; cur->next = start->next; start->next = cur; count++; cur = prev->next; if (count % k == 0) { count++; if (count + k > len + 1) return dummy.next; start = prev; if (prev->next != nullptr) { prev = prev->next; cur = prev->next; } } } return dummy.next; } }; 优化一下代码： class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if (head == nullptr || head->next == nullptr || k next, *cur = prev->next; ListNode *p = prev; // Get the len of the List while (p) { len++; p = p->next; } if (k > len) return head; int count = 1; while (cur) { prev->next = cur->next; cur->next = start->next; start->next = cur; count++; cur = prev->next; if(count % k == 0) { count++; if (count + k > len+1) return dummy.next; start = prev; if (prev->next != nullptr) { prev = prev->next; cur = prev->next; } } } return dummy.next; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-117-Populating-Next-Right-Pointers-In-Each-Node-II.html":{"url":"Leetcode-117-Populating-Next-Right-Pointers-In-Each-Node-II.html","title":"Populating Next Right Pointers In Each Node II","keywords":"","body":"Question Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. Example: Given the following binary tree, Difficulty:Medium Category:Tree, Depth-First-Search Solution /** * Definition for binary tree with next pointer. * struct TreeLinkNode { * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */ class Solution { public: void connect(TreeLinkNode *root) { while (root) { TreeLinkNode *next = nullptr, *prev = nullptr; // Loop in the same level for (; root; root = root->next) { // The first one --> to find the next level if (!next) next = root->left ? root->left : root->right; if (root->left) { if (prev) prev->next = root->left; prev = root->left; } if (root->right) { if (prev) prev->next = root->right; prev = root->right; } } root = next; // Next Level } } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-160-Intersection-of-Two-Linked-Lists.html":{"url":"Leetcode-160-Intersection-of-Two-Linked-Lists.html","title":"Intersection of Two Linked Lists","keywords":"","body":"Question Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. Example 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2: Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Reference of the node with value = 2 Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3: Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: null Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. Difficulty:Easy Category:Linked-List Solution class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *a = headA, *b = headB; while (a != b) { a = a ? a->next : headB; b = b ? b->next : headA; } return a; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-141-Linked-List-Cycle.html":{"url":"Leetcode-141-Linked-List-Cycle.html","title":"Linked List Cycle","keywords":"","body":"Question Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? Difficulty:Easy Category:Linked List, Two Points Analyze 虽然我刷题不够多，但是还是知道这个经典的检查链表中是否有环的快慢指针方式。设置两个指针，一个快一个慢，快的指针一次走两格，慢的指针一次走一格。 为什么如果有环的话，快的指针一定可以追上慢的指针呢, 难道不会刚好错过么 快的指针一次走两格，慢的指针一次走一格，他们的相对速度只差是1个格子，那我们这样分析。如果链表中间有环，那么快的在追到慢的之前的话，他们之间之可能相差一个格子或者两个格子： 如果他们相差一个格子，那么下一步就能够追上 如果他们相差两个格子，那么两步之后也可以追上。 Solution class Solution { public: bool hasCycle(ListNode* head) { ListNode *slow = head, *fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; if (fast == slow) return true; } return false; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-142-Linked-List-Cycle-II.html":{"url":"Leetcode-142-Linked-List-Cycle-II.html","title":"Linked List Cycle II","keywords":"","body":"Question Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up:Can you solve it without using extra space? Difficulty:Medium Category:Linked List, Two Points Analyze 这道题目，感觉更多的是考虑数学公式的推导的样子，如果是一个环，可以得到下面这个图形： 图片来自于博客: [算法][LeetCode]Linked List Cycle & Linked List Cycle II——单链表中的环 先对图中符号做下面的定义： X是链表头 Y是环的第一个节点，也就是环的起点 'Z'是快慢节点的相遇位置 环的长度是r = c + b slow指针走过的距离是 s = a + b fast指针走过的距离是 2s = a + n(c+b) + b 相遇的时候fast指针在环里面已经走了n圈了 根据上面的图形，得到下面的推导： 2s = a + n(c+b) + b 2(a+b) = a + n(c+b) + b a+b = n(c+b) a = n(c+b) - b = （n-1)×（c+b） + c = (n-1)*r + c 所以如果在相遇的时候，重新定义一个slow2的慢指针，每次走一步，那么他们一定可以在环的起点位置相遇的。 Solution class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast != nullptr && fast->next != nullptr) { slow = slow->next; fast = fast->next->next; if (slow == fast) { ListNode *slow2 = head; while (slow2 != slow) { slow2 = slow2->next; slow = slow->next; } return slow2; } } return nullptr; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-234-Palindrome-Linked-List.html":{"url":"Leetcode-234-Palindrome-Linked-List.html","title":"Palindrome Linked List","keywords":"","body":"Question Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up:Could you do it in O(n) time and O(1) space? Difficulty:Easy Category:Linked-List, Two-Points Solution // Runtime: 1484ms class Solution { public: bool isPalindrome(ListNode* head) { int len = getlength(head); int left = 1, right = len; while (left val == getnthnode(head, right)->val) { left++; right--; } else return false; } return true; } private: int getlength(ListNode* node) { int n = 0; while (node) { ++n; node = node->next; } return n; } ListNode* getnthnode(ListNode* node, int n) { while (--n) node = node->next; return node; } }; Solution 2: // Runtime: 1484ms class Solution { public: bool isPalindrome(ListNode* head) { int len = getlength(head); vector rec; rec.reserve(len); while (head) { rec.emplace_back(head); head = head->next; } int left = 0, right = len - 1; while (left val != rec[right--]->val) return false; return true; } private: int getlength(ListNode* node) { int n = 0; while (node) { ++n; node = node->next; } return n; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-143-Reorder-List.html":{"url":"Leetcode-143-Reorder-List.html","title":"Reorder List","keywords":"","body":"Question Given a singly linked list L: L_0→_L_1→…→_L__n-1→L_n,reorder it to: _L_0→_L__n→L_1→_L__n-1→L_2→_L__n-2→… You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1->2->3->4, reorder it to 1->4->2->3. Example 2: Given 1->2->3->4->5, reorder it to 1->5->2->4->3. Difficulty:Medium Category:Linked List Analyze 利用快慢节点的方式，找到中间的节点，然后断开两个部分，然后将后面的链表翻转，在合并两个部分的单链表。 Solution class Solution { public: void reorderList(ListNode* head) { if (head == nullptr || head->next == nullptr) return; ListNode *slow = head, *fast = head, *left = head, *right = nullptr; while (fast && fast->next) { left = slow; slow = slow->next; fast = fast->next->next; } // Cut this list at the Middle. left->next = nullptr; right = reverse(slow); left = head; // Merged these two List; while (left->next) { ListNode* temp = left->next; left->next = right; right = right->next; left->next->next = temp; left = temp; } left->next = right; } // From Leetcode 206. Reverse Linked List ListNode* reverse(ListNode* head) { // Do something to reverse node if (!head) return head; ListNode dummy(-1); dummy.next = head; ListNode* const start = &dummy; ListNode* prev = head; ListNode* cur = head->next; while (cur) { prev->next = cur->next; cur->next = start->next; start->next = cur; cur = prev->next; } return dummy.next; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-147-Insertion-Sort-List.html":{"url":"Leetcode-147-Insertion-Sort-List.html","title":"Insertion Sort List","keywords":"","body":"Question Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list Algorithm of Insertion Sort:** Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Difficulty:Medium Category:Linked-List, Sort Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* insertionSortList(ListNode* head) { ListNode dummy(INT_MIN); for (ListNode* cur = head; cur != nullptr;) { auto pos = findInsertPos(&dummy, cur->val); ListNode* tmp = cur->next; cur->next = pos->next; pos->next = cur; cur = tmp; } return dummy.next; } ListNode* findInsertPos(ListNode* head, int x) { ListNode* prev = nullptr; for (ListNode* cur = head; cur != nullptr && cur->val next) { ; } return prev; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-599-Minimum-Index-Sum-of-Two-Lists.html":{"url":"Leetcode-599-Minimum-Index-Sum-of-Two-Lists.html","title":"Minimum Index Sum of Two Lists","keywords":"","body":"Question Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. Example 1: Input: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"] Output: [\"Shogun\"] Explanation: The only restaurant they both like is \"Shogun\". Example 2: Input: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"KFC\", \"Shogun\", \"Burger King\"] Output: [\"Shogun\"] Explanation: The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1). Note: The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists. Difficulty:Easy Category:Hash-Table Solution class Solution { public: vector findRestaurant(vector& list1, vector& list2) { vector ans; int index = INT_MAX; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-138-Copy-List-With-Random-Pointer.html":{"url":"Leetcode-138-Copy-List-With-Random-Pointer.html","title":"Copy List With Random Pointer","keywords":"","body":"Question A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Example 1: Input: {\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1} Explanation: Node 1's value is 1, both of its next and random pointer points to Node 2. Node 2's value is 2, its next pointer points to null and its random pointer points to itself. Note: You must return the copy of the given head as a reference to the cloned list. Difficulty:Medium Category:HashTable, Linked List Analyze 这道题目看上去是比较麻烦的，因为你不能够同时完成所有内容的Deep copy, 因为每个节点的random是不知道的，所以是不能够在第一次拷贝的时候就完全完成拷贝。可以分成下面几个步骤完成。 在当前节点中，拷贝一个节点包含了Next节点以及int label的数值，然后将这个节点添加到当前现在的list里面去，最后在将其分出来。 完成 rondom 节点内容的拷贝工作 分解两个List Solution Solution 1: Iterative Use the next pointer of each node to store its copy. Time complexity: O(1), Space complexity: O(1) class Solution { public: Node* copyRandomList(Node* head) { Node dummy(-1, nullptr, nullptr); Node* new_cur = &dummy; // Copy the Next node and val // Add it after the original node for (Node* cur = head; cur != nullptr;) { Node* node = new Node(cur->val, nullptr, nullptr); node->next = cur->next; cur->next = node; cur = node->next; } // Copy the random node for (Node* cur = head; cur != nullptr;) { // Copy the random node if (cur->random != nullptr) cur->next->random = cur->random->next; cur = cur->next->next; } for (Node* cur = head; cur != nullptr;) { new_cur->next = cur->next; new_cur = new_cur->next; cur->next = cur->next->next; cur = cur->next; } return dummy.next; } }; 另外一种写法： class Solution { public: Node* copyRandomList(Node* head) { if (!head) { return NULL; } copies[head] = new Node(head->val, NULL, NULL); Node* node = head; while (node) { Node *next = node->next, *random = node->random; if (next && copies.find(next) == copies.end()) { copies[next] = new Node(next->val, NULL, NULL); } if (random && copies.find(random) == copies.end()) { copies[random] = new Node(random->val, NULL, NULL); } copies[node]->next = next ? copies[next] : NULL; copies[node]->random = random ? copies[random] : NULL; node = next; } return copies[head]; } private: unordered_map copies; }; Solution 2: Recursive class Solution { public: Node* copyRandomList(Node* head) { if (!head) return nullptr; if (copies.find(head) == copies.end()) { copies[head] = new Node(head->val, NULL, NULL); copies[head]->next = copyRandomList(head->next); copies[head]->random = copyRandomList(head->random); } return copies[head]; } private: unordered_map copies; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-61-Rotate-List.html":{"url":"Leetcode-61-Rotate-List.html","title":"Rotate List","keywords":"","body":"Question Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL Difficulty:Medium Category:Linked List, Two Points Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if (!head || k == 0) return head; int len_list = 1; ListNode* p = head; while (p->next) { p = p->next; len_list++; } k = len_list - k % len_list; p->next = head; for (int step = 0; step next; } head = p->next; p->next = NULL; return head; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-86-Partition-List.html":{"url":"Leetcode-86-Partition-List.html","title":"Partition List","keywords":"","body":"Question Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5 Difficulty:Medium Category:Linked List, Two Pointers Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { ListNode left_dummy(-1); ListNode right_dummy(-1); auto left_cur = &left_dummy; auto right_cur = &right_dummy; for (ListNode* cur = head; cur; cur = cur->next) { if (cur->val next = cur; left_cur = left_cur->next; } else { right_cur->next = cur; right_cur = right_cur->next; } } left_cur->next = right_dummy.next; right_cur->next = NULL; return left_dummy.next; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-20-Valid-Parentheses.html":{"url":"Leetcode-20-Valid-Parentheses.html","title":"Valid Parentheses(LC.20)","keywords":"","body":"Question Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: \"()\" Output: true Example 2: Input: \"()[]{}\" Output: true Example 3: Input: \"(]\" Output: false Example 4: Input: \"([)]\" Output: false Example 5: Input: \"{[]}\" Output: true Difficulty:Easy Category:Stack, String Analyze 验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。在这里使用一个栈来实现, 如果扫描到的是左边的括号(,{,[, 那么就把其压入到栈中，之后如果扫描到的不是左边的符号的话，那么就把堆栈最上面的数据出栈，然后如果出栈的数据是对应的右括号的话，那么就pop 出栈这个数据，如果不是对应的有括号，那么就返回false. Solution class Solution { public: bool isValid(string s) { std::stack parentheses; for (int i = 0; i 换一种方式,判断是否满足全部也可以,但是这样时间复杂度是O(n) class Solution { public: bool isValid(string s) { stack s_; for (int i = 0; i Similar Questions Different Ways to Add Parentheses Longest Valid Parentheses Generate Parentheses updated 01/28/2019 Add the second Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-32-Longest-Valid-Parentheses.html":{"url":"Leetcode-32-Longest-Valid-Parentheses.html","title":"Longest Valid Parentheses(LC.32)","keywords":"","body":"Question Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\" Example 2: Input: \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\" Difficulty:Hard Category:Dynamic Programming, String Solution class Solution { public: int longestValidParentheses(string s) { int res = 0, left = 0; stack m; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-301-Remove-Invalid-Parentheses.html":{"url":"Leetcode-301-Remove-Invalid-Parentheses.html","title":"Remove Invalid Parentheses(LC.301)","keywords":"","body":"Question Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Example 1: Input: \"()())()\" Output: [\"()()()\", \"(())()\"] Example 2: Input: \"(a)())()\" Output: [\"(a)()()\", \"(a())()\"] Example 3: Input: \")(\" Output: [\"\"] Difficulty:Hard Category:DFS, BFS 题目大意：给你一个字符串，由”(” “)”和其他字符构成。让你删除数量最少的括号使得表达式合法（括号都匹配）。输出所有的合法表达式。 Solution Solution 1: DFS // Runtime: 8 ms, faster than 97.09% of C++ online submissions for Remove Invalid Parentheses. // Memory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Remove Invalid Parentheses. // Solution: DFS // Step 1. Count how many parentheses we need to remove // Step 2. dfs function --- Try to remove each parentheses. class Solution { public: vector removeInvalidParentheses(string s) { vector ans; int l_cnt = 0, r_cnt = 0; // l_cnt and r_cnt is the number \"()\" which we need to remove; for (char& c : s) { if (c == '(') ++l_cnt; else if (c == ')') l_cnt == 0 ? ++r_cnt : --l_cnt; } dfs(s, 0, l_cnt, r_cnt, ans); if (ans.empty()) ans.emplace_back(\"\"); return ans; } private: void dfs(string& s, int start, int l_cnt, int r_cnt, vector& ans) { if (l_cnt == 0 && r_cnt == 0) { if (isValidParentheses(s)) ans.emplace_back(s); return; } for (int i = start; i start && s[i] == s[i - 1]) continue; if (s[i] == '(' || s[i] == ')') { string cur = s; cur.erase(i, 1); if (r_cnt > 0 && s[i] == ')') dfs(cur, i, l_cnt, r_cnt - 1, ans); else if (l_cnt > 0 && s[i] == '(') dfs(cur, i, l_cnt - 1, r_cnt, ans); } } } }; // Judge the s is valid parentheses, if not, return false. Otherwise, return true. bool isValidParentheses(string& s) { int cnt = 0; for (char& a : s) { if (a == '(') cnt++; else if (a == ')') cnt--; if (cnt 另外一种解法:Link class Solution { public: vector removeInvalidParentheses(string s) { vector ans; dfs(s, 0, 0, ans, \"()\"); return ans; } private: void dfs(const string &s, int last_i, int last_j, vector &res, string p) { int n = s.size(); int cnt = 0; for (int i = last_i; i = 0) continue; for (int j = last_j; j last_j && s[j - 1] == p[1]) continue; dfs(s.substr(0, j) + s.substr(j + 1, n - j - 1), i, j, res, p); } return; } string s1 = s; reverse(s1.begin(), s1.end()); if (p[0] == '(') dfs(s1, 0, 0, res, \")(\"); else res.push_back(s1); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-921-Minimum-Add-to-Make-Parentheses-Valid.html":{"url":"Leetcode-921-Minimum-Add-to-Make-Parentheses-Valid.html","title":"Minimum Add to Make Parentheses Valid(LC.921)","keywords":"","body":"Question Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if: It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid. Example 1: Input: \"())\" Output: 1 Example 2: Input: \"(((\" Output: 3 Example 3: Input: \"()\" Output: 0 Example 4: Input: \"()))((\" Output: 4 Note: S.length S only consists of '(' and ')' characters. Difficulty:Medium Category: Solution class Solution { public: int minAddToMakeValid(string s) { int ans = 0; stack sta; for (int i = 0; i Related Problems Valid Parentheses Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-856-Score-Of-Parentheses.html":{"url":"Leetcode-856-Score-Of-Parentheses.html","title":"Score Of Parentheses(LC.856)","keywords":"","body":"Question Given a balanced parentheses string S, compute the score of the string based on the following rule: () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string. Example 1: Input: \"()\" Output: 1 Example 2: Input: \"(())\" Output: 2 Example 3: Input: \"()()\" Output: 2 Example 4: Input: \"(()(()))\" Output: 6 Note: S is a balanced parentheses string, containing only ( and ). 2 Solution class Solution { public: int scoreOfParentheses(string S) { int res = 0; std::stack par_stack; bool flag = false; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-946-Validate-Stack-Sequences.html":{"url":"Leetcode-946-Validate-Stack-Sequences.html","title":"Validate Stack Sequences(LC.946)","keywords":"","body":"Question Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. Note: 0 0 pushed is a permutation of popped. pushed and popped have distinct values. Difficulty:Medium Category:Stack Solution class Solution { public: bool validateStackSequences(vector& pushed, vector& popped) { stack s; auto it = popped.begin(); for (int& e : pushed) { s.push(e); while (!s.empty() && s.top() == *it) { s.pop(); ++it; } } return it == popped.end(); } }; Solution 2: Stack class Solution { public: vector nextGreaterElements(vector& nums) { int n = nums.size(); vector r(n, -1); stack s; for (int i = 0; i nums[s.top()]) { r[s.top()] = temp; s.pop(); } // save the element; if (i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-225-Implement-Stack-using-Queues.html":{"url":"Leetcode-225-Implement-Stack-using-Queues.html","title":"Implement Stack using Queues(LC.225)","keywords":"","body":"Question Implement the following operations of a stack using queues. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. empty() -- Return whether the stack is empty. Example: MyStack stack = new MyStack(); stack.push(1); stack.push(2);stack.top(); // returns 2 stack.pop(); // returns 2 stack.empty(); // returns false Notes: You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is emptyoperations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). Difficulty:Easy Category:Stack, Design Solution class MyStack { public: /** Initialize your data structure here. */ MyStack() {} /** Push element x onto stack. */ void push(int x) { q_.push(x); for (int i = 0; i q_; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-155-Min-Stack.html":{"url":"Leetcode-155-Min-Stack.html","title":"Min Stack(LC.155)","keywords":"","body":"Question Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> Returns -3. minStack.pop(); minStack.top(); --> Returns 0. minStack.getMin(); --> Returns -2. Difficulty:Easy Category:Stack, Design Solution class MinStack { public: /** initialize your data structure here. */ MinStack() {} void push(int x) { s_.push(x); if (s_min.empty() || x s_; stack s_min; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-84-Largest-Rectangle-in-histogram.html":{"url":"Leetcode-84-Largest-Rectangle-in-histogram.html","title":"Largest Rectangle in histogram(LC.84)","keywords":"","body":"Question Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Example: Input: [2,1,5,6,2,3] Output: 10 Difficulty:Medium Category:Array, Stack Analyze 问题： 求直方图里面的最大矩形面积 方案一(Solution 1): 来自于博客 [LeetCode] Largest Rectangle in Histogram 解题报告 通过遍历数组，没找到一个局部峰值，就向前遍历所有的数值，算出矩形面积，每次计算结果进行对比，保留最大值 方案二(Solution 2)： 维护一个单调栈，用来保存递增序列，相当于上面那种方法的找局部峰值。我们可以看到，直方图矩形面积要最大的话，需要尽可能的使得连续的矩形多，并且最低一块的高度要高。有点像木桶原理一样，总是最低的那块板子决定桶的装水量。 递增栈Vs递减栈 递增栈是维护递增的顺序，当遇到小于栈顶元素的数就开始处理，而递减栈正好相反，维护递减的顺序，当遇到大于栈顶元素的数开始处理。 在这一题中，我们要把大于栈顶的连续数字进入堆栈，而当遇到小于栈顶元素的数字时，就要取出栈顶元素进行处理了，那取出的顺序就是从高板子到矮板子了，于是乎遇到的较小的数字只是一个触发，开始计算矩形面积了，为了使得最后一块板子也被处理，这里用了个小trick，在高度数组最后面加上一个0，这样原先的最后一个板子也可以被处理了。(引自于博客) Solution Solution 1 遍历数组，遇到局部峰值后计算矩阵的大小，1. 然后比较大小: i + 1 , 如果当前数值小于等于下一个数值，那就说明这不是一个局部最大值，所以继续向后走，找到在一个局部位置的最大值int minH = height[i] for (int j = i; j >= 0; --j)，向这个局部最大值的前面找一个局部范围内的小值(只要比当前的最大值小就可以了)，使用这个数值计算一个面积，在这里，我们可以计算出来i个面积，在这个i个面积里面找到那个最大的面积 for (int j = i; j >= 0; --j) { minH = min(minH, height[j]); int area = minH * (i - j + 1); res = max(res, area); } 完整代码如下： class Solution { public: int largestRectangleArea(vector &height) { int res = 0; for (int i = 0; i = 0; --j) { minH = min(minH, height[j]); int area = minH * (i - j + 1); res = max(res, area); } } return res; } }; Solution 2 使用的网上推荐的一种方案, 使用递进增栈来处理这个问题。 为了保证能够处理到最后的一个元素，就在原有的元素最后加上一个0,保证最后是一个小的数值，这样能够处理到最后一段元素:heights.emplace_back(0); 如果当前堆栈为空(第一个元素，或者处理完上一次)，或者当前元素大于堆栈最上面的那个索引数值的话，那么就将这个数据放入到堆栈里面去。 if (s.empty() || heights[i] > heights[s.top()]) { s.push(i++); } 如果遇到一个小的数值的话，那么就处理堆栈里面的数据：heights[tmp] * (s.empty() ? i : i - s.top() - 1)) else { // 取出栈顶的元素 int tmp = s.top(); s.pop(); res = max(res, heights[tmp] * (s.empty() ? i : i - 1 - s.top())); // i - 1 is the position at the last element for the smaller element. } 完整的代码如下： class Solution { public: int largestRectangleArea(vector& heights) { int res = 0; std::stack s; heights.emplace_back(0); for (int i = 0; i heights[s.top()], then push in the stack if (s.empty() || heights[i] > heights[s.top()]) { s.push(i++); } else { int tmp = s.top(); s.pop(); res = max(res, heights[tmp] * (s.empty() ? i : i - s.top() - 1)); } } return res; } }; Solution 3 Solution 2简化版本： 代码如下 class Solution { public: int largestRectangleArea(vector& heights) { int res = 0; stack st; heights.push_back(0); for (int i = 0; i = heights[i]) { int cur = st.top(); st.pop(); res = max(res, heights[cur] * (st.empty() ? i : (i - st.top() - 1))); } st.push(i); } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-150-Evaluate-Reverse-Polish-Notation.html":{"url":"Leetcode-150-Evaluate-Reverse-Polish-Notation.html","title":"Evaluate Reverse Polish Notation(LC.150)","keywords":"","body":"Question Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation. Example 1: Input: [\"2\", \"1\", \"+\", \"3\", \"\"] Output: 9 Explanation: ((2 + 1) 3) = 9 Example 2: Input: [\"4\", \"13\", \"5\", \"/\", \"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"\", \"/\", \"\", \"17\", \"+\", \"5\", \"+\"] Output: 22 Explanation: ((10 (6 / ((9 + 3) -11))) + 17) + 5 = ((10 (6 / (12 -11))) + 17) + 5 = ((10 (6 / -132)) + 17) + 5 = ((10 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 Difficulty:Medium Category:Stack Solution class Solution { public: int evalRPN(vector& tokens) { stack sta; for (auto token : tokens) { // If this is a number, then push it to the stack. if (!is_operator(token)) { sta.push(token); } else { int b = stoi(sta.top()); sta.pop(); int a = stoi(sta.top()); sta.pop(); if (token == \"+\") a += b; else if (token == \"-\") a -= b; else if (token == \"*\") a *= b; else a /= b; sta.push(to_string(a)); } } return stoi(sta.top()); } bool is_operator(const string& token) { return token.size() == 1 && string(\"+-*/\").find(token) != string::npos; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-933-Number-of-Recent-Calls.html":{"url":"Leetcode-933-Number-of-Recent-Calls.html","title":"Number of Recent Calls(LC.933)","keywords":"","body":"Question Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before. Example 1: Input: inputs = [\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\"], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3] Note: Each test case will have at most 10000 calls to ping. Each test case will call ping with strictly increasing values of t. Each call to ping will have 1 . Difficulty:Easy Category:Queue Analyze 这道题目，一眼看过去，没有搞明白这个题目说的是什么东西。就是找出最近的3000毫秒内有多少个调用的请求，每个调用请求对应的是就是pint(t)函数，其中的t就是请求的时间，可以保证每一次ping的参数t是不大于前面３０００． Understand this Question： The input is the inputs = [[],[1],[100],[3001],[3002]]. These number in the array descript the time when the Ping is coming. As a result, I need to calculate the numbers of ping within the last 3000 milliseconds. Plan 1(Solution 1): Queue We can easily use the data structure Queue to solve this problem. If this cur ping - q.front > 3000, then we can pop the front one because we don't need them any more. If the cur ping - q.front , then we need to push the cur's time in the queue. We use the queue's size as the return value. Solution Solution 1: Queue // Solution 1: Queue // Runtimes: class RecentCounter { public: RecentCounter() {} int ping(int t) { while (!q.empty() && t - q.front() > 3000) q.pop(); q.push(t); return q.size(); } private: queue q; }; /** * Your RecentCounter object will be instantiated and called as such: * RecentCounter* obj = new RecentCounter(); * int param_1 = obj->ping(t); */ Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-406-Queue-Reconstruction-by-Height.html":{"url":"Leetcode-406-Queue-Reconstruction-by-Height.html","title":"Queue Reconstruction by Height(LC.406)","keywords":"","body":"Question Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note:The number of people is less than 1,100. Example Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] Difficulty:Medium Category:Greedy Solution class Solution { public: vector> reconstructQueue(vector>& people) { sort(people.begin(), people.end(), [](const pair& a, const pair& b) { return a.first > b.first || (a.first == b.first && a.second > ans; for (auto a : people) ans.insert(ans.begin() + a.second, a); return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-622-Design-Circular-Queue.html":{"url":"Leetcode-622-Design-Circular-Queue.html","title":"Design Circular Queue(LC.622)","keywords":"","body":"Question Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Your implementation should support following operations: MyCircularQueue(k): Constructor, set the size of the queue to be k. Front: Get the front item from the queue. If the queue is empty, return -1. Rear: Get the last item from the queue. If the queue is empty, return -1. enQueue(value): Insert an element into the circular queue. Return true if the operation is successful. deQueue(): Delete an element from the circular queue. Return true if the operation is successful. isEmpty(): Checks whether the circular queue is empty or not. isFull(): Checks whether the circular queue is full or not. Example: MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3 circularQueue.enQueue(1); // return true circularQueue.enQueue(2); // return true circularQueue.enQueue(3); // return true circularQueue.enQueue(4); // return false, the queue is full circularQueue.Rear(); // return 3 circularQueue.isFull(); // return true circularQueue.deQueue(); // return true circularQueue.enQueue(4); // return true circularQueue.Rear(); // return 4 Note: All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Queue library. Difficulty:Medium Category: Solution class MyCircularQueue { public: /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue(int k) : buffer(k, -1), cnt(0), n(k), front(k - 1), rear(k - 1) {} /** Insert an element into the circular queue. Return true if the operation is successful. */ bool enQueue(int value) { if (cnt == n) return false; buffer[rear--] = value; rear = (rear + n) % n; ++cnt; return true; } /** Delete an element from the circular queue. Return true if the operation is successful. */ bool deQueue() { if (cnt == 0) return false; front = (front - 1) % n; --cnt; return true; } /** Get the front item from the queue. */ int Front() { return cnt == 0 ? -1 : buffer[front]; } /** Get the last item from the queue. */ int Rear() { return cnt == 0 ? -1 : buffer[(rear + 1) % n]; } /** Checks whether the circular queue is empty or not. */ bool isEmpty() { return cnt == 0; } /** Checks whether the circular queue is full or not. */ bool isFull() { return cnt == n; } private: vector buffer; int cnt; int n; int front; int rear; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-641-Design-Circular-Deque.html":{"url":"Leetcode-641-Design-Circular-Deque.html","title":"Design Circular Deque(Lc.641)","keywords":"","body":"Question Design your implementation of the circular double-ended queue (deque). Your implementation should support following operations: MyCircularDeque(k): Constructor, set the size of the deque to be k. insertFront(): Adds an item at the front of Deque. Return true if the operation is successful. insertLast(): Adds an item at the rear of Deque. Return true if the operation is successful. deleteFront(): Deletes an item from the front of Deque. Return true if the operation is successful. deleteLast(): Deletes an item from the rear of Deque. Return true if the operation is successful. getFront(): Gets the front item from the Deque. If the deque is empty, return -1. getRear(): Gets the last item from Deque. If the deque is empty, return -1. isEmpty(): Checks whether Deque is empty or not. isFull(): Checks whether Deque is full or not. Example: MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3 circularDeque.insertLast(1); // return true circularDeque.insertLast(2); // return true circularDeque.insertFront(3); // return true circularDeque.insertFront(4); // return false, the queue is full circularDeque.getRear(); // return 2 circularDeque.isFull(); // return true circularDeque.deleteLast(); // return true circularDeque.insertFront(4); // return true circularDeque.getFront(); // return 4 Note: All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Deque library. Difficulty:Medium Category: Solution class MyCircularDeque { public: MyCircularDeque(int n) : buffer(n, -1), cnt(0), k(n), front(n - 1), rear(0){ } bool insertFront(int value) { if (cnt == k) return false; buffer[front--] = value; front = (front + k) % k; ++cnt; return true; } bool insertLast(int value) { if (cnt == k) return false; buffer[rear++] = value; rear %= k; ++cnt; return true; } bool deleteFront() { if (cnt == 0) return false; front = (front + 1) % k; --cnt; return true; } bool deleteLast() { if (cnt == 0) return false; rear = (rear - 1 + k) % k; --cnt; return true; } int getFront() { return cnt == 0 ? -1 : buffer[(front + 1) % k]; } int getRear() { return cnt == 0 ? -1 : buffer[(rear - 1 + k) % k]; } bool isEmpty() { return cnt == 0; } bool isFull() { return cnt == k; } private: vector buffer; int cnt; int k; int front; int rear; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"summary/summary.html":{"url":"summary/summary.html","title":"Traversal","keywords":"","body":"TODO: You need to write something..... Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:20 "},"Leetcode-144-Binary-Tree-Preorder-Traversal.html":{"url":"Leetcode-144-Binary-Tree-Preorder-Traversal.html","title":"Preorder Traversal","keywords":"","body":"Question Given a binary tree, return the preorder traversal of its nodes' values. Difficulty:Medium Category:Tree, Stack Analyze 这一道题目考察的是二叉树的深度遍历里面的前序遍历，在深度遍历里面有下面几种情况： 前序遍历：根结点 ---> 左子树 ---> 右子树 中序遍历：左子树---> 根结点 ---> 右子树 后序遍历：左子树 ---> 右子树 ---> 根结点 使用下图作为一个例子： 前序遍历: A->B->C->D->E->F->G->H->I->J->K->M->L 中序遍历: C->B->E->D->F->A->H->G->J->I->M->K->L 后序遍历: C->E->F->D->B->H->J->M->L->K->I->G->A 方案一：虽然这道题不让使用递归的方式来实现，但是还是将递归的版本写出来。 class Solution { public void preOrderTraverse1(TreeNode root) { if (root != null) { System.out.print(root.val + \" \"); preOrderTraverse1(root.left); preOrderTraverse1(root.right); } } } 方案二：非递归的实现方式，就需要使用到栈来进行辅助实现 （Solution 2） 图片来自于：二叉树经典面试题解析一：用非递归实现二叉树的前序遍历，中序遍历，后序遍历 前序遍历：根结点 ---> 左子树 ---> 右子树 根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点node，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，所以，需要栈这种数据结构的支持。对于任意一个结点node，具体步骤如下： 访问之，并把结点node入栈，当前结点置为左孩子； 判断结点node是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复a)步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的） Solution Solution 1: Stack class Solution { public: vector preorderTraversal(TreeNode* root) { vector res; stack sta; if (root != nullptr) sta.push(root); while (!sta.empty()) { const TreeNode* temp = sta.top(); sta.pop(); res.emplace_back(temp->val); if (temp->right != nullptr) sta.push(temp->right); if (temp->left != nullptr) sta.push(temp->left); } return res; } }; 非递归, 使用栈的另外一种实现方式。 class Solution { public: vector preorderTraversal(TreeNode* root) { vector res; stack sta; const TreeNode* p = root; while (p != nullptr || !sta.empty()) { if (p != nullptr) { res.emplace_back(p->val); sta.push(p); p = p->left; } else { // p == nullptr && !stack.isEmpty() const TreeNode* temp = sta.top(); sta.pop(); p = temp->right; } } return res; } }; 网上的另外一种实现的方式，其实和上面Solution 2的方式是一样的，只是使用的是while循环处理的p != nullptr。源代码来自：二叉树经典面试题解析一：用非递归实现二叉树的前序遍历，中序遍历，后序遍历 //前序非递归 void _PreOrderNR(pNode _pRoot) { pNode pCur = _pRoot; stack s; while (pCur || !s.empty()) { //将左侧节点依次压栈 while (pCur) { cout _data _pLeft; } //开始依次访问栈顶节点的右子树，通过循环将该右子树的左侧节点依次压栈 pNode pTop = s.top(); s.pop(); pCur = pTop->_pRight; //循环的子问题 } } Solution 2: 非递归(不使用堆栈) -- Morris Traversal, O(1)空间复杂度 参考博客:Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间） 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。 a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。输出当前节点（在这里输出，这是与中序遍历唯一一点不同）。当前节点更新为当前节点的左孩子。 b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。当前节点更新为当前节点的右孩子。 重复以上1、2直到当前节点为空。 class Solution { public: vector preorderTraversal(TreeNode* root) { vector ans; if (!root) return ans; TreeNode *cur = root, *pre; while (cur) { if (!cur->left) { ans.emplace_back(cur->val); cur = cur->right; } else { pre = cur->left; while (pre->right && pre->right != cur) pre = pre->right; if (!pre->right) { pre->right = cur; ans.emplace_back(cur->val); cur = cur->left; } else { pre->right = nullptr; cur = cur->right; } } } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-94-Binary-Tree-Inorder-Traversal.html":{"url":"Leetcode-94-Binary-Tree-Inorder-Traversal.html","title":"Inorder Traversal","keywords":"","body":"Question Difficulty:Medium Category:Tree, Stack, Hash Table Analyze 图片来自于：二叉树经典面试题解析一：用非递归实现二叉树的前序遍历，中序遍历，后序遍历 和前序非递归遍历方法一样，只是改变了遍历的次序问题, 输出的位置变化了一下就好了。下面的代码也来自于上面的博客： //中序非递归 void _InOrderNR(pNode _pRoot) { pNode pCur = _pRoot; stack s; while (pCur || !s.empty()) { //将左侧节点依次压栈 while (pCur) { s.push(pCur); pCur = pCur->_pLeft; } //栈中节点的左子树已经遍历完 //栈中节点自身和右子树还没有遍历 //开始依次访问栈顶节点的右子树，通过循环将该右子树的左侧节点依次压栈 pNode pTop = s.top(); cout _data _pRight; //循环的子问题 } } Solution Solution 1: 使用递归的方式完成 对左子结点调用递归函数，根节点访问值，右子节点再调用递归函数. class Solution { public: vector inorderTraversal(TreeNode* root) { vector ans; inorder(root, ans); return ans; } private: void inorder(TreeNode* root, vector& ans) { if (!root) return; inorder(root->left, ans); ans.emplace_back(root->val); inorder(root->right, ans); } }; Solution 2: 非递归的实现方式(使用堆栈) 从根节点开始，先将根节点压入栈，然后再将其所有左子结点压入栈，然后取出栈顶节点，保存节点值，再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中。这样就保证了访问顺序为左-根-右. class Solution { public: vector inorderTraversal(TreeNode* root) { vector res; stack sta; TreeNode* p = root; while (p || !sta.empty()) { if (p) { sta.push(p); p = p->left; } else { // p == nullptr && !stack.isEmpty() p = sta.top(); sta.pop(); res.emplace_back(p->val); p = p->right; } } return res; } }; Solution 3: 非递归(不使用堆栈) -- Morris Traversal, O(1)空间复杂度 A binary tree is threaded by making all right child pointers that would normally be null point to the inorder successor of the node (if it exists), and all left child pointers that would normally be null point to the inorder predecessor of the node. 参考博客:Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间） 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。 重复以上1、2直到当前节点为空。 class Solution { public: vector inorderTraversal(TreeNode* root) { vector ans; if (!root) return ans; TreeNode *cur = root, *pre; while (cur) { if (!cur->left) { ans.emplace_back(cur->val); cur = cur->right; } else { pre = cur->left; while (pre->right && pre->right != cur) pre = pre->right; if (!pre->right) { pre->right = cur; cur = cur->left; } else { pre->right = nullptr; ans.emplace_back(cur->val); cur = cur->right; } } } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-145-Binary-Tree-Postorder-Travesal.html":{"url":"Leetcode-145-Binary-Tree-Postorder-Travesal.html","title":"Postorder Travesal","keywords":"","body":"Question Given a binary tree, return the postorder traversal of its nodes' values. Difficulty:Hard Category:Tree, Hard Analyze 非递归的实现按照下图中的方式进行实现： 图片来自于：二叉树经典面试题解析一：用非递归实现二叉树的前序遍历，中序遍历，后序遍历 Solution class Solution { public: vector postorderTraversal(TreeNode* root) { vector res; stack sta; const TreeNode *p = root, *q = nullptr; do { while (p != nullptr) { sta.push(p); p = p->left; } q = nullptr; while (!sta.empty()) { p = sta.top(); sta.pop(); if (p->right == q) { res.push_back(p->val); q = p; } else { sta.push(p); p = p->right; break; } } } while (!sta.empty()); return res; } }; Solution 2: 非递归(不使用堆栈) -- Morris Traversal 参考博客:Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间） 后续遍历稍显复杂，需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。 步骤： 当前节点设置为临时节点dump。 如果当前节点的左孩子为空，则将其右孩子作为当前节点。 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。 a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。 b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。倒序输出从当前节点的左孩子到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右孩子。 重复以上1、2直到当前节点为空。 class Solution { public: vector postorderTraversal(TreeNode* root) { TreeNode dump(-1); dump.left = root; vector ans; TreeNode *cur = &dump, *pre = nullptr; while (cur) { if (!cur->left) { cur = cur->right; } else { pre = cur->left; while (pre->right && pre->right != cur) pre = pre->right; if (!pre->right) { pre->right = cur; cur = cur->left; } else { savePostorder(cur->left, pre, ans); pre->right = nullptr; cur = cur->right; } } } return ans; } private: void reverse(TreeNode* from, TreeNode* to) { if (from == to) return; TreeNode *x = from, *y = from->right, *z = nullptr; while (true) { z = y->right; y->right = x; x = y; y = z; if (x == to) break; } } void savePostorder(TreeNode* from, TreeNode* to, vector& ans) { reverse(from, to); TreeNode* p = to; while (true) { ans.emplace_back(p->val); if (p == from) break; p = p->right; } reverse(to, from); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-102-Binary-Tree-Level-Order-Traversal.html":{"url":"Leetcode-102-Binary-Tree-Level-Order-Traversal.html","title":"Level Order Traversal","keywords":"","body":"Question Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). Difficulty:Medium Category:Tree, Breadith-first Search Solution class Solution { public: vector> levelOrder(TreeNode *root) { vector> res; traverse(root, 1, res); return res; } void traverse(TreeNode const *root, int level, vector> &res) { if (!root) return; if (level > res.size()) res.push_back(vector()); res[level - 1].push_back(root->val); traverse(root->left, level + 1, res); traverse(root->right, level + 1, res); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-107-Binary-Tree-Level-Order-Traversal-II.html":{"url":"Leetcode-107-Binary-Tree-Level-Order-Traversal-II.html","title":"Level Order Traversal II","keywords":"","body":"Question Difficulty:Medium Category: Analyze Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root). Solution class Solution { public: vector> levelOrderBottom(TreeNode *root) { vector> res; traverse(root, 1, res); std::reverse(res.begin(), res.end()); return res; } void traverse(TreeNode const *root, int level, vector> &res) { if (!root) return; if (level > res.size()) res.push_back(vector()); res[level - 1].push_back(root->val); traverse(root->left, level + 1, res); traverse(root->right, level + 1, res); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal.html":{"url":"Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal.html","title":"Zigzag Level Order Traversal","keywords":"","body":"Question Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between). Difficulty:Medium Category:Tree, Stack, Breadth-first Search Solution class Solution { public: vector> zigzagLevelOrder(TreeNode *root) { vector> res; traverse(root, 1, res, true); return res; } void traverse(TreeNode const *root, int level, vector> &res, bool left_to_right) { if (!root) return; if (level > res.size()) res.push_back(vector()); if (left_to_right) { res[level - 1].push_back(root->val); } else { res[level - 1].insert(res[level - 1].begin(), root->val); } traverse(root->left, level + 1, res, !left_to_right); traverse(root->right, level + 1, res, !left_to_right); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-987-Vertical-Order-Traversal-of-a-Binary-Tree.html":{"url":"Leetcode-987-Vertical-Order-Traversal-of-a-Binary-Tree.html","title":"Vertical Order Traversal","keywords":"","body":"Question Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1). Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates). If two nodes have the same position, then the value of the node that is reported first is the value that is smaller. Return an list of non-empty reports in order of X coordinate. Every report will have a list of values of nodes. Example 1: Input: [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation: Without loss of generality, we can assume the root node is at position (0, 0): Then, the node with value 9 occurs at position (-1, -1); The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2); The node with value 20 occurs at position (1, -1); The node with value 7 occurs at position (2, -2). Example 2: Input: [1,2,3,4,5,6,7] Output: [[4],[2],[1,5,6],[3],[7]] Explanation: The node with value 5 and the node with value 6 have the same position according to the given scheme. However, in the report \"[1,5,6]\", the node value of 5 comes first since 5 is smaller than 6. Note: The tree will have between 1 and 1000 nodes. Each node's value will be between 0 and 1000. Difficulty:Medium Category:Tree Analyze 题目要求遍历二叉树，并把每一列存入一个二维数组，我们应该如何来确定列的顺序呢？ 在列内部， 我们又如何确定顺序呢？ 我们可以把根节点给个序号0，然后开始层序遍历，凡是左子节点则序号减1，右子节点序号加1，这样我们可以通过序号来把相同列的节点值放到一起，我们用一个TreeMap来建立序号和其对应的节点值的映射，用TreeMap的另一个好处是其自动排序功能可以让我们的列从左到右，由于层序遍历需要用到queue，我们此时queue里不能只存节点，而是要存序号和节点组成的pair，这样我们每次取出就可以操作序号，而且排入队中的节点也赋上其正确的序号 Solution Solution 1: Ordered_Map + Ordered_set Time complexity: O(nlogn) Space complexity: O(n) class Solution { public: vector> verticalTraversal(TreeNode* root) { if (!root) return {}; int min_col = INT_MAX; int max_col = INT_MIN; // Sort by the row value in the map, second sort by the col value // In the set, sort by the value map, set> rec; // {row, col} -> {vals} traverse(root, 0, 0, rec, min_col, max_col); vector> ans(max_col - min_col + 1); // max_x - min_x = number of the col for (const auto& m : rec) { int x = m.first.second - min_col; // Get the col val and map to ans // Insert the elements at the last of the vector. ans[x].insert(ans[x].end(), m.second.begin(), m.second.end()); } return ans; } private: void traverse(TreeNode* root, int col, int row, map, set>& rec, int& min_col, int& max_col) { if (!root) return; min_col = min(min_col, col); max_col = max(max_col, col); rec[{row, col}].insert(root->val); traverse(root->left, col - 1, row + 1, rec, min_col, max_col); traverse(root->right, col + 1, row + 1, rec, min_col, max_col); } }; Solution 2: Recursive Runtime: 12 ms, faster than 93.08% of C++ online submissions for Vertical Order Traversal of a Binary Tree. Memory Usage: 16.6 MB, less than 18.02% of C++ online submissions for Vertical Order Traversal of a Binary Tree. class Solution { public: vector> verticalTraversal(TreeNode* root) { recurse(root, 0, 0); vector> res; for (const auto& column : ans) { res.push_back(vector()); for (const auto& cell : column.second) { for (const auto& number : cell.second) { res.back().push_back(number); } } } return res; } void recurse(TreeNode* root, int x, int y) { if (root == nullptr) return; ans[x][y].insert(root->val); recurse(root->left, x - 1, y + 1); recurse(root->right, x + 1, y + 1); } map>> ans; }; Solution 3: Iteration (Error) 这种做法没有考虑列里面的顺序，可用在 Leetcode 314. Binary Tree Vertical Order Traversal class Solution { public: vector> verticalOrder(TreeNode* root) { vector> res; if (!root) return res; map> m; queue> q; q.push({0, root}); while (!q.empty()) { auto a = q.front(); q.pop(); m[a.first].push_back(a.second->val); if (a.second->left) q.push({a.first - 1, a.second->left}); if (a.second->right) q.push({a.first + 1, a.second->right}); } for (auto a : m) { res.push_back(a.second); } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-589-N-ary-Tree-Preorder-Traversal.html":{"url":"Leetcode-589-N-ary-Tree-Preorder-Traversal.html","title":"N ary Tree Preorder Traversal","keywords":"","body":"Question Given an n-ary tree, return the preorder traversal of its nodes' values. For example, given a 3-ary tree: Difficulty:Easy Category:Tree Solution class Solution { public: vector preorder(Node* root) { if (!root) return {}; ans.push_back(root->val); for (auto& c : root->children) preorder(c); return ans; } private: vector ans; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-590-N-ary-Tree-Postorder-Traversal.html":{"url":"Leetcode-590-N-ary-Tree-Postorder-Traversal.html","title":"N ary Tree Postorder Traversal","keywords":"","body":"Question Given an n-ary tree, return the postorder traversal of its nodes' values. For example, given a 3-ary tree: Difficulty:Easy Category:Tree Solution class Solution { public: vector postorder(Node* root) { if (!root) return {}; for (auto& c : root->children) postorder(c); ans.emplace_back(root->val); return ans; } private: vector ans; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-429-N-ary-Tree-Level-Order-Traversal.html":{"url":"Leetcode-429-N-ary-Tree-Level-Order-Traversal.html","title":"N ary Tree Level Order Traversal","keywords":"","body":"Question Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example, given a 3-ary tree: We should return its level order traversal: [ [1], [3,2,4], [5,6] ] Note: The depth of the tree is at most 1000. The total number of nodes is at most 5000. Difficulty:Easy Category:Tree Solution class Solution { public: vector> levelOrder(Node* root) { vector> ans; travllevel(root, 1, ans); return ans; } void travllevel(Node* root, int level, vector>& ans) { if (!root) return; if (level > ans.size()) ans.emplace_back(vector()); ans[level - 1].emplace_back(root->val); for (auto& c : root->children) travllevel(c, level + 1, ans); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-105-Construct-Binary-Tree-From-Preorder-and-Inorder-Traversal.html":{"url":"Leetcode-105-Construct-Binary-Tree-From-Preorder-and-Inorder-Traversal.html","title":"Construct Binary Tree From Preorder and Inorder Traversal","keywords":"","body":"Question Given preorder and inorder traversal of a tree, construct the binary tree. Difficulty:Medium Category:Tree, Array, Depth-first-Search Analyze 题目给定了先序和中序，并且里面的元素不重复，可以得到这样几个条件： 先序的第一个元素一定是跟 可以更加先序里面的根节点到中序里面找到对应的节点，因为没有重复元素 根据中序里面找到的根节点可以将其分为左右两个部分，分别对左右两个部分递归调用原函数 图片来自于:Construct a Binary Tree from Given Inorder and Depth-First-Search Solution 参考博客：Construct Binary Tree from Preorder and Inorder Traversal 由先序和中序遍历建立二叉树 Solution 1:递归方案 class Solution { public: TreeNode* buildTree(vector& preorder, vector& inorder) { return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); } TreeNode* buildTree(vector& preorder, int pLeft, int pRight, vector& inorder, int iLeft, int iRight) { if (pLeft > pRight || iLeft > iRight) return nullptr; // Get the root value for each subtree TreeNode* root = new TreeNode(preorder[pLeft]); // Move the i to the root->val in the inorder array int i = iLeft; for (; i left = buildTree(preorder, pLeft + 1, pLeft + (i - iLeft), inorder, iLeft, i - 1); root->right = buildTree(preorder, pLeft + i - iLeft + 1, pRight, inorder, i + 1, iRight); return root; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-106-Construct-Binary-Tree-From-Inorder-And-Postorder-Traversal.html":{"url":"Leetcode-106-Construct-Binary-Tree-From-Inorder-And-Postorder-Traversal.html","title":"Construct Binary Tree From Inorder And Postorder Traversal","keywords":"","body":"Question Given inorder and postorder traversal of a tree, construct the binary tree. Difficulty:Medium Category:Tree, Array, Depth-first-Search Analyze 题目给定了后序和中序，并且里面的元素不重复，可以得到这样几个条件： 后序的最后一个元素一定是跟节点 可以在后序里面的根节点到中序里面找到对应的节点，因为没有重复元素 根据中序里面找到的根节点可以将其分为左右两个部分，分别对左右两个部分递归调用原函数 图片来自于:Construct a Binary Tree from Given Inorder and Depth-First-Search Solution class Solution { public: TreeNode* buildTree(vector& inorder, vector& postorder) { return buildTree(postorder, 0, postorder.size() - 1, inorder, 0, inorder.size() - 1); } TreeNode* buildTree(vector& postorder, int pLeft, int pRight, vector& inorder, int iLeft, int iRight) { if (pLeft > pRight || iLeft > iRight) return nullptr; TreeNode* root = new TreeNode(postorder[pRight]); int i = 0; for (i = iLeft; i left = buildTree(postorder, pLeft, pLeft + (i - iLeft) - 1, inorder, iLeft, i - 1); root->right = buildTree(postorder, pLeft + (i - iLeft), pRight - 1, inorder, i + 1, iRight); return root; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-108-Convert-Sorted-Array-To-Binary-Search-Tree.html":{"url":"Leetcode-108-Convert-Sorted-Array-To-Binary-Search-Tree.html","title":"Convert Sorted Array To Binary Search Tree","keywords":"","body":"Question Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Difficulty:Easy Category:Tree, Depth-first-Search Solution Solution 1: Create any BST Runtime Error in this problem class Solution { public: TreeNode* sortedArrayToBST(vector& nums) { return sortedArrayToBST(nums, 0, nums.size() - 1); } private: TreeNode* sortedArrayToBST(vector& nums, int start, int end) { if (start > end) return nullptr; int mid = (start + end) / 2; TreeNode* root = new TreeNode(nums[mid]); root->left = sortedArrayToBST(nums, start, mid - 1); root->right = sortedArrayToBST(nums, mid + 1, end); return root; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree.html":{"url":"Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree.html","title":"Convert Sorted List to Binary Search Tree","keywords":"","body":"Question Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 Difficulty:Medium Category:Linked List, Depth-First-Search Solution class Solution { public: TreeNode* sortedListToBST(ListNode* head) { return sortedListToBst(head, getlength(head)); } private: TreeNode* sortedListToBst(ListNode* head, int len) { if (len == 0) return nullptr; if (len == 1) return new TreeNode(head->val); ListNode* mid = getnthnode(head, len / 2 + 1); ListNode* mid_r = getnthnode(head, len / 2 + 2); TreeNode* root = new TreeNode(mid->val); root->left = sortedListToBst(head, len / 2); root->right = sortedListToBst(mid_r, (len - 1) / 2); return root; } int getlength(ListNode* node) { int n = 0; while (node) { ++n; node = node->next; } return n; } ListNode* getnthnode(ListNode* node, int n) { while (--n) node = node->next; return node; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-226-Invert-Binary-Tree.html":{"url":"Leetcode-226-Invert-Binary-Tree.html","title":"Invert Binary Tree","keywords":"","body":"Question Invert a binary tree. Trivia:This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f* off. Difficulty:Medium Category:Tree Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* invertTree(TreeNode* root) { if (!root) return nullptr; TreeNode* temp = root->left; root->left = root->right; root->right = temp; invertTree(root->left); invertTree(root->right); return root; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-617-Merge-Two-Binary-Trees.html":{"url":"Leetcode-617-Merge-Two-Binary-Trees.html","title":"Merge Two Binary Trees","keywords":"","body":"Question Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Note: The merging process must start from the root nodes of both trees. Difficulty:Easy Category:Tree Solution //Runtime: 36ms class Solution { public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { if (!t1 && !t2) return nullptr; if (!t1 || !t2) { if (!t1) t1 = t2; return t1; } t1->val += t2->val; t1->left = mergeTrees(t1->left, t2->left); t1->right = mergeTrees(t1->right, t2->right); return t1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-965-Univalued-Binary-Tree.html":{"url":"Leetcode-965-Univalued-Binary-Tree.html","title":"Univalued Binary Tree","keywords":"","body":"Question A binary tree is univalued if every node in the tree has the same value. Return true if and only if the given tree is univalued. Example 1: Input: [1,1,1,1,1,null,1] Output: true Example 2: Input: [2,2,2,5,2] Output: false Note: The number of nodes in the given tree will be in the range [1, 100]. Each node's value will be an integer in the range [0, 99]. Difficulty:Easy Category:Tree Solution class Solution { public: bool isUnivalTree(TreeNode* root) { if (!root) return true; int val = root->val; return isUnivalTree(root, val); } bool isUnivalTree(TreeNode* root, int val) { if (!root) return true; if (root->val == val) { return isUnivalTree(root->left, val) && isUnivalTree(root->right, val); } else { return false; } } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-538-Convert-BST-to-Greater-Tree.html":{"url":"Leetcode-538-Convert-BST-to-Greater-Tree.html","title":"Convert BST to Greater Tree","keywords":"","body":"Question Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Difficulty:Easy Category:Tree Solution // Runtime: 32ms class Solution { public: TreeNode* convertBST(TreeNode* root) { int sum = 0; dfs(root, sum); return root; } private: void dfs(TreeNode* root, int& sum) { if (!root) return; dfs(root->right, sum); sum += root->val; root->val = sum; dfs(root->left, sum); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-449-Serialize-and-Deserialize-BST.html":{"url":"Leetcode-449-Serialize-and-Deserialize-BST.html","title":"Serialize and Deserialize BST","keywords":"","body":"Question Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. Difficulty:Medium Category:Tree Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-111-Minimum-Depth-of-Binary-Tree.html":{"url":"Leetcode-111-Minimum-Depth-of-Binary-Tree.html","title":"Minimum Depth of Binary Tree","keywords":"","body":"Question Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Difficulty:Easy Category:Tree, Depth-first-Search, Breadth-First-Search Analyze Template 1: One root There are four steps for this template: Boundary conditions. Deal with the root value. recursive call funciton compare ouput value There is a small mistake in the picture, the last line for this question. Use: min function Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int minDepth(TreeNode* root) { if (root == nullptr) return 0; if (root->left == nullptr && root->right == nullptr) return 1; int l = minDepth(root->left); int r = minDepth(root->right); if (r == 0) return l + 1; if (l == 0) return r + 1; return min(l, r) + 1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-104-Maximum-Depth-of-Binary-Tree.html":{"url":"Leetcode-104-Maximum-Depth-of-Binary-Tree.html","title":"Maximum Depth of Binary Tree","keywords":"","body":"Question Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Difficulty:Easy Category:Tree, Depth-first-Search Analyze This is a easy question for the tree problem. This question have these feature: One root node question We can use the return value to compare. So we use the template code for the Tree Question. There are four steps for this template: Boundary conditions. Deal with the root value. recursive call funciton compare ouput value Post: Tree Question Summary Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; int l = maxDepth(root->left); int r = maxDepth(root->right); return max(l, r) + 1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-559-Maximum-Depth-of-N-ary-Tree.html":{"url":"Leetcode-559-Maximum-Depth-of-N-ary-Tree.html","title":"Maximum Depth of N ary Tree","keywords":"","body":"Question Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree: Difficulty:Easy Category:Tree, Depth-First-Search, Breadth-First-Search Analyze So we use the template code for this Tree Question. There are four steps for this template: Boundary conditions. Deal with the root value. recursive call funciton compare ouput value Solution /* // Definition for a Node. class Node { public: int val; vector children; Node() {} Node(int _val, vector _children) { val = _val; children = _children; } }; */ class Solution { public: int maxDepth(Node* root) { if (root == nullptr) return 0; if (root->children.empty()) return 1; int len = root->children.size(), max_dep = 0; for (int i = 0; i children[i]); max_dep = max(max_dep, d); } return max_dep + 1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-110-Balanced-Binary-tree.html":{"url":"Leetcode-110-Balanced-Binary-tree.html","title":"Balanced Binary tree","keywords":"","body":"Question Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1 Difficulty:Easy Category:Tree, Depth-First-Search Solution class Solution { public: bool isBalanced(TreeNode* root) { return balanceHeight(root) >= 0; } int balanceHeight(TreeNode* root) { if (root == nullptr) return 0; int left = balanceHeight(root->left); int right = balanceHeight(root->right); if (left 1) return -1; return max(left, right) + 1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-114-Flatten-Binary-Tree-To-Linked-List.html":{"url":"Leetcode-114-Flatten-Binary-Tree-To-Linked-List.html","title":"Flatten Binary Tree To Linked List","keywords":"","body":"Question Given a binary tree, flatten it to a linked list in-place. Difficulty:Medium Category:Tree, Depth-first-Search Solution 思路是先利用DFS的思路找到最左子节点，然后回到其父节点，把其父节点和右子节点断开，将原左子结点连上父节点的右子节点上，然后再把原右子节点连到新右子节点的右子节点上，然后再回到上一父节点做相同操作。 class Solution { public: void flatten(TreeNode* root) { if (!root) return; if (root->left) flatten(root->left); if (root->right) flatten(root->right); TreeNode* temp = root->right; root->right = root->left; root->left = nullptr; while (root->right) root = root->right; root->right = temp; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-116-Populating-Next-Right-Pointers-In-Each-Node.html":{"url":"Leetcode-116-Populating-Next-Right-Pointers-In-Each-Node.html","title":"Populating Next Right Pointers In Each Node","keywords":"","body":"Question Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). Difficulty:Medium Category:Tree, Depth-First-Search Analyze 方案一：递归 (Solution 1) 这道题目是完全二叉树，所以如果节点的左子节点存在的话，那么右子节点必定存在： 如果左子节点存在，那么左节点的next指针可以直接指向其右子节点 对应右节点，判断其父节点的next是否为空，如果不为空，那么就指向父节点next指针指向的节点的左子节点，如果为空那么就指向NULL. 方案二：迭代 (Solution 2) Solution Solution 1:递归的解决方案 /** * Definition for binary tree with next pointer. * struct TreeLinkNode { * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} * }; */ class Solution { public: void connect(TreeLinkNode *root) { if (root == nullptr) return; if (root->left) root->left->next = root->right; if (root->right) root->right->next = root->next ? root->next->left : NULL; connect(root->left); connect(root->right); } }; Solution 2: 迭代的解决方案 class Solution { public: void connect(TreeLinkNode *root) { while (root) { TreeLinkNode *next = nullptr, *prev = nullptr; // Loop in the same level for (; root; root = root->next) { // The first one --> to find the next level if (!next) next = root->left ? root->left : root->right; if (root->left) { if (prev) prev->next = root->left; prev = root->left; } if (root->right) { if (prev) prev->next = root->right; prev = root->right; } } root = next; // Next Level } } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-687-Longest-Univalue-Path.html":{"url":"Leetcode-687-Longest-Univalue-Path.html","title":"Longest Univalue Path","keywords":"","body":"Question Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them. Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. Difficulty:Easy Category:Tree, Recursion Analyze This problem: You need to find the longest path which each node have the same value in this tree.(The path can pass the root node.) The output value not the node number. It is the side numbers. You can use the left len and right len and the root node together. Output 3 is 2, not 3. Solution Solution 1: dfs Time complexity: O(n) Space complexity: O(n) Runtime: 140 ms, faster than 93.41% of C++ online submissions for Longest Univalue Path. Memory Usage: 50.2 MB, less than 47.32% of C++ online submissions for Longest Univalue Path. class Solution { public: int longestUnivaluePath(TreeNode* root) { int max_len = 0; dfs(root, max_len); return max_len; } private: int dfs(TreeNode* root, int& max_len) { if (!root) return 0; int l = dfs(root->left, max_len); int r = dfs(root->right, max_len); int l_len = 0, r_len = 0; // The l is the long for the root->left, So, it need to return l_len if (root->left && root->left->val == root->val) l_len = l + 1; if (root->right && root->right->val == root->val) r_len = r + 1; // The path may pass the root node max_len = max(max_len, l_len + r_len); return max(l_len, r_len); } }; 其他类似解法可参考博客：Longest Univalue Path 最长相同值路径 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-100-Same-Tree.html":{"url":"Leetcode-100-Same-Tree.html","title":"Same Tree","keywords":"","body":"Question Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Difficulty:Easy Category:Tree, Depth-first-Search Solution Solution 1: Recursion Time complexity: O(n) Space complexity: O(n) class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if (!p && !q) return true; if (!p || !q) return false; return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right); } }; Follow up 如何判断其中一个树是另外一个树的 subtree LeetCode 572. Subtree of Another Tree Solution: Recursion Time complexity: O(max(n, m)) Space complexity: O(max(n, m)) class Solution { public: bool isSubtree(TreeNode* s, TreeNode* t) { if (t == nullptr) return true; if (s == nullptr) return false; if (isSameTree(s, t)) return true; return isSubtree(s->left, t) || isSubtree(s->right, t); } private: bool isSameTree(TreeNode* s, TreeNode* t) { if (s == nullptr && t == nullptr) return true; if (s == nullptr || t == nullptr) return false; return (s->val == t->val) && isSameTree(s->left, t->left) && isSameTree(s->right, t->right); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-101-Symmetrix-Tree.html":{"url":"Leetcode-101-Symmetrix-Tree.html","title":"Symmetrix Tree","keywords":"","body":"Question Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). Difficulty:Easy Category:Tree, Depth-First-Search, Breadth-First-Search Solution class Solution { public: bool isSymmetric(TreeNode* root) { if (root == nullptr) return true; return isSymmetric(root->left, root->right); } bool isSymmetric(TreeNode* p, TreeNode* q) { if (p == nullptr && q == nullptr) return true; if (p == nullptr || q == nullptr) return false; return p->val == q->val && isSymmetric(p->left, q->right) && isSymmetric(p->right, q->left); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-173-Binary-Search-Tree-Iterator.html":{"url":"Leetcode-173-Binary-Search-Tree-Iterator.html","title":"Binary Search Tree Iterator","keywords":"","body":"Question Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Example: Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called. Difficulty:Medium Category:Stack, Tree, Design Solution Using stack solve this problem. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ // Runtime: 48ms class BSTIterator { public: BSTIterator(TreeNode* root) { inorder(root, s); } /** @return the next smallest number */ int next() { int x = s.top(); s.pop(); return x; } void inorder(TreeNode* root, std::stack& s) { if (!root) return; inorder(root->right, s); s.push(root->val); inorder(root->left, s); } /** @return whether we have a next smallest number */ bool hasNext() { return s.size(); } private: std::stack s; }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */ Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-257-Binary-Tree-Paths.html":{"url":"Leetcode-257-Binary-Tree-Paths.html","title":"Binary Tree Paths","keywords":"","body":"Question Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Difficulty:Easy Category:Tree, DFS Solution Solution 1: DFS Time complexity: O(n) Space Complexity: O(n) Runtime: 8 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths. Memory Usage: 13 MB, less than 30.23% of C++ online submissions for Binary Tree Paths. class Solution { public: vector binaryTreePaths(TreeNode* root) { vector ans; string cur; binaryTreePaths(root, cur, ans); return ans; } private: void binaryTreePaths(TreeNode* root, string cur, vector& ans) { if (!root) return; cur += to_string(root->val); if (!root->left && !root->right) { ans.push_back(cur); } cur += \"->\"; binaryTreePaths(root->left, cur, ans); binaryTreePaths(root->right, cur, ans); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-222-Count-Complete-Tree-Nodes.html":{"url":"Leetcode-222-Count-Complete-Tree-Nodes.html","title":"Count Complete Tree Nodes","keywords":"","body":"Question Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Difficulty:Medium Category:Tree, Binary-Search Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ //Runtime: 16ms class Solution { public: int countNodes(TreeNode* root) { if (!root) return 0; if (!root->left && !root->right) return 1; int l = countNodes(root->left); int r = countNodes(root->right); return l + r + 1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-199-Binary-Tree-Right-Side-View.html":{"url":"Leetcode-199-Binary-Tree-Right-Side-View.html","title":"Binary Tree Right Side View","keywords":"","body":"Question Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Difficulty:Medium Category:Tree, Depth-First-Search, Breadth-First-Search Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ // Runtime: 4ms class Solution { public: vector rightSideView(TreeNode* root) { std::vector ans; rightSideView(root, 0, ans); return ans; } private: void rightSideView(TreeNode* root, int dep, std::vector& ans) { if (!root) return; if (dep == ans.size()) { ans.push_back(root->val); } rightSideView(root->right, dep + 1, ans); rightSideView(root->left, dep + 1, ans); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-637-Average-of-Levels-in-Binary-Tree.html":{"url":"Leetcode-637-Average-of-Levels-in-Binary-Tree.html","title":"Average of Levels in Binary Tree","keywords":"","body":"Question Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array. Example 1: Input: 3 / \\ 9 20 / \\ 15 7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Note: The range of node's value is in the range of 32-bit signed integer. Difficulty:Medium Category:Tree Solution Solution 1: DFS 利用的递归的先序遍历，但是其根据判断当前层数 level 跟结果 res 中已经初始化的层数之间的关系对比，能把当前结点值累计到正确的位置，而且该层的结点数也自增1，这样我们分别求了两个数组，一个数组保存了每行的所有结点值，另一个保存了每行结点的个数，这样对应位相除就是我们要求的结果了. Time Complexity: O(n) Space Complexity: O(n) Runtime: 24 ms, faster than 99.64% of C++ online submissions for Average of Levels in Binary Tree. Memory Usage: 22.3 MB, less than 28.32% of C++ online submissions for Average of Levels in Binary Tree. class Solution { public: vector averageOfLevels(TreeNode* root) { if (root == nullptr) return {}; vector> sum_count; // [sumForlevel, cnt] vector ans; preorder(root, 0, sum_count); for (const auto& p : sum_count) ans.push_back(static_cast(p.first) / p.second); return ans; } private: void preorder(TreeNode* root, int depth, vector>& sum_count) { if (root == nullptr) return; if (depth >= sum_count.size()) sum_count.push_back({0, 0}); sum_count[depth].first += root->val; ++sum_count[depth].second; preorder(root->left, depth + 1, sum_count); preorder(root->right, depth + 1, sum_count); } }; Solution 2: Iteration Time Complexity: O(n) Space Complexity: O(h) class Solution { public: vector averageOfLevels(TreeNode* root) { if (root == nullptr) return {}; vector ans; vector curr, next; curr.push_back(root); // process every level one by one while (!curr.empty()) { long long sum = 0; for (const auto& node : curr) { sum += node->val; if (node->left) next.push_back(node->left); if (node->right) next.push_back(node->right); } ans.push_back(static_cast(sum) / curr.size()); curr.swap(next); next.clear(); } return ans; } }; 也可以使用 queue 来实现： class Solution { public: vector averageOfLevels(TreeNode* root) { if (!root) return {}; vector res; queue q{{root}}; while (!q.empty()) { int n = q.size(); double sum = 0; for (int i = 0; i val; if (t->left) q.push(t->left); if (t->right) q.push(t->right); } res.push_back(sum / n); } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-606-Construct-String-from-Binary-Tree.html":{"url":"Leetcode-606-Construct-String-from-Binary-Tree.html","title":"Construct String from Binary Tree","keywords":"","body":"Question You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: string tree2str(TreeNode* t) { if (!t) return \"\"; string res = to_string(t->val); string left = tree2str(t->left), right = tree2str(t->right); if (left == \"\" && right == \"\") { return res;} if (left == \"\") {return res+\"()\"+\"(\"+ right +\")\";} if (right == \"\") {return res+\"(\" + left + \")\";} return res+\"(\" + left + \")\" + \"(\" + right+\")\"; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-543-Diameter-of-Binary-Tree.html":{"url":"Leetcode-543-Diameter-of-Binary-Tree.html","title":"Diameter of Binary Tree","keywords":"","body":"Leetcode 543. Diameter of Binary Tree Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 1 / \\ 2 3 / \\ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. Difficulty:Easy Category:Tree Solution Solution 1: Recursion Time complexity: O(n) Space complexity: O(n) Runtime: 16 ms, faster than 99.52% of C++ online submissions for Diameter of Binary Tree. Memory Usage: 20.5 MB, less than 43.81% of C++ online submissions for Diameter of Binary Tree. class Solution { public: int diameterOfBinaryTree(TreeNode* root) { int max_len = 0; dfs(root, max_len); return max_len; } private: int dfs(TreeNode* root, int& max_len) { if (!root) return 0; int left = dfs(root->left, max_len); int right = dfs(root->right, max_len); // Count the edge [left -> root] and [right -> root] max_len = max(max_len, left + right); return max(right, left) + 1; } }; Solution 2: Iteration Cite: LeetCode 543. Diameter of Binary Tree Simulate recursion with a stack. We also need to track the return value of each node. Time complexity: O(n) Space complexity: O(1) Runtime: 20 ms, faster than 69.08% of C++ online submissions for Diameter of Binary Tree. Memory Usage: 20.8 MB, less than 8.09% of C++ online submissions for Diameter of Binary Tree. class Solution { public: int diameterOfBinaryTree(TreeNode* root) { if (!root) return 0; int ans = 0; unordered_map d{{nullptr, -1}}; stack s; s.push(root); while (!s.empty()) { TreeNode* node = s.top(); if (d.count(node->left) && d.count(node->right)) { int l = d[node->left] + 1; int r = d[node->right] + 1; ans = max(ans, l + r); d[node] = max(l, r); // children's results will never be used again, safe to delete here. if (node->left) d.erase(node->left); if (node->right) d.erase(node->right); s.pop(); } else { if (node->left) s.push(node->left); if (node->right) s.push(node->right); } } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-671-Second-Minimum-Node-In-a-Binary-Tree.html":{"url":"Leetcode-671-Second-Minimum-Node-In-a-Binary-Tree.html","title":"Second Minimum Node In a Binary Tree","keywords":"","body":"Question Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1: Input: 2 / \\ 2 5 / \\ 5 7 Output: 5 Explanation: The smallest value is 2, the second smallest value is 5. Example 2: Input: 2 / \\ 2 2 Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value. Difficulty:Easy Category:Tree Solution // Runtime: 0ms class Solution { public: int findSecondMinimumValue(TreeNode* root) { // If there is a leaf, and don't have other node. if (!root || (!root->left && !root->right)) return -1; int l = root->left->val, r = root->right->val; if (l == root->val) l = findSecondMinimumValue(root->left); if (r == root->val) r = findSecondMinimumValue(root->right); if (l != -1 && r != -1) return min(l, r); return l != -1 ? l : r; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-572-Subtree-of-Another-Tree.html":{"url":"Leetcode-572-Subtree-of-Another-Tree.html","title":"Subtree of Another Tree","keywords":"","body":"Question Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself. Example 1:Given tree s: 3 / \\ 4 5 / \\ 1 2 Given tree t: 4 / \\ 1 2 Return true, because t has the same structure and node values with a subtree of s. Example 2:Given tree s: 3 / \\ 4 5 / \\ 1 2 / 0 Given tree t: 4 / \\ 1 2 Return false. Difficulty:Easy Category:Tree Solution // Runtime: 24ms class Solution { public: bool isSubtree(TreeNode* s, TreeNode* t) { if (!s) return false; bool p = isSubtreeRoot(s, t); bool l = isSubtree(s->left, t); bool r = isSubtree(s->right, t); return p || l || r; } private: bool isSubtreeRoot(TreeNode* s, TreeNode* t) { if (!s && !t) return true; if (!s || !t) return false; if (s->val != t->val) return false; bool l = isSubtreeRoot(s->left, t->left); bool r = isSubtreeRoot(s->right, t->right); return l && r; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-404-Sum-of-Left-Leaves.html":{"url":"Leetcode-404-Sum-of-Left-Leaves.html","title":"Sum of Left Leaves","keywords":"","body":"Question Find the sum of all left leaves in a given binary tree. Difficulty:Easy Category:Tree Solution // Runtimes: 4ms class Solution { public: int sumOfLeftLeaves(TreeNode* root) { if (!root) return 0; if (root->left && !root->left->left && !root->left->right) return root->left->val + sumOfLeftLeaves(root->right); int l = sumOfLeftLeaves(root->left); int r = sumOfLeftLeaves(root->right); return l + r; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-513-Find-Bottom-Left-Tree-Value.html":{"url":"Leetcode-513-Find-Bottom-Left-Tree-Value.html","title":"Find Bottom Left Tree Value","keywords":"","body":"Question Given a binary tree, find the leftmost value in the last row of the tree. Difficulty:Medium Category:Tree, Depth-First-Search, Breadth-First-Search Solution // Find the bootton left tree valur(not the left node) // Runtimes: 12ms class Solution { public: int findBottomLeftValue(TreeNode* root) { int max_row = -1, ans = 0; // DFS function dfs(root, 0, max_row, ans); return ans; } private: void dfs(TreeNode* root, int row, int& max_row, int& ans) { if (!root) return; dfs(root->left, row + 1, max_row, ans); if (row > max_row) { ans = root->val; max_row = row; } dfs(root->right, row + 1, max_row, ans); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-515-Find-Largest-Value-in-Each-Tree-Row.html":{"url":"Leetcode-515-Find-Largest-Value-in-Each-Tree-Row.html","title":"Find Largest Value in Each Tree Row","keywords":"","body":"Question You need to find the largest value in each row of a binary tree. Example: **Input:** 1 / \\ 3 2 / \\ \\ 5 3 9 **Output:** [1, 3, 9] Difficulty:Medium Category:Tree, Depth-First-Search, Breadth-First-Search Solution class Solution { public: vector largestValues(TreeNode* root) { vector ans; traverse(root, 1, ans); return ans; } private: void traverse(TreeNode const* root, int level, vector& res) { if (!root) return; if (level > res.size()) res.push_back(INT_MIN); if (root->val > res[level - 1]) res[level - 1] = root->val; traverse(root->left, level + 1, res); traverse(root->right, level + 1, res); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-951-Flip-Equivalent-Binary-Trees.html":{"url":"Leetcode-951-Flip-Equivalent-Binary-Trees.html","title":"Flip Equivalent Binary Trees","keywords":"","body":"Question For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations. Write a function that determines whether two binary trees are flip equivalent. The trees are given by root nodes root1 and root2. Difficulty:Medium Category:Tree Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ // Runtime: 4ms class Solution { public: bool flipEquiv(TreeNode* root1, TreeNode* root2) { if (!root1 && !root2) return true; if (!root1 || !root2) return false; bool l1 = flipEquiv(root1->left, root2->right); bool l2 = flipEquiv(root1->left, root2->left); bool r1 = flipEquiv(root1->right, root2->left); bool r2 = flipEquiv(root1->right, root2->right); return root1->val == root2->val && (l1 && r1) || (l2 && r2); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-563-Binary-Tree-Tilt.html":{"url":"Leetcode-563-Binary-Tree-Tilt.html","title":"Binary Tree Tilt","keywords":"","body":"Question Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes' tilt. Note: The sum of node values in any subtree won't exceed the range of 32-bit integer. All the tilt values won't exceed the range of 32-bit integer. Difficulty:Easy Category:Tree Solution // Runtime: 12ms class Solution { public: int findTilt(TreeNode* root) { int ans = 0; dfs(root, ans); return ans; } private: int dfs(TreeNode* root, int& ans) { if (!root) return 0; int l = dfs(root->left, ans); int r = dfs(root->right, ans); ans += abs(l - r); return l + r + root->val; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-958-Check-Completeness-of-a-Binary-Tree.html":{"url":"Leetcode-958-Check-Completeness-of-a-Binary-Tree.html","title":"Check Completeness of a Binary Tree(LC.958)","keywords":"","body":"Question Given a binary tree, determine if it is a complete binary tree. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example 1: Input: [1,2,3,4,5,6] Output: true Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible. Example 2: Input: [1,2,3,4,5,null,7] Output: false Explanation: The node with value 7 isn't as far left as possible. Note: The tree will have between 1 and 100 nodes. Difficulty:Medium Category: Solution class Solution { public: bool isCompleteTree(TreeNode *root) { vector> ans; int count = 0; traverse(root, 1, ans); if (ans.size() prev = ans[ans.size() - 2]; int n = prev.size(); count = 0; for (int i = 0; i left) count++; else break; if (prev[i]->right) count++; else break; } if (count != ans.back().size()) return false; return true; } private: void traverse(TreeNode *root, int level, vector> &res) { if (!root) return; if (level > res.size()) res.push_back(vector()); res[level - 1].push_back(root); traverse(root->left, level + 1, res); traverse(root->right, level + 1, res); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-98-Validate-Binary-Search-Tree.html":{"url":"Leetcode-98-Validate-Binary-Search-Tree.html","title":"Validate BST","keywords":"","body":"Question Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: Difficulty:Medium Category:Tree, Depth-First-Search Solution Note: in order to cover the range of -2^31 ~ 2^31-1, we need to use long or nullable integer. Time complexity: O(n) Space complexity: O(n) class Solution { public: bool isValidBST(TreeNode* root) { long pre = LONG_MIN; return inorder(root, pre); } private: bool inorder(TreeNode* root, long& pre) { if (!root) return true; bool left = inorder(root->left, pre); // Deal with root->val if (root->val val; bool right = inorder(root->right, pre); return left && right; } }; Follow up 如果限制不能使用 long 的数据类型的话， 我们可以考虑使用 TreeNode*. Traverse the tree and limit the range of each subtree and check whether root’s value is in the range. Time complexity: O(n) Space complexity: O(n) class Solution { public: bool isValidBST(TreeNode* root) { return isValidBST(root, nullptr, nullptr); } private: bool isValidBST(TreeNode* root, int* min_val, int* max_val) { if (!root) return true; if ((min_val && root->val val >= *max_val)) return false; return isValidBST(root->left, min_val, &root->val) && isValidBST(root->right, &root->val, max_val); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-96-Unique-Binary-Search-Trees.html":{"url":"Leetcode-96-Unique-Binary-Search-Trees.html","title":"Unique BST","keywords":"","body":"Question Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: **Input:** 3 **Output:** 5 **Explanation:** Given _n_ = 3, there are a total of 5 unique BST's: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Difficulty:Medium Category:Tree, DP Analyze 修改一下上图中展示的顺序: 以1为根的数的个数,等于左子树的个数 * 右子树的个数. 左子树是0个元素的树木(记作1),右子树是两个元素的树. 当数组为 1,2,3,4,5, ... n的时候,基于下面的规则构建的BST树木具有唯一性质: 以 i 为根结点的树, 其左子树由[1, i-1] 构成, 其右子树由 [i+1, n]构成. 定义f[i]为以[1,i]能够产生的Unique Binary Search Tree的数目. 如果数组为空,那么只有一种BST, 空树, f(0) = 1; 如果数组只有一个元素,那么只有一种BST, 它自己, f(1) = 1; 两个元素: f(2) = f(0)f(1) + f(1) f(0); 三个元素: f(3) = f(0) f(2) + f(1) f(1) + f(2) * f(0); $f(i) = \\sum_{k-1}^i f(k-1) * f(i-k)$ Solution class Solution { public: int numTrees(int n) { // Defint f[i] is the number for the BST in [1, i] // f[0] = 1, f[1] = 1, f[2] = 2; // f[2] = f[0] * f[1] // f[3] = f[0] * f[2] + f[1] * f[1] + f[2]* f[1] // f[i] = f[0] * f[i-1] + ... + f[i-1] * f[0] vector f(n + 1, 0); f[0] = 1; f[1] = 1; for (int i = 2; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-95-Unique-Binary-Search-Trees-II.html":{"url":"Leetcode-95-Unique-Binary-Search-Trees-II.html","title":"Unique BST II","keywords":"","body":"Question Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n. Example: **Input:** 3 **Output:** [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Difficulty:Medium Category:Dynamic-Programming, Tree Solution class Solution { public: vector generateTrees(int n) { if (n == 0) return {}; return generateTrees(1, n); } private: vector generateTrees(int start, int end) { vector ans; if (start > end) { ans.emplace_back(nullptr); return ans; } for (int k = start; k leftsub = generateTrees(start, k - 1); vector rightsub = generateTrees(k + 1, end); for (auto& m : leftsub) { for (auto& n : rightsub) { TreeNode* temp = new TreeNode(k); temp->left = m; temp->right = n; ans.emplace_back(temp); } } } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-99-Recover-Binary-Search-Tree.html":{"url":"Leetcode-99-Recover-Binary-Search-Tree.html","title":"Recover BST","keywords":"","body":"Question Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2] 1 / 3 \\ 2 Output: [3,1,null,null,2] 3 / 1 \\ 2 Example 2: **Input:** [3,1,4,null,null,2] 3 / \\ 1 4 / 2 **Output:** [2,1,4,null,null,3] 2 / \\ 1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? Difficulty:Hard Category:Tree, Depth-First-Search Analyze 这道题目可以使用很多种方案来解决, 首先我们能够想到的就是使用inorder遍历,因为它可以得到一个每个节点位置的数值记录的数组和一个记录每个结点顺序的结点指针, 將包含数值的数组排序之后,重新赋值回去给记录指针的数组就可以了. (Solution 1) Solution Solution 1: 使用树的中序遍历 // Time Complexity: O(n) class Solution { public: void recoverTree(TreeNode* root) { vector list; vector val; inorder(root, list, val); sort(val.begin(), val.end()); for (int i = 0; i val = val[i]; } private: void inorder(TreeNode* root, vector& list, vector& val) { if (!root) return; inorder(root->left, list, val); list.emplace_back(root); val.emplace_back(root->val); inorder(root->right, list, val); } }; Solution 3: --- Morris Traversal class Solution { public: void recoverTree(TreeNode* root) { TreeNode* first = nullptr, *second = nullptr, *parent = nullptr; TreeNode* cur = root, *pre = nullptr; while(cur){ if (!cur->left) { if (parent && parent->val > cur->val) { if (!first) first = parent; second = cur; } parent = cur; cur = cur->right; } else { pre = cur->left; while(pre->right && pre->right != cur) pre = pre->right; if (!pre->right) { pre->right = cur; cur = cur->left; } else { pre->right = nullptr; if (parent->val > cur->val) { if (!first) first = parent; second = cur; } parent = cur; cur = cur->right; } } } if (first && second) swap(first->val, second->val); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List.html":{"url":"Leetcode-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List.html","title":"Convert BST to Sorted Doubly Linked List","keywords":"","body":"Leetcode 426. Convert Binary Search Tree to Sorted Doubly Linked List 题目大意：输入是一个二叉搜索树，将其转化为双向链表输出 Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list. Let's take the following BST as an example, it may help you understand the problem better: We want to transform this BST into a circular doubly linked list. Each node in a doubly linked list has a predecessor and successor. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element. The figure below shows the circular doubly linked list for the BST above. The \"head\" symbol means the node it points to is the smallest element of the linked list. Specifically, we want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. We should return the pointer to the first element of the linked list. The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship. Difficulty:Medium Category: Analyze Cite: Convert Binary Search Tree to Sorted Doubly Linked List 将二叉搜索树转为有序双向链表 转化成双向链表后，每个结点都有left和right指针指向左右两个结点，不管其原来是否是叶结点还是根结点，转换后统统没有区别。 其次，我们发现这是个循环双向链表，即首尾结点是相连的，原先的二叉搜索树中的最左结点和最右结点，现在也互相连接起来了。最后，我们发现返回的结点不再是原二叉搜索树的根结点root了，而是最左结点，即最小值结点。 跟二叉搜索树有关的题，肯定要利用其性质，即左，即左子结点值小于根结点值小于右子结点值。而且十有八九都得用中序遍历来解，因为中序遍历的顺序就是左根右啊，跟性质吻合。我们观察原二叉搜索树中结点4连接着结点2和结点5，而在双向链表中，连接的是结点3和结点5，这就是为啥我们要用中序遍历了，因为只有中序遍历，结点3之后才会遍历到结点4，这时候我们可以将结点3和结点4串起来。决定了用中序遍历之后，就要考虑是迭代还是递归的写法，博主建议写递归的，一般写起来都比较简洁，而且递归是解树类问题的神器啊，十有八九都是用递归，一定要熟练掌握。再写中序遍历之前，其实还有难点，因为我们需要把相邻的结点连接起来，所以我们需要知道上一个遍历到的结点是什么，所以用一个变量pre，来记录上一个遍历到的结点。还需要一个变量head，来记录最左结点，这样的话，在递归函数中，先判空，之后对左子结点调用递归，这样会先一直递归到最左结点，此时如果head为空的话，说明当前就是最左结点，赋值给head和pre，对于之后的遍历到的结点，那么可以和pre相互连接上，然后pre赋值为当前结点node，再对右子结点调用递归即可 Solution Solution 1: Recursive Time complexity: O(n) Space complexity: O(1) class Solution { public: Node* treeToDoublyList(Node* root) { if (!root) return NULL; Node *head = NULL, *pre = NULL; inorder(root, pre, head); pre->right = head; head->left = pre; return head; } void inorder(Node* node, Node*& pre, Node*& head) { if (!node) return; inorder(node->left, pre, head); if (!head) { head = node; pre = node; } else { pre->right = node; node->left = pre; pre = node; } inorder(node->right, pre, head); } }; Solution 2: Iteration class Solution { public: Node* treeToDoublyList(Node* root) { if (!root) return NULL; Node *head = NULL, *pre = NULL; stack st; while (root || !st.empty()) { while (root) { st.push(root); root = root->left; } root = st.top(); st.pop(); if (!head) head = root; if (pre) { pre->right = root; root->left = pre; } pre = root; root = root->right; } head->left = pre; pre->right = head; return head; } }; Solution 3: Divide and Conquer class Solution { public: Node* treeToDoublyList(Node* root) { if (!root) return NULL; Node* leftHead = treeToDoublyList(root->left); Node* rightHead = treeToDoublyList(root->right); root->left = root; root->right = root; return connect(connect(leftHead, root), rightHead); } Node* connect(Node* node1, Node* node2) { if (!node1) return node2; if (!node2) return node1; Node *tail1 = node1->left, *tail2 = node2->left; tail1->right = node2; node2->left = tail1; tail2->right = node1; node1->left = tail2; return node1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-230-Kth-Smallest-Element-in-a-BST.html":{"url":"Leetcode-230-Kth-Smallest-Element-in-a-BST.html","title":"Kth Smallest Element in a BST","keywords":"","body":"Question Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Difficulty:Medium Category: Analyze In order to get the k-th smallest element in a BST, we can use the inorder traversal property to get a sorted array. (left ). There are two ways to solve this problem: recursive or no-recursive. Solution Solution 1: Inorder Traversal // Runtime: 12ms class Solution { public: int kthSmallest(TreeNode* root, int k) { std::stack s; TreeNode* p = root; while (p || !s.empty()) { if (p) { s.push(p); p = p->left; } else { TreeNode* t = s.top(); s.pop(); if (--k == 0) return t->val; p = t->right; } } return 0; } }; We also can change the Inorder function like the second way. Solution 2: The other Inorder traversal was // Runtime: 12ms class Solution { public: int kthSmallest(TreeNode* root, int k) { std::stack s; TreeNode* p = root; while (p) { s.push(p); p = p->left; } while (!s.empty()) { TreeNode* t = s.top(); s.pop(); if (--k == 0) return t->val; t = t->right; while (t) { s.push(t); t = t->left; } } return 0; } }; Solution 3: Divide and conquer 再来看一种分治法的思路，由于BST的性质，我们可以快速定位出第k小的元素是在左子树还是右子树，我们首先计算出左子树的结点个数总和cnt，如果k小于等于左子树结点总和cnt，说明第k小的元素在左子树中，直接对左子结点调用递归即可。如果k大于cnt+1，说明目标值在右子树中，对右子结点调用递归函数，注意此时的k应为k-cnt-1，应为已经减少了cnt+1个结点。如果k正好等于cnt+1，说明当前结点即为所求，返回当前结点值即可 class Solution { public: int kthSmallest(TreeNode* root, int k) { int cnt = count(root->left); if (k left, k); } else if (k > cnt + 1) { return kthSmallest(root->right, k - cnt - 1); } return root->val; } int count(TreeNode* node) { if (!node) return 0; return 1 + count(node->left) + count(node->right); } }; Follow up Cite(下面的内容和代码均来自于该博客地址): Kth Smallest Element in a BST 二叉搜索树中的第K小的元素 这道题的Follow up中说假设该BST被修改的很频繁，而且查找第k小元素的操作也很频繁，问我们如何优化。其实最好的方法还是像上面的解法那样利用分治法来快速定位目标所在的位置，但是每个递归都遍历左子树所有结点来计算个数的操作并不高效，所以我们应该修改原树结点的结构，使其保存包括当前结点和其左右子树所有结点的个数，这样我们使用的时候就可以快速得到任何左子树结点总数来帮我们快速定位目标值了。定义了新结点结构体，然后就要生成新树，还是用递归的方法生成新树，注意生成的结点的count值要累加其左右子结点的count值。然后在求第k小元素的函数中，我们先生成新的树，然后调用递归函数。在递归函数中，不能直接访问左子结点的count值，因为左子节结点不一定存在，所以我们先判断，如果左子结点存在的话，那么跟上面解法的操作相同。如果不存在的话，当此时k为1的时候，直接返回当前结点值，否则就对右子结点调用递归函数，k自减1 // Follow up class Solution { public: struct MyTreeNode { int val; int count; MyTreeNode* left; MyTreeNode* right; MyTreeNode(int x) : val(x), count(1), left(NULL), right(NULL) {} }; MyTreeNode* build(TreeNode* root) { if (!root) return NULL; MyTreeNode* node = new MyTreeNode(root->val); node->left = build(root->left); node->right = build(root->right); if (node->left) node->count += node->left->count; if (node->right) node->count += node->right->count; return node; } int kthSmallest(TreeNode* root, int k) { MyTreeNode* node = build(root); return helper(node, k); } int helper(MyTreeNode* node, int k) { if (node->left) { int cnt = node->left->count; if (k left, k); } else if (k > cnt + 1) { return helper(node->right, k - 1 - cnt); } return node->val; } else { if (k == 1) return node->val; return helper(node->right, k - 1); } } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree.html":{"url":"Leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree.html","title":"Lowest Common Ancestor of a BST","keywords":"","body":"Question Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the BST. Difficulty:Easy Category: Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (!root) return nullptr; if (root->val > p->val && root->val > q->val) return lowestCommonAncestor(root->left, p, q); if (root->val val && root->val val) return lowestCommonAncestor(root->right, p, q); return root; } }; Solution 2: Leetcode 236 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ //Runtime: 24ms class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (!root || root == p || root == q) return root; TreeNode* l = lowestCommonAncestor(root->left, p, q); TreeNode* r = lowestCommonAncestor(root->right, p, q); if (l && r) return root; return l ? l : r; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree.html":{"url":"Leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree.html","title":"Lowest Common Ancestor of a Binary Tree","keywords":"","body":"Question 题目大意： 求二叉树的最小共同父节点的题 Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the binary tree. Difficulty:Medium Category:Tree Solution 使用递归来求解，在递归函数中，我们首先看当前结点是否为空，若为空则直接返回空，若为p或q中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了p和q一定都在二叉树中存在，那么如果当前结点不等于p或q，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论： 若 p 和 q 要么分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回p和q结点的位置，而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可，这就是题目中的例子1的情况。 若 p 和 q 同时位于左子树，这里有两种情况，一种情况是left会返回p和q中较高的那个位置，而right会返回空，所以我们最终返回非空的left即可，这就是题目中的例子2的情况。还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。 若 p 和 q 同时位于右子树，同样这里有两种情况，一种情况是right会返回p和q中较高的那个位置，而left会返回空，所以我们最终返回非空的right即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回，写法很简洁 Time complexity: O(n) Space complexity: O(n) class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (!root || root == p || root == q) return root; TreeNode* l = lowestCommonAncestor(root->left, p, q); TreeNode* r = lowestCommonAncestor(root->right, p, q); if (l && r) return root; return l ? l : r; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-450-Delete-Node-in-a-BST.html":{"url":"Leetcode-450-Delete-Node-in-a-BST.html","title":"Delete Node in a BST","keywords":"","body":"Question Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. Note: Time complexity should be O(height of tree). Difficulty:Medium Category:Tree Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* deleteNode(TreeNode* root, int key) { if (!root) return nullptr; // If found the element if (key == root->val) { if (!root->right) return root->left; else { TreeNode* t = root->right; while (t->left) t = t->left; // Exchange the val for the t node // Move the target val to the last leaf // So Next time, move it swap(root->val, t->val); } } // Recursive call root->left = deleteNode(root->left, key); root->right = deleteNode(root->right, key); return root; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-501-Find-Mode-in-Binary-Search-Tree.html":{"url":"Leetcode-501-Find-Mode-in-Binary-Search-Tree.html","title":"Find Mode in BST","keywords":"","body":"Question Given a binary search tree (BST) with duplicates, find all the mode(s)) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. For example:Given BST [1,null,2,2], return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). Difficulty:Easy Category:Tree Solution // Runtime: 16ms class Solution { public: vector findMode(TreeNode* root) { vector ans; std::stack s; TreeNode* p = root; int preval = 0, count = 0, max_num = 0; while (p || !s.empty()) { if (p) { s.push(p); p = p->left; } else { TreeNode* t = s.top(); s.pop(); if (t->val == preval) count++; else { count = 1; preval = t->val; } if (count >= max_num) { if (count > max_num) ans.clear(); ans.push_back(preval); max_num = count; } p = t->right; } } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-669-Trim-a-Binary-Search-Tree.html":{"url":"Leetcode-669-Trim-a-Binary-Search-Tree.html","title":"Trim a BST","keywords":"","body":"Question Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R >= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. Example 1: **Input:** 1 / \\ 0 2 L = 1 R = 2 **Output:** 1 \\ 2 Example 2: **Input:** 3 / \\ 0 4 \\ 2 / 1 L = 1 R = 3 **Output:** 3 / 2 / 1 Difficulty:Easy Category:Tree Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-897-Increasing-Order-Search-Tree.html":{"url":"Leetcode-897-Increasing-Order-Search-Tree.html","title":"Increasing Order Search Tree","keywords":"","body":"Question Given a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. Example 1: **Input:** [5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\ 1 7 9 **Output:** [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 Note: The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000. Difficulty:Easy Category:Tree, Depth-First-Search Solution Solution 1:使用递归: Time Limit Exceeded class Solution { public: TreeNode* increasingBST(TreeNode* root) { if (!root) return root; vector ans; inorder(root, ans); std::cout right = ans[i]; p = p->right; } return root; } private: void inorder(TreeNode* root, vector& ans) { if (!root) return; inorder(root->left, ans); ans.emplace_back(root); inorder(root->right, ans); } }; Solution 2 class Solution { public: TreeNode* increasingBST(TreeNode* root) { return inorder(root, nullptr); } private: TreeNode* inorder(TreeNode* root, TreeNode* target) { if (!root) return target; TreeNode* ans = inorder(root->left, root); root->left =nullptr; root->right = inorder(root->right, target); return ans; } }; Solution 3 class Solution { public: TreeNode* increasingBST(TreeNode* root) { TreeNode dump(0); prev_ = &dump; inorder(root); return dump.right; } private: TreeNode* prev_; void inorder(TreeNode* root) { if (!root) return; inorder(root->left); prev_->right = root; prev_ = root; prev_->left = nullptr; inorder(root->right); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-979-Distribute-Coins-in-Binary-Tree.html":{"url":"Leetcode-979-Distribute-Coins-in-Binary-Tree.html","title":"Distribute Coins in Binary Tree","keywords":"","body":"Question Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total. In one move, we may choose two adjacent nodes and move one coin from one node to another. (The move may be from parent to child, or from child to parent.) Return the number of moves required to make every node have exactly one coin. Example 1: Input: [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child. Example 2: Input: [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child. Example 3: Input: [1,0,2] Output: 2 Example 4: Input: [1,0,0,null,3] Output: 4 Note: 1 0 Difficulty:Hard Category:Tree, Depth-First-Search Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int distributeCoins(TreeNode* root) { int ans = 0; dfs(root, ans); return ans; } private: int dfs(TreeNode* root, int& ans) { if (!root) return 0; int ret = 0; int x = dfs(root->left, ans); int y = dfs(root->right, ans); ret += x + y; ans += abs(x) + abs(y); ret += root->val - 1; return ret; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-112-Path-Sum.html":{"url":"Leetcode-112-Path-Sum.html","title":"Path Sum(LC.112)","keywords":"","body":"Question Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Difficulty:Medium Category:Tree, Depth-First-Search Analyze So we use the template code for this Tree Question. There are four steps for this template: Boundary conditions. Deal with the root value. recursive call funciton compare ouput value Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int sum) { if (!root) return false; if (!root->left && !root->right) return root->val == sum; bool l = hasPathSum(root->left, sum - root->val); bool r = hasPathSum(root->right, sum - root->val); return l || r; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-113-Path-Sum-II.html":{"url":"Leetcode-113-Path-Sum-II.html","title":"Path Sum II(LC.113)","keywords":"","body":"Question Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, Difficulty:Medium Category:Tree, Depth-first Search Solution //Runtime: 8ms class Solution { public: vector> pathSum(TreeNode* root, int sum) { vector> ans; vector cur; dfs(root, sum, cur, ans); return ans; } private: void dfs(TreeNode* root, int sum, vector& cur, vector>& ans) { if (!root) return; if (!root->left && !root->right) { if (root->val == sum) { cur.push_back(root->val); ans.push_back(cur); cur.pop_back(); } return; } cur.push_back(root->val); dfs(root->left, sum - root->val, cur, ans); dfs(root->right, sum - root->val, cur, ans); cur.pop_back(); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-437-Path-Sum-III.html":{"url":"Leetcode-437-Path-Sum-III.html","title":"Path Sum III(LC.437)","keywords":"","body":"Question You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Example: Difficulty:Easy Category:Tree Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ // Runtime: 36ms class Solution { public: int pathSum(TreeNode* root, int sum) { if (!root) return 0; int c = curSum(root, sum, 0); int l = pathSum(root->left, sum); int r = pathSum(root->right, sum); return c + l + r; } private: int curSum(TreeNode* root, int& sum, int cur) { if (!root) return 0; cur += root->val; int l = curSum(root->left, sum, cur); int r = curSum(root->right, sum, cur); return (cur == sum) + l + r; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-129-Sum-Root-to-Leaf-Numbers.html":{"url":"Leetcode-129-Sum-Root-to-Leaf-Numbers.html","title":"Sum Root to Leaf Numbers(LC.129)","keywords":"","body":"Question Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Difficulty:Medium Category:Tree, Depth-First-Search Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int sumNumbers(TreeNode* root) { if (!root) return 0; int ans = 0; return sumNumbers(root, ans); } private: int sumNumbers(TreeNode* root, int ans) { if (!root) return 0; ans = ans * 10 + root->val; if (!root->left && !root->right) { return ans; } int l = sumNumbers(root->left, ans); int r = sumNumbers(root->right, ans); // If this is not the last one, // return l + r; return l + r; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-988-Smallest-String-Starting-From-Leaf.html":{"url":"Leetcode-988-Smallest-String-Starting-From-Leaf.html","title":"Smallest String Starting From Leaf(LC.988)","keywords":"","body":"Question Given the root of a binary tree, each node has a value from 0 to 25representing the letters 'a' to 'z': a value of 0 represents 'a', a value of 1 represents 'b', and so on. Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root. (As a reminder, any shorter prefix of a string is lexicographically smaller: for example, \"ab\" is lexicographically smaller than \"aba\". A leaf of a node is a node that has no children.) Example 1: Input: [0,1,2,3,4,3,4] Output: \"dba\" Example 2: Input: [25,1,3,1,3,0,2] Output: \"adz\" Example 3: Input: [2,2,1,null,1,0,null,0] Output: \"abc\" Note: The number of nodes in the given tree will be between 1 and 1000. Each node in the tree will have a value between 0 and 25. Difficulty:Medium Category: Solution class Solution { public: string smallestFromLeaf(TreeNode* root) { if (!root) return \"\"; if (!root->left && !root->right) { char temp = root->val + 'a'; return string(1, temp); } string l = smallestFromLeaf(root->left); string r = smallestFromLeaf(root->right); char temp = root->val + 'a'; if (l == \"\") return r + temp; if (r == \"\") return l + temp; return min(l + temp, r + temp); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-124-Binary-Tree-Maximum-Path-Sum.html":{"url":"Leetcode-124-Binary-Tree-Maximum-Path-Sum.html","title":"Binary Tree Maximum Path Sum(LC.124)","keywords":"","body":"Question Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Difficulty:Hard Category:Tree, Depth-First-Search Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxPathSum(TreeNode* root) { if (!root) return 0; int ans = INT_MIN; maxPathSum(root, ans); return ans; } private: int maxPathSum(TreeNode* root, int& ans) { if (!root) return 0; int l = max(0, maxPathSum(root->left, ans)); int r = max(0, maxPathSum(root->right, ans)); int sum = l + r + root->val; // Only use the ans to record, don't use it to return ans = max(sum, ans); return max(l, r) + root->val; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-Interview-Amazon-OA2-Subtree-Maximum-average-node.html":{"url":"Leetcode-Interview-Amazon-OA2-Subtree-Maximum-average-node.html","title":"Subtree: Maximum Average Node(Interview)","keywords":"","body":"Subtree: Maximum average node 两个版本的情况，可能是二叉树，也可能是多子节点的情况。我之前看到过这个题型的两种版本，一种是二叉树的，一种则是有多个子节点的。很不幸我遇到的是后者，为什么说不幸呢，且听我娓娓道来。 要注意我用的语言是C++，所以题目里对CategoryNode类的描述和截图里稍有不同。坑爹的是出题人写错了。。TA把成员变量subCategoryNode的类型写成了vector（经事实证明应该是vector），直接导致了我编译一直没通过。等到我捣鼓了半天终于编译过了发现结果不对，时间只剩3分钟的我脑袋炸裂，并没能奇迹般的找出bug来。 解答看这里：https://www.1point3acres.com/bbs ... read&tid=478916 （另外OA要求那里好像有说不能用global以及static变量，所以我把res作为了helper的实参） 需要注意的是返回的必须是内部节点 general tree, leaves not counted), return tree node Find substrings of size k with k-1 distinct characters K-1 distinct subarray with length K 多差树 找最大平均的TreeNode 不包括叶子 变形题：Number of substrings containing K distinct characters，返回满足条件的子串个数-corner case：K=0时，返回0-注意相同的子串只算一次，所以用unordered_set来记录符合条件的子串，可以达到除重的目的 若要求子串长度为K： -可以考虑用双指针来模拟大小为k的窗口，用一个unordered_map来存窗口内的，移动时把左指针所指的字符在map中—，若等于0则从map中删去该项；而右指针所指的新字符则在map中++（或新建），若map.size等于k则说明该子串符合条件，否则不符合条件。-时间复杂度为O(n+mk)其中n为大字符串的长度，m为符合条件的子串数目（mk是取substr的开销） 若子串长度没有限制： -举例来说，“aba”的k=2的子串有“ab”、“aba”，亦即要求有k种字母，而单种字母是可以出现多次的-用两重循环的方法，对每个左指针i，右指针j从i开始一直移动到n-1，此过程中维护一个hashmap。若hashmap的size为k，则将该子串加入到结果中-时间复杂度是O(n^2)。如果相同子串只算一次的话，需要用unordered_set来存结果。需要注意的是每一层i循环中移动指针j的时候也需要维护一个[i,j]的子串，这样当符合条件时就不需要调用substr产生额外的开销了 find substrings of size k with k-1 distinct characters，返回满足条件的子串个数 -与上题算法的区别：判断条件从map.size==k 改为 map.size == k - 1 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:19 "},"Leetcode-993-Cousins-in-Binary-Tree.html":{"url":"Leetcode-993-Cousins-in-Binary-Tree.html","title":"Cousins in Binary Tree(LC.933)","keywords":"","body":"Question In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins. Example 1: Input: root = [1,2,3,4], x = 4, y = 3 Output: false Example 2: Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true Example 3: Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false Note: The number of nodes in the tree will be between 2 and 100. Each node has a unique integer value from 1 to 100. Difficulty:Easy Category: Solution class Solution { public: bool isCousins(TreeNode* root, int x, int y) { if ((level(root, x, 1) == level(root, y, 1)) && !(isSibling(root, x, y))) return true; return false; } private: bool isSibling(TreeNode* root, int a, int b) { if (!root) return false; if (root->left && root->right) { if ((root->left->val == a && root->right->val == b) || (root->right->val == a && root->left->val == b)) { return true; } } return isSibling(root->left, a, b) || isSibling(root->right, a, b); } int level(TreeNode* root, int target, int lev) { if (!root) return 0; if (root->val == target) return lev; int l = level(root->left, target, lev + 1); if (l != 0) return l; return level(root->right, target, lev + 1); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-865-Smallest-Subtree-with-all-the-Deepest-Nodes.html":{"url":"Leetcode-865-Smallest-Subtree-with-all-the-Deepest-Nodes.html","title":"Smallest Subtree with all the Deepest Nodes(LC.865)","keywords":"","body":"Leetcode 865. Smallest Subtree with all the Deepest Nodes 题目：一棵二叉树有它的最大深度，找出包含了树中所有深度最大的结点的最深的子树。 Given a binary tree rooted at root, the depth of each node is the shortest distance to the root. A node is deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is that node, plus the set of all descendants of that node. Return the node with the largest depth such that it contains all the deepest nodes in its subtree. Example 1: Input: [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation: We return the node with value 2, colored in yellow in the diagram. The nodes colored in blue are the deepest nodes of the tree. The input \"[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]\" is a serialization of the given tree. The output \"[2, 7, 4]\" is a serialization of the subtree rooted at the node with value 2. Both the input and output have TreeNode type. Note: The number of nodes in the tree will be between 1 and 500. The values of each node are unique. Difficulty:Medium Category: Analyze 这个题的模型其实比较左右子树的高度，如果左右子树的高度相等，说明当前节点就是要求的。这个解释是这样的：必须包含所有的最大高度的叶子，左右叶子高度相等，所以必须包含当前节点。 当左子树高度>右子树高度的时候，要求的节点在左边；反之，在右边。 所以，递归思路 + 一个pair。这个pair的思路是，保存了当前节点的深度和当前节点的最深子树节点。 Cite: LeetCode 865. Smallest Subtree with all the Deepest Nodes Solution Solution 1: Recursion Time complexity: O(n) Space complexity: O(n) Runtime: 12 ms, faster than 74.90% of C++ online submissions for Smallest Subtree with all the Deepest Nodes. Memory Usage: 15.3 MB, less than 44.90% of C++ online submissions for Smallest Subtree with all the Deepest Nodes. class Solution { public: TreeNode* subtreeWithAllDeepest(TreeNode* root) { return depth(root).second; } private: pair depth(TreeNode* root) { if (root == nullptr) return {-1, nullptr}; auto left = depth(root->left); auto right = depth(root->right); int dl = left.first; int dr = right.first; return {max(dl, dr) + 1, dl == dr ? root : (dl > dr) ? left.second : right.second}; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-547-Friend-Circles.html":{"url":"Leetcode-547-Friend-Circles.html","title":"Friend Circles(LC.547)","keywords":"","body":"Leetcode 547. Friend Circles 题目大意：求朋友圈的个数, 判断在 n 个人里面有多少个朋友圈 There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends. Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ithand jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students. Example 1: Input: [[1,1,0], [1,1,0], [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.The 2nd student himself is in a friend circle. So return 2. Example 2: Input: [[1,1,0], [1,1,1], [0,1,1]] Output: 1 Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1. Note: N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1. Difficulty:Medium Category: Solution 那么比较直接的解法就是DFS搜索，对于某个人，遍历其好友，然后再遍历其好友的好友，那么我们就能把属于同一个朋友圈的人都遍历一遍，我们同时标记出已经遍历过的人，然后累积朋友圈的个数，再去对于没有遍历到的人在找其朋友圈的人，这样就能求出个数。 Solution 1: DFS Time complexity: O(n^2), Space complexity: O(n) class Solution { public: int findCircleNum(vector>& M) { int n = M.size(), ans = 0; vector visited(n, false); for (int i = 0; i >& M, int k, vector& visited) { visited[k] = true; for (int i = 0; i 我们也可以不使用多余的空间来记录，直接在原有的元素上操作就好： cite:花花酱 LeetCode 547. Friend Circles class Solution { public: int findCircleNum(vector>& M) { if (M.empty()) return 0; int n = M.size(); int ans = 0; for (int i = 0; i >& M, int curr, int n) { // Visit all friends (neighbors) for (int i = 0; i Solution 2: BFS class Solution { public: int findCircleNum(vector>& M) { int n = M.size(), res = 0; vector visited(n, false); queue q; for (int i = 0; i Solution 3: Union Find 初始时给每一个对象都赋上不同的标签，然后对于属于同一类的对象，在root中查找其标签，如果不同，那么将其中一个对象的标签赋值给另一个对象，注意root数组中的数字跟数字的坐标是有很大关系的，root存的是属于同一组的另一个对象的坐标，这样通过getRoot函数可以使同一个组的对象返回相同的值. Time complexity: O(n), Space complexity: O(n) class UnionFindSet { public: UnionFindSet(int n) { parents_ = vector(n + 1, 0); ranks_ = vector(n + 1, 0); for (int i = 0; i ranks_[pv]) { parents_[pv] = pu; } else if (ranks_[pv] > ranks_[pu]) { parents_[pu] = pv; } else { parents_[pu] = pv; ++ranks_[pv]; } return true; } int Find(int id) { if (id != parents_[id]) parents_[id] = Find(parents_[id]); return parents_[id]; } private: vector parents_; vector ranks_; }; class Solution { public: int findCircleNum(vector>& M) { int n = M.size(); UnionFindSet s(n); for (int i = 0; i circles; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-133-Clone-Graph.html":{"url":"Leetcode-133-Clone-Graph.html","title":"Clone Graph","keywords":"","body":"Leetcode 133. Clone Graph 题目大意：无向图的深度复制 Given a reference of a node in a connected#Connected_graph) undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors. Example: Input: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1} Explanation: Node 1's value is 1, and it has two neighbors: Node 2 and 4. Node 2's value is 2, and it has two neighbors: Node 1 and 3. Node 3's value is 3, and it has two neighbors: Node 2 and 4. Node 4's value is 4, and it has two neighbors: Node 1 and 3. Note: The number of nodes will be between 1 and 100. The undirected graph is a simple graph#Simple_graph), which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph. Difficulty:Medium Category:Depth-First-Search, Breadth-First-Search, Graph Analyze cite:Clone Graph 克隆无向图 如何处理每一个节点的neighbors 由于所有的结点都具有不同的数值，所以我们可以使用HashMap来对应原图中的结点和新生成的克隆图中的结点。图的遍历的基本方法是 DFS 和 BFS. 在递归函数中，首先判断是否为空m.count(node)，然后再看当前的结点是否已经被克隆过了，若在 HashMap 中存在，则直接返回其映射结点。否则就克隆当前结点，并在 HashMap 中建立映射，然后遍历当前结点的所有neihbor结点，调用递归函数并且加到克隆结点的 neighbors 数组中即可. Solution Solution 1: DFS class Solution { public: Node* cloneGraph(Node* node) { unordered_map m; return helper(node, m); } private Node* helper(Node* node, unordered_map& m) { if (!node) return nullptr; if (m.count(node)) return m[node]; Node* clone = new Node(node->val); m[node] = clone; for (Node* neighbor : node->neighbors) { clone->neighbors.push_back(helper(neighbor, m)); } return clone; } }; Solution 2: BFS--Queue + HashTable 使用BFS来遍历图，使用队列queue进行辅助，还是需要一个HashMap来建立原图结点和克隆结点之间的映射。先克隆当前结点，然后建立映射，并加入queue中，进行while循环。在循环中，取出队首结点，遍历其所有neighbor结点，若不在HashMap中，我们根据 neighbor 结点值克隆一个新 neighbor 结点，建立映射，并且排入queue中。然后将 neighbor 结点在 HashMap 中的映射结点加入到克隆结点的 neighbors 数组中即可. Time complexity: O(V+E) Space complexity: O(V+E) class Solution { public: Node *cloneGraph(Node *node) { if (!node) return NULL; unordered_map m; queue q{{node}}; Node *clone = new Node(node->val); m[node] = clone; while (!q.empty()) { Node *t = q.front(); q.pop(); for (Node *neighbor : t->neighbors) { if (!m.count(neighbor)) { m[neighbor] = new Node(neighbor->val); q.push(neighbor); } m[t]->neighbors.push_back(m[neighbor]); } } return clone; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-9-Palindrome-Number.html":{"url":"Leetcode-9-Palindrome-Number.html","title":"Palindrome Number","keywords":"","body":"Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Could you solve it without converting the integer to a string? Difficulty:Easy Category:Math Analyze 验证回文数字, 直接对整数进行操作，我们可以利用取整和取余来获得我们想要的数字, 每计算一次, 去掉收尾各一个数字, 循环计算. Solution class Solution { public: bool isPalindrome(int x) { if (x = 10) div *= 10; while (x > 0) { int left = x / div; int right = x % 10; if (left != right) return false; x = (x % div) / 10; div /= 100; } return true; } }; Solution 2 class Solution { public: bool isPalindrome(int x) { if (x Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-50-Powerx-n.html":{"url":"Leetcode-50-Powerx-n.html","title":"Powerx n","keywords":"","body":"Question Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 x n is a 32-bit signed integer, within the range [−231, 231 − 1] Difficulty:Medium Category:Math, Binary-Search Analyze 使用分治法，解决求解一半的情况： double half = power(x, n/2); Solution class Solution { public: double myPow(double x, int n) { if (n Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-60-Permutation-Sequence.html":{"url":"Leetcode-60-Permutation-Sequence.html","title":"Permutation Sequence","keywords":"","body":"Question The set [1,2,3,...,_n_] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Given n and k, return the _k_th permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1: Input: n = 3, k = 3 Output: \"213\" Example 2: Input: n = 4, k = 9 Output: \"2314\" Difficulty:Medium Category:Math, Backtracking Analyze 这到题是找到数字的排列中的第k个，我们在Leetcode 31. Next Permutation 这个题目是已经完成了求解给定排列的下一个排列的情况，所以这道题目，我们直接使用那道题目的函数来循环k次求解第k个排列就好了。 class Solution { public: void nextPermutation(vector& nums) { unsigned len = nums.size() - 1; // Find an element from the right to left. for (int i = len - 1; i >= 0; --i) { if (nums[i + 1] > nums[i]) { for (int j = len; j > i; --j) { if (nums[j] > nums[i]) { swap(nums[j], nums[i]); reverse(nums.begin() + i + 1, nums.end()); return; } } } } // If there are increate order from left to right. reverse(nums.begin(), nums.end()); return; } }; 只需要在最后将结果转换为string返回即可。 Solution class Solution { public: string getPermutation(int n, int k) { vector nums; for (int i = 0; i & nums) { unsigned len = nums.size() - 1; // Find an element from the right to left. for (int i = len - 1; i >= 0; --i) { if (nums[i + 1] > nums[i]) { for (int j = len; j > i; --j) { if (nums[j] > nums[i]) { swap(nums[j], nums[i]); reverse(nums.begin() + i + 1, nums.end()); return; } } } } // If there are increate order from left to right. reverse(nums.begin(), nums.end()); return; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-89-Gray-Code.html":{"url":"Leetcode-89-Gray-Code.html","title":"Gray Code","keywords":"","body":"Question The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2 For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence. 00 - 0 10 - 2 11 - 3 01 - 1 Example 2: Input: 0 Output: [0] **Explanation:** We define the gray code sequence to begin with 0.A gray code sequence of _n_ has size = 2n, which for _n_ = 0 the size is 20 = 1. Therefore, for _n_ = 0 the gray code sequence is [0]. Difficulty:Medium Category:Backtracking Analyze 这到题目是关于格雷码的，难点也就是理解格雷码的转换过程。格雷码的转换过程可以如下图所示： 图片来自于：[LeetCode] Gray Code 格雷码 这个图片清晰的说明了格雷码的生成规律，随着n的变化，前面n-1之前就存在的项目都是在前面加上0,这些项目的数值是不会变化的，而后面的是和前面的对称相反的，所以在这里进行处理就可以得到完整的格雷码转换之后的vector了。 Solution class Solution { public: vector grayCode(int n) { vector res; res.emplace_back(0); for (int i = 0; i = 0; --j) { res.emplace_back(res[j] | 1 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-970-Powerful-Integers.html":{"url":"Leetcode-970-Powerful-Integers.html","title":"Powerful Integers","keywords":"","body":"Question Given two non-negative integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i >= 0 and j >= 0. Return a list of all powerful integers that have value less than or equal to bound. You may return the answer in any order. In your answer, each value should occur at most once. Example 1: Input: x = 2, y = 3, bound = 10 Output: [2,3,4,5,7,9,10] Explanation: 2 = 2^0 + 3^0 3 = 2^1 + 3^0 4 = 2^0 + 3^1 5 = 2^1 + 3^1 7 = 2^2 + 3^1 9 = 2^3 + 3^0 10 = 2^0 + 3^2 Example 2: Input: x = 3, y = 5, bound = 15 Output: [2,4,6,8,10,14] Note: 1 1 0 Difficulty:Easy Category:Math Solution class Solution { public: vector powerfulIntegers(int x, int y, int bound) { vector ans; unordered_set res; if (bound == 0) return ans; int m = 0, n = 0; if (x != 1) m = log(bound) / log(x); if (y != 1) n = log(bound) / log(y); for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-892-Surface-Area-of-3D-Shapes.html":{"url":"Leetcode-892-Surface-Area-of-3D-Shapes.html","title":"Surface Area of 3D Shapes","keywords":"","body":"Question On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes. Example 1: Input: [[2]] Output: 10 Example 2: Input: [[1,2],[3,4]] Output: 34 Example 3: Input: [[1,0],[0,2]] Output: 16 Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32 Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46 Note: 1 0 Difficulty:Medium Category:Math, Geometry Solution // Running time: 8 ms class Solution { public: int surfaceArea(vector>& grid) { static const vector dirs{0, -1, 0, 1, 0}; int m = grid.size(); int n = grid[0].size(); int ans = 0; for (int i = 0; i = n || ty = m) continue; int th = grid[ty][tx]; ans -= (th Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-949-Largest-Time-for-Given-Digits.html":{"url":"Leetcode-949-Largest-Time-for-Given-Digits.html","title":"Largest Time for Given Digits","keywords":"","body":"Question Given an array of 4 digits, return the largest 24 hour time that can be made. The smallest 24 hour time is 00:00, and the largest is 23:59. Starting from 00:00, a time is larger if more time has elapsed since midnight. Return the answer as a string of length 5. If no valid time can be made, return an empty string. Example 1: Input: [1,2,3,4] Output: \"23:41\" Example 2: Input: [5,5,5,5] Output: \"\" Note: A.length == 4 0 Difficulty:Easy Category:Math Solution class Solution { public: string largestTimeFromDigits(vector& A) { vector temp(10, 0); for (int i : A) temp[i]++; for (int h = 23; h >= 0; --h) { for (int m = 59; m >= 0; --m) { vector rec = temp; int h1 = h / 10, h2 = h % 10; int m1 = m / 10, m2 = m % 10; if (rec[h1] > 0) rec[h1]--; if (rec[h2] > 0) rec[h2]--; if (rec[m1] > 0) rec[m1]--; if (rec[m2] > 0) rec[m2]--; if (rec == vector(10, 0)) return to_string(h1) + to_string(h2) + \":\" + to_string(m1) + to_string(m2); } } return \"\"; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-914-X-of-a-Kind-in-a-Deck-of-Cards.html":{"url":"Leetcode-914-X-of-a-Kind-in-a-Deck-of-Cards.html","title":"X of a Kind in a Deck of Cards","keywords":"","body":"Question In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where: Each group has exactly X cards. All the cards in each group have the same integer. Example 1: Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4] Example 2: Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition. Example 3: Input: [1] Output: false Explanation: No possible partition. Example 4: Input: [1,1] Output: true Explanation: Possible partition [1,1] Example 5: Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2] Note: 1 0 Difficulty:Easy Category:Array, Math Solution // Runtimes: 20ms class Solution { public: bool hasGroupsSizeX(vector& deck) { unordered_map rec; for (int i : deck) rec[i]++; for (int i = 2; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-908-Smallest-Range-I.html":{"url":"Leetcode-908-Smallest-Range-I.html","title":"Smallest Range I","keywords":"","body":"Question Given an array A of integers, for each integer A[i] we may choose any x with -K , and add xto A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B. Example 1: Input: A = [1], K = 0 Output: 0 Explanation: B = [1] Example 2: Input: A = [0,10], K = 2 Output: 6 Explanation: B = [2,8] Example 3: Input: A = [1,3,6], K = 3 Output: 0 Explanation: B = [3,3,3] or B = [4,4,4] Note: 1 0 0 Difficulty:Easy Category:Math Analyze 这道题目的输入是一个整数的集合以及一个目标数值k,要求对于A[i]的任何一个元素，我们都可以选择一个-K 的整数，并將藏歌整数加入到这个集合里面去，找到每一项中加入的数值的最大值和最小值的最小差。(其实就是向中间值靠拢) Solution // Solution: // Runtime: 20ms class Solution { public: int smallestRangeI(vector& A, int K) { int ma = *std::max_element(A.begin(), A.end()); int mi = *std::min_element(A.begin(), A.end()); return max(0, ma - mi - 2 * K); } }; 稍微修改一下： // Solution: // Runtime: 20ms class Solution { public: int smallestRangeI(vector& A, int K) { int ma = 0, mi = INT_MAX; for (int& i : A) { ma = max(ma, i); mi = min(mi, i); } return max(0, ma - mi - 2 * K); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-172-Factorial-Trailing-Zeroes.html":{"url":"Leetcode-172-Factorial-Trailing-Zeroes.html","title":"Factorial Trailing Zeroes","keywords":"","body":"Question Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Difficulty:Easy Category:Math Solution class Solution { public: int trailingZeroes(int n) { if (n Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-66-Plus-One.html":{"url":"Leetcode-66-Plus-One.html","title":"Plus One","keywords":"","body":"Question Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Difficulty:Easy Category:Array, Math Analyze 这道题目是给一个数字的容器，每个位置放了一个数字，然后让你将这个容器的最小位 + 1之后，处理进位操作之后，输出出来，我们只需要判断最低位是否为9，如果为9，那么就处理进位操作，如果不为9，那么就加1之后直接输出出来即可。 Solution class Solution { public: vector plusOne(vector& digits) { int len = digits.size(); for (int i = len - 1; i >= 0; i--) { if (digits[i] == 9) digits[i] = 0; else { digits[i] += 1; return digits; } } if (digits.front() == 0) digits.insert(digits.begin(), 1); return digits; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-976-Largest-Perimeter-Triangle.html":{"url":"Leetcode-976-Largest-Perimeter-Triangle.html","title":"Largest Perimeter Triangle","keywords":"","body":"Question Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths. If it is impossible to form any triangle of non-zero area, return 0. Example 1: Input: [2,1,2] Output: 5 Example 2: Input: [1,2,1] Output: 0 Example 3: Input: [3,2,3,4] Output: 10 Example 4: Input: [3,6,2,3] Output: 8 Note: 3 1 Difficulty:Easy Category:Array, Math Solution class Solution { public: int largestPerimeter(vector& A) { sort(A.begin(), A.end(), greater()); for (int i = 2; i A[i - 2]) return A[i] + A[i - 1] + A[i - 2]; } return 0; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-461-Hamming-Distance.html":{"url":"Leetcode-461-Hamming-Distance.html","title":"Hamming Distance","keywords":"","body":"Question The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. **Note:** 0 ≤ `x`, `y` The above arrows point to positions where the corresponding bits are different. Difficulty:Medium Category:Bit-Manipulation Solution Solution 1 对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。 class Solution { public: int hammingDistance(int x, int y) { int c = x ^ y, ans = 0; while (c > 0) { ans += c & 1; c = c >> 1; } return ans; } }; Solution 2 使用 z&(z-1) 去除 z 位级表示最低的那一位。 class Solution { public: int hammingDistance(int x, int y) { int c = x ^ y, ans = 0; while (c > 0) { c &= (c - 1); ++ans; } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-389-Find-the-Difference.html":{"url":"Leetcode-389-Find-the-Difference.html","title":"Find the Difference","keywords":"","body":"Question Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: Input: s = \"abcd\" t = \"abcde\" Output: e Explanation: 'e' is the letter that was added. Difficulty:Easy Category:Hash-Table, Bit-Manipulation Solution class Solution { public: char findTheDifference(string s, string t) { unordered_map m_; for (char& c : s) ++m_[c]; for (char& c : t) if (--m_[c] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-190-Reverse-Bits.html":{"url":"Leetcode-190-Reverse-Bits.html","title":"Reverse Bits","keywords":"","body":"Question Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001. Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825. Follow up: If this function is called many times, how would you optimize it? Difficulty:Easy Category:Bit-Manipulation Solution 后来看了看发现根本不需要这么麻烦，直接进行位移运算，因为是要翻转过来，所以一边向右位移输入的数字，一边根据右移后原数字跟1的与操作结果来将结果数字左移，最后直接返回就完了，完全不需要转成二进制又转回来，都是一样的。 不过这里要注意右移时要使用无符号右移。 class Solution { public: uint32_t reverseBits(uint32_t n) { int ans = 0; for (int i = 0; i >= 1; if (i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-231-Power-of-Two.html":{"url":"Leetcode-231-Power-of-Two.html","title":"Power of Two","keywords":"","body":"Question Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true Explanation: 20 = 1 Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false Difficulty:Easy Category:Math, Bit-Manipulation Solution class Solution { public: bool isPowerOfTwo(int n) { bitset bit(n); return n > 0 && bit.count() == 1; } }; Solution 2 class Solution { public: bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-342-Power-of-Four.html":{"url":"Leetcode-342-Power-of-Four.html","title":"Power of Four","keywords":"","body":"Question Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: Input: 16 Output: true Example 2: Input: 5 Output: false Follow up: Could you solve it without loops/recursion? Difficulty:Easy Category:Bit-Manipulation Solution class Solution { public: bool isPowerOfFour(int num) { int temp = 0b01010101010101010101010101010101; return num > 0 && (num & (num - 1)) == 0 && (num & temp) != 0; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-693-Binary-Number-with-Alternating-Bits.html":{"url":"Leetcode-693-Binary-Number-with-Alternating-Bits.html","title":"Binary Number with Alternating Bits","keywords":"","body":"Question Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: Input: 5 Output: True Explanation: The binary representation of 5 is: 101 Example 2: Input: 7 Output: False Explanation: The binary representation of 7 is: 111. Example 3: Input: 11 Output: False Explanation: The binary representation of 11 is: 1011. Example 4: Input: 10 Output: True Explanation: The binary representation of 10 is: 1010. Difficulty:Medium Category:Bit-Manipulation Analyze 这个对于中间分割数据, 相同的两位不一样的情况下, 数据 n 和 n >> 1求异或的话, 就可以得到全为 11111111 的数据, 我们只要判断得到的数所有位都是1就可以了. Solution class Solution { public: bool hasAlternatingBits(int n) { int a = (n ^ (n >> 1)); if (a == INT_MAX) return true; return (a & long(a + 1)) == 0; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-476-Number-Complement.html":{"url":"Leetcode-476-Number-Complement.html","title":"Number Complement","keywords":"","body":"Question Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. Example 1: Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Difficulty:Easy Category:Bit-Manipulation Analyze This idea is come from the leetcode discuss. The actual process for the solution like: num = 00000101 mask = 11111000 mask ^ num = 11111101 ~(mask ^ num) = 00000010 Solution class Solution { public: int findComplement(int num) { int mask = ~0; int bit = 0; while (mask & num) mask &= ~(1 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-371-Sum-of-Two-Integers.html":{"url":"Leetcode-371-Sum-of-Two-Integers.html","title":"Sum of Two Integers","keywords":"","body":"Question Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example 1: Input: a = 1, b = 2 Output: 3 Example 2: Input: a = -2, b = 3 Output: 1 Difficulty:Medium Category:Bit-Manipulation Analyze Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-318-Maximum-Product-of-Word-Lengths.html":{"url":"Leetcode-318-Maximum-Product-of-Word-Lengths.html","title":"Maximum Product of Word Lengths","keywords":"","body":"Question Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: Input: [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"] Output: 16 **Explanation:** The two words can be \"abcw\", \"xtfn\". Example 2: Input: [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"] Output: 4 **Explanation:** The two words can be \"ab\", \"cd\". Example 3: Input: [\"a\",\"aa\",\"aaa\",\"aaaa\"] Output: 0 **Explanation:** No such pair of words. Difficulty:Medium Category:Bit-Manipulation Analyze 题目描述：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。 本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。 Solution class Solution { public: int maxProduct(vector& words) { int n = words.size(); vector v(n, 0); for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-338-Counting-Bits.html":{"url":"Leetcode-338-Counting-Bits.html","title":"Counting Bits","keywords":"","body":"Question Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ numcalculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. Difficulty:Medium Category: Solution Solution 1 class Solution { public: vector countBits(int num) { vector ans(num + 1, 0); bitset bit(0); for (int i = 0; i Solution 2 对于数字 6(110)，它可以看成是 4(100) 再加一个 2(10)，因此 dp[i] = dp[i & (i-1)] + 1. class Solution { public: vector countBits(int num) { vector ans(num + 1, 0); for (int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-445-Add-Two-Numbers-II.html":{"url":"Leetcode-445-Add-Two-Numbers-II.html","title":"Add Two Numbers II","keywords":"","body":"Question You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 8 -> 0 -> 7 Difficulty:Medium Category:Linked-List Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-347-Top-K-Frequent-Elements.html":{"url":"Leetcode-347-Top-K-Frequent-Elements.html","title":"Top K Frequent Elements","keywords":"","body":"Question Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. Difficulty:Medium Category:Bubble Sort Solution Solution 1: 桶排序 // Bucket sort // Runtime: 12ms > 99.14% class Solution { public: vector topKFrequent(vector& nums, int k) { vector ans; unordered_map m_; int max_freq = 1; for (int& num : nums) max_freq = max(++m_[num], max_freq); map> bucket; for (auto& val : m_) bucket[val.second].emplace_back(val.first); // Find the Top K frequent elements for (int i = max_freq; i >= 1; --i) { if (bucket.find(i) != bucket.end()) { ans.insert(ans.end(), bucket[i].begin(), bucket[i].end()); if (ans.size() == k) return ans; } else continue; } return ans; } }; Solution 2: Quick Sort // Bucket sort // Runtime: 12ms > 99.14% class Solution { public: vector topKFrequent(vector& nums, int k) { vector ans; unordered_map m_; for (int& num : nums) ++m_[num]; priority_queue> q; for (auto& val : m_) { q.emplace(-val.second, val.first); if (q.size() > k) q.pop(); } // Find the Top K frequent elements while (k--) { ans.emplace_back(q.top().second); q.pop(); } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-451-Sort-Characters-By-Frequency.html":{"url":"Leetcode-451-Sort-Characters-By-Frequency.html","title":"Sort Characters By Frequency","keywords":"","body":"Question Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: \"tree\" Output: \"eert\" Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer. Example 2: Input: \"cccaaa\" Output: \"cccaaa\" Explanation: Both 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer. Note that \"cacaca\" is incorrect, as the same characters must be together. Example 3: Input: \"Aabb\" Output: \"bbAa\" Explanation: \"bbaA\" is also a valid answer, but \"Aabb\" is incorrect. Note that 'A' and 'a' are treated as two different characters. Difficulty:Medium Category: Hash-Table, Heap Solution Solution 1: Bubble Sort // Bubble Sort // Runtime: 12ms > 87.28% class Solution { public: string frequencySort(string s) { unordered_map m_; for (char c : s) ++m_[c]; priority_queue> q; for (auto& val : m_) q.emplace(val.second, val.first); string ans; int len = s.length() - 1; while (q.size()) { for (int i = q.top().first; i > 0; --i) { ans += q.top().second; } q.pop(); } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-215-Kth-Largest-Element-in-an-Array.html":{"url":"Leetcode-215-Kth-Largest-Element-in-an-Array.html","title":"Kth Largest Element in an Array","keywords":"","body":"Question Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:You may assume k is always valid, 1 ≤ k ≤ array's length. Difficulty:Medium Category: Analyze 这道题目是要求找到 k-th Largest Element in An Array, 可以考虑使用堆排序. Leetcode Discuss: C++ STL, partition and heapsort Solution Solution 1: Sort 时间复杂度 $O(n log n)$, 空间复杂度 $O(1)$ class Solution { public: int findKthLargest(vector& nums, int k) { sort(nums.begin(), nums.end()); return nums[nums.size() - k]; } }; Solution 2: Heap Sort 排序 ：时间复杂度 O(nlog n)，空间复杂度 O(N) class Solution { public: int findKthLargest(vector& nums, int k) { priority_queue p; for (int& i : nums) p.push(i); while (--k) p.pop(); return p.top(); } }; 稍作修改: Max-heap -- Using Priority_queue class Solution { public: int findKthLargest(vector& nums, int k) { priority_queue pq(nums.begin(), nums.end()); while (--k) p.pop(); return pq.top(); } }; min-heap using priority_queue class Solution { public: int findKthLargest(vector& nums, int k) { priority_queue, greater> pq; for (int num : nums) { pq.push(num); if (pq.size() > k) { pq.pop(); } } return pq.top(); } }; min-heap using multiset class Solution { public: int findKthLargest(vector& nums, int k) { multiset mset; for (int num : nums) { mset.insert(num); if (mset.size() > k) { mset.erase(mset.begin()); } } return *mset.begin(); } }; max-heap using multiset class Solution { public: int findKthLargest(vector& nums, int k) { multiset> mset(nums.begin(), nums.end()); for (int i = 0; i Solution 3: Heap Sort 排序 ：时间复杂度 O(nlog n)，空间复杂度 O(N) class Solution { public: int findKthLargest(vector& nums, int k) { priority_queue p; for (int& i : nums) p.push(i); while (--k) p.pop(); return p.top(); } }; Solution 3: QuickSort class Solution { public: int findKthLargest(vector& nums, int k) { k = nums.size() - k; int left = 0, right = nums.size() - 1; while (left & nums, int b, int e) { if (b = nums[b] && lb Use STL Function: class Solution { public: int findKthLargest(vector& nums, int k) { nth_element(nums.begin(), nums.begin() + k - 1, nums.end(), greater()); return nums[k - 1]; } }; class Solution { public: int findKthLargest(vector& nums, int k) { partial_sort(nums.begin(), nums.begin() + k, nums.end(), greater()); return nums[k - 1]; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-88-Merge-Sorted-Array.html":{"url":"Leetcode-88-Merge-Sorted-Array.html","title":"Merge Sorted Array","keywords":"","body":"Leetcode 88. Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Difficulty:Easy Category:Array, Two Pointers Solution Solution1: Two Points 混合插入有序数组，由于两个数组都是有序的，所有只要按顺序比较大小即可。 Time complexity: O(m + n) Space complexity: O(m + n) class Solution { public: void merge(vector& nums1, int m, vector& nums2, int n) { if (n == 0) return; vector temp = nums1; int p = 0, q = 0; for (int i = 0; i = nums2[q] || p == m ? nums2[q++] : temp[p++]; } }; Solution2: Two Points Fill nums1 from back to front Time complexity: O(m + n) Space complexity: O(1) in-place class Solution { public: void merge(vector& nums1, int m, vector& nums2, int n) { int p = m - 1, q = n - 1, tail = m + n - 1; while (q >= 0) nums1[tail--] = (p >= 0 && nums1[p] >= nums2[q]) ? nums1[p--] : nums2[q--]; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-21-Merge-Two-Sorted-Lists.html":{"url":"Leetcode-21-Merge-Two-Sorted-Lists.html","title":"Merge Two Sorted Lists","keywords":"","body":"Leetcode 21. Merge Two Sorted Lists Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1->2->4, 1->3->4Output: 1->1->2->3->4->4 Difficulty:Easy Category:Linked-List Solution 这道混合插入有序链表和我之前那篇混合插入有序数组非常的相似Merge Sorted Array，仅仅是数据结构由数组换成了链表而已，代码写起来反而更简洁。具体思想就是新建一个链表，然后比较两个链表中的元素值，把较小的那个链到新链表中，由于两个输入链表的长度可能不同，所以最终会有一个链表先完成插入所有元素，则直接另一个未完成的链表直接链入新链表的末尾。 Solution 1: Iterative Time complexity: O(n) Space complexity: O(1) in-place Runtime: 12 ms, faster than 100.00% of C++ online submissions for Merge Two Sorted Lists. Memory Usage: 9.9 MB, less than 90.59% of C++ online submissions for Merge Two Sorted Lists. class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *mergelist = new ListNode(-1), *cur = mergelist; while (l1 && l2) { if (l1->val val) { cur->next = l1; l1 = l1->next; } else { cur->next = l2; l2 = l2->next; } cur = cur->next; } cur->next = l1 ? l1 : l2; return mergelist->next; } }; Solution 2: Recursive 递归的写法，当某个链表为空了，就返回另一个。然后核心还是比较当前两个节点值大小，如果l1的小，那么对于l1的下一个节点和l2调用递归函数，将返回值赋值给l1.next，然后返回l1；否则就对于l2的下一个节点和l1调用递归函数，将返回值赋值给l2.next，然后返回l2 Time complexity: O(n) Space complexity: O(n) Runtime: 12 ms, faster than 100.00% of C++ online submissions for Merge Two Sorted Lists. Memory Usage: 10.3 MB, less than 11.45% of C++ online submissions for Merge Two Sorted Lists. class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { // If one of the list is emptry, return the other one. if (!l1 || !l2) return l1 ? l1 : l2; // The smaller one becomes the head. if (l1->val val) { l1->next = mergeTwoLists(l1->next, l2); return l1; } else { l2->next = mergeTwoLists(l1, l2->next); return l2; } } }; 对上述的代码可以做一些精简： class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if (!l1 || (l2 && l1->val > l2->val)) swap(l1, l2); if (l1) l1->next = mergeTwoLists(l1->next, l2); return l1; } }; 另外一种解法 // Merge Two Sorted Lists (LeetCode) ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode dummy(-1); ListNode *p = l1, *q = l2, *r = &dummy; while (p && q) { if (p->val val) { r->next = p; r = p; p = p->next; } else { r->next = q; r = q; q = q->next; } } r->next = (p ? p : q); return dummy.next; } Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-274-H-Index.html":{"url":"Leetcode-274-H-Index.html","title":"H Index","keywords":"","body":"Question Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\" Note: If there are several possible values for h, the maximum one is taken as the h-index. Difficulty:Medium Category:Hash-Table, Sort Analyze 可以按照如下方法确定某人的H指数： 将其发表的所有SCI论文按被引次数从高到低排序； 从前往后查找排序后的列表，直到某篇论文的序号大于该论文被引次数。所得序号减一即为H指数。 Solution class Solution { public: int hIndex(vector& citations) { // For example: [3,0,6,1,5] ---> [6,5,3,1,0] // More than i paper bigger than the value; sort(citations.begin(), citations.end(), greater()); for (int i = 0; i = citations[i]) return i; } return citations.size(); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-275-H-Index-II.html":{"url":"Leetcode-275-H-Index-II.html","title":"H Index II","keywords":"","body":"Question Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\" Note: If there are several possible values for h, the maximum one is taken as the h-index. Follow up: This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order. Could you solve it in logarithmic time complexity? Difficulty:Medium Category:Array Solution class Solution { public: int hIndex(vector& citations) { int len_c = citations.size(), left = 0, right = len_c - 1; while (left len_c - mid_c) { right = mid_c - 1; } else { left = mid_c + 1; } } return len_c - left; } }; Solution 2: Line Scan class Solution { public: int hIndex(vector& citations) { vector& c = citations; for (int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-242-Valid-Anagram.html":{"url":"Leetcode-242-Valid-Anagram.html","title":"Valid Anagram","keywords":"","body":"Question Given two strings s and t , write a function to determine if t is an anagram of s. Example 1: Input: s = \"anagram\", t = \"nagaram\" Output: true Example 2: Input: s = \"rat\", t = \"car\" Output: false Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? Difficulty:Easy Category:Sort, Hash-Table Solution class Solution { public: bool isAnagram(string s, string t) { if (s.length() != t.length()) return false; int count[26] = {0}; for (char c : s) count[c - 'a']++; for (char c : t) count[c - 'a']--; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-905-Sort-Array-By-Parity.html":{"url":"Leetcode-905-Sort-Array-By-Parity.html","title":"Sort Array By Parity","keywords":"","body":"Question Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition. Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Note: 1 0 Difficulty:Easy Category:Array Solution class Solution { public: vector sortArrayByParity(vector& A) { int left = 0, right = A.size() - 1; while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-922-Sort-Array-By-Parity-II.html":{"url":"Leetcode-922-Sort-Array-By-Parity-II.html","title":"Sort Array By Parity II","keywords":"","body":"Question Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition. Example 1: Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. Note: 2 A.length % 2 == 0 0 Difficulty:Easy Category:Array, Sort Solution Solution 2 (Error: Memory Limit Exceeded) class Solution { public: vector sortArrayByParityII(vector& A) { vector odd_vec, even_vec, res_vec; for (auto i : A) { if (i & 1) odd_vec.emplace_back(i); else even_vec.emplace_back(i); } for (int i = 0; i Solution 2 class Solution { public: vector sortArrayByParityII(vector& A) { int odd = 1, even = 0, len = A.size(); while (odd Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-283-Move-Zeroes.html":{"url":"Leetcode-283-Move-Zeroes.html","title":"Move Zeroes","keywords":"","body":"Question Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Difficulty:Medium Category:Array, Two Points Solution 把非零数前移，要求不能改变非零数的相对应的位置关系，而且不能拷贝额外的数组，那么只能用替换法in-place来做，需要用两个指针，一个不停的向后扫，找到非零位置，然后和前面那个指针交换位置即可，参见下面的代码： Time complexity: O(n), Space complexity: O(1) class Solution { public: void moveZeroes(vector& nums) { int left = 0, right = 0; for (; right Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-771-Jewels-and-Stones.html":{"url":"Leetcode-771-Jewels-and-Stones.html","title":"Jewels and Stones","keywords":"","body":"Question You're given strings J representing the types of stones that are jewels, and Srepresenting the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\". Example 1: Input: J = \"aA\", S = \"aAAbbbb\" Output: 3 Example 2: Input: J = \"z\", S = \"ZZ\" Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. Difficulty:Easy Category:Hash-Table Solution class Solution { public: int numJewelsInStones(string J, string S) { int ans = 0; unordered_map rec; for (char c : J) rec.insert({c, 1}); for (char c : S) { if (rec[c] == 1) ans++; } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-75-Sort-Colors.html":{"url":"Leetcode-75-Sort-Colors.html","title":"Sort Colors","keywords":"","body":"Question Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space? Difficulty:Medium Category:Array, Two-Points, Sort Solution Solution 1 class Solution { public: void sortColors(vector& nums) { int count[3] = {0}; for (auto i : nums) count[i]++; for (int i = 0, index = 0; i Solution 2: 颜色问题, 分成三个部分排序 class Solution { public: void sortColors(vector& nums) { int left = -1, mid = 0, right = nums.size(); while (mid Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-969-Pancake-Sorting.html":{"url":"Leetcode-969-Pancake-Sorting.html","title":"Pancake Sorting","keywords":"","body":"Question Given an array A, we can perform a pancake flip: We choose some positive integer **k** , then reverse the order of the first k elements of A. We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A. Return the k-values corresponding to a sequence of pancake flips that sort A. Any valid answer that sorts the array within 10 * A.length flips will be judged as correct. Example 1: Input: [3,2,4,1] Output: [4,2,4,3] Explanation: We perform 4 pancake flips, with k values 4, 2, 4, and 3. Starting state: A = [3, 2, 4, 1] After 1st flip (k=4): A = [1, 4, 2, 3] After 2nd flip (k=2): A = [4, 1, 2, 3] After 3rd flip (k=4): A = [3, 2, 1, 4] After 4th flip (k=3): A = [1, 2, 3, 4], which is sorted. Example 2: Input: [1,2,3] Output: [] Explanation: The input is already sorted, so there is no need to flip anything. Note that other answers, such as [3, 3], would also be accepted. Note: 1 A[i] is a permutation of [1, 2, ..., A.length] Difficulty:Medium Category:Array, Sort Solution class Solution { public: vector pancakeSort(vector& A) { vector ans; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-767-Reorganize-String.html":{"url":"Leetcode-767-Reorganize-String.html","title":"Reorganize String","keywords":"","body":"Question Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result. If not possible, return the empty string. Example 1: Input: S = \"aab\" Output: \"aba\" Example 2: Input: S = \"aaab\" Output: \"\" Note: S will consist of lowercase letters and have length in range [1, 500]. Difficulty:Medium Category:String, Heap, Greedy, Sort Analyze 在这道题中考虑使用堆排序, 处理步骤如下: 使用vector v_(26, 0)记录每一个字符出现的次数. 使用priority_queue对得到的结果进行排序, 在这里可以进行剪枝, 如果其中某一个元素的个数超过了总的字符长度的一半,那就说明这个没有办法按照题目的要求给出输出, 在这里返回去空字符串. 当我们得到字符分别个数的排序之后, 我们使用一个队列, 每次到priority_queue 里面去得到当前最大个素的字母,然后將这个字母加载到ans里面. 再将其个数减少一, 然后将其推入到队列中, 当队列中的个数超过两个之后, 就处理队列, 將队里中的字母在推入priority_queue里面去重新排序,这样就可以实现字符分开的要求了. Solution Solution 1: 堆排序 class Solution { public: string reorganizeString(string S) { string ans; int n = S.length(); vector v_(26, 0); for (char& c : S) v_[c - 'a']++; // Sort the date in the priority_queue priority_queue> q_; for (int i = 0; i (n + 1) / 2) return \"\"; if (v_[i]) q_.push({v_[i], i + 'a'}); } // Deal with two elements each tiem queue> r_; while (!q_.empty() || r_.size() > 1) { // r_.size() > 1; if (r_.size() > 1) { auto cur = r_.front(); r_.pop(); if (cur.first > 0) q_.push(cur); } if (!q_.empty()) { auto cur = q_.top(); q_.pop(); ans += cur.second; cur.first--; r_.push(cur); } } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-164-Maximum-Gap.html":{"url":"Leetcode-164-Maximum-Gap.html","title":"Maximum Gap","keywords":"","body":"Question Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2: Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. Difficulty:Hard Category:Sort Solution class Solution { public: int maximumGap(vector& nums) { if (nums.size() , greater> pq; for (int num : nums) pq.push(num); int ans = 0; int pre = pq.top(); pq.pop(); for (int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-324-Wiggle-Sort-II.html":{"url":"Leetcode-324-Wiggle-Sort-II.html","title":"Wiggle Sort II","keywords":"","body":"Question Given an unsorted array nums, reorder it such that nums[0] nums[2] . Example 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2]. Note:You may assume all input has valid answer. Follow Up:Can you do it in O(n) time and/or in-place with O(1) extra space? Difficulty:Medium Category:Sort https://leetcode.com/problems/wiggle-sort-ii/ Solution class Solution { public: void wiggleSort(vector& nums) { vector temp = nums; sort(temp.begin(), temp.end()); int n = nums.size(); int left = (n + 1) / 2, right = n; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-710-Random-Pick-with-Blacklist.html":{"url":"Leetcode-710-Random-Pick-with-Blacklist.html","title":"Random Pick with Blacklist","keywords":"","body":"Question Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B. Optimize it such that it minimizes the call to system’s Math.random(). Note: 1 0 [0, N) does NOT include N. See interval notation). Example 1: Input: [\"Solution\",\"pick\",\"pick\",\"pick\"] [[1,[]],[],[],[]] Output: [null,0,0,0] Example 2: Input: [\"Solution\",\"pick\",\"pick\",\"pick\"] [[2,[]],[],[],[]] Output: [null,1,1,1] Example 3: Input: [\"Solution\",\"pick\",\"pick\",\"pick\"] [[3,[1]],[],[],[]] Output: [null,0,0,2] Example 4: Input: [\"Solution\",\"pick\",\"pick\",\"pick\"] [[4,[2]],[],[],[]] Output: [null,1,3,1] Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, N and the blacklist B. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any. Difficulty:Hard Category:Sort Solution class Solution { public: Solution(int N, vector blacklist) { n = N; blackset = unordered_set(blacklist.begin(), blacklist.end()); whitelist = vector(); if (blacklist.size() > N / 2) for (int i = 0; i whitelist; unordered_set blackset; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-57-Insert-Interval.html":{"url":"Leetcode-57-Insert-Interval.html","title":"Insert Interval","keywords":"","body":"Question Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Difficulty:Medium Category: Solution class Solution { public: vector insert(vector& vals, Interval newVal) { vector ans; int index = 0; for (auto& v : vals) { if (v.end newVal.end) { ans.emplace_back(v); } else { newVal.start = min(newVal.start, v.start); newVal.end = max(newVal.end, v.end); } } ans.insert(ans.begin() + index, newVal); return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-56-Merge-Intervals.html":{"url":"Leetcode-56-Merge-Intervals.html","title":"Merge Intervals","keywords":"","body":"Leetcode 56. Merge Intervals Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Difficulty:Medium Category:Array, Sort Analyze 一开始,我使用两重循环的方式来解决这个问题,但是很耗时间,需要考虑使用其他的方式(solution 1). 根据博客:花花酱 LeetCode 56. Merge Intervals 进行优化,先按照start数值的大小进行排序. Solution Solution 1: 暴力枚举的方式 Time complexity: O(n^2) Space complexity: O(n) // Runtime: 44ms (> 8.37%) class Solution { public: vector merge(vector& vals) { if (vals.empty()) return {}; for (int j = 0; j Solution 2: 先排序, Lamda function 我们首先给区间集排序，由于我们要排序的是个结构体，所以我们要定义自己的comparator，才能用sort来排序，我们以 start 的值从小到大来排序，排完序我们就可以开始合并了，首先把第一个区间存入结果中，然后从第二个开始遍历区间集，如果结果中最后一个区间和遍历的当前区间无重叠，直接将当前区间存入结果中，如果有重叠，将结果中最后一个区间的 end值更新为结果中最后一个区间的end和当前end值之中的较大值，然后继续遍历区间集，以此类推可以得到最终结果 Time complexity: O(n log n) Space complexity: O(n) class Solution { public: vector merge(vector& vals) { if (vals.empty()) return {}; sort(vals.begin(), vals.end(), [](Interval& a, Interval& b) { return a.start ans{vals[0]}; for (int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-986-Interval-List-Intersections.html":{"url":"Leetcode-986-Interval-List-Intersections.html","title":"Interval List Intersections","keywords":"","body":"Question Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a ) denotes the set of real numbers x with a . The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].) Example 1: Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists. Note: 0 0 0 Difficulty:Medium Category: Solution class Solution { public: vector intervalIntersection(vector& A, vector& B) { vector ans; int i = 0, j = 0; while (i = start) ans.emplace_back(Interval(start, end)); if (A[i].end Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-34-Find-First-And-Last-Position-Of-Element-In-Sorted-Array.html":{"url":"Leetcode-34-Find-First-And-Last-Position-Of-Element-In-Sorted-Array.html","title":"Find First And Last Position Of Element In Sorted Array(LC.34)","keywords":"","body":"Question Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Difficulty:Medium Category:Array, Binary-Search Solution Solution 1: Binary Search 在第一个　Binary Search 里面，　寻找　lower bound 的时候，有两种情况： 如果目标数字比数组中所有数值都要大，那么　Left 指针会一直移动到超出数组索引 如果目标数字比数组中所有数字都要小的话，　那么，right指针会一直移动到０的位置 所以在这个位置的去数值要比较特殊：如果使用的是：int left = 0, right = nums.size();, 那么在使用left or right进行索引的时候，　一定要判断是否超出索引。 class Solution { public: vector searchRange(vector& nums, int target) { vector res(2, -1); int left = 0, right = nums.size() - 1; while (left Solution 2: DFS class Solution { public: vector searchRange(vector& nums, int target) { vector res = {-1, -1}; int index_x = search(nums, target); if (index_x == -1) return res; int index_left = index_x, index_right = index_x; while (index_left && nums[index_left - 1] == target) index_left--; while (index_right & nums, int target) { int left = 0, right = nums.size(); while (left != right) { const int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; if (nums[left] target) { right = mid; } else { left = mid + 1; } } else if (nums[left] == nums[mid]) { left++; } else { if (nums[mid] = target) { left = mid + 1; } else { right = mid; } } } return -1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-35-Search-Insert-Position.html":{"url":"Leetcode-35-Search-Insert-Position.html","title":"Search Insert Position(LC.35)","keywords":"","body":"Question Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 Solution Solution 1: Binary Search class Solution { public: int searchInsert(vector& nums, int target) { if (nums.back() Solution 2: Scan class Solution { public: int searchInsert(vector& nums, int target) { if (nums.empty()) return 0; for (int i = 0; i = target) return i; } return nums.size(); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-744-Find-Smallest-Letter-Greater-Than-Target.html":{"url":"Leetcode-744-Find-Smallest-Letter-Greater-Than-Target.html","title":"Find Smallest Letter Greater Than Target","keywords":"","body":"Question Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target. Letters also wrap around. For example, if the target is target = 'z'and letters = ['a', 'b'], the answer is 'a'. Examples: Input: letters = [\"c\", \"f\", \"j\"] target = \"a\" Output: \"c\" Input: letters = [\"c\", \"f\", \"j\"] target = \"c\" Output: \"f\" Input: letters = [\"c\", \"f\", \"j\"] target = \"d\" Output: \"f\" Input: letters = [\"c\", \"f\", \"j\"] target = \"g\" Output: \"j\" Input: letters = [\"c\", \"f\", \"j\"] target = \"j\" Output: \"c\" Input: letters = [\"c\", \"f\", \"j\"] target = \"k\" Output: \"c\" Note: letters has a length in range [2, 10000]. letters consists of lowercase letters, and contains at least 2 unique letters. target is a lowercase letter. Difficulty:Easy Category:Binary-Search Solution Solution 1: Line Scan class Solution { public: char nextGreatestLetter(vector& letters, char target) { for (const char c : letters) if (c > target) return c; return letters.front(); } }; Solution 2: Binary Search class Solution { public: char nextGreatestLetter(vector& letters, char target) { int left = 0, right = letters.size(); while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-506-Relative-Ranks.html":{"url":"Leetcode-506-Relative-Ranks.html","title":"Relative Ranks","keywords":"","body":"Question Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\". Example 1: Input: [5, 4, 3, 2, 1] Output: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"] Explanation: The first three athletes got the top three highest scores, so they got \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".For the left two athletes, you just need to output their relative ranks according to their scores. Note: N is a positive integer and won't exceed 10,000. All the scores of athletes are guaranteed to be unique. Difficulty:Easy Category:Binary-Search Analyze 在这道题目中,给出了你一些人的分数,输入他们的排名, 前面三名使用Gold, Medal, Silver Medal, Bronze Medal替代,后面的输出排名的数字号码就好了. Solution class Solution { public: vector findRelativeRanks(vector& nums) { vector ans; vector s(nums); sort(s.begin(), s.end()); vector medals{\"Gold\", \"Silver\", \"Bronze\"}; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-704-Binary-Search.html":{"url":"Leetcode-704-Binary-Search.html","title":"Binary Search(LC.704)","keywords":"","body":"Leetcode 704. Binary Search Given a sorted (in ascending order) integer array nums of n elements and a targetvalue, write a function to search target in nums. If target exists, then return its index, otherwise return -1. Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 Note: You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999]. Difficulty:Medium Category: Solution Time complexity: O(log n) Space complexity: O(1) class Solution { public: int search(vector& nums, int target) { int left = 0, right = nums.size(); while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-981-Time-Based-Key-Value-Store.html":{"url":"Leetcode-981-Time-Based-Key-Value-Store.html","title":"Time Based Key Value Store(LC.981)","keywords":"","body":"Leetcode 981. Time Based Key Value Store Create a timebased key-value store class TimeMap, that supports two operations. set(string key, string value, int timestamp) Stores the key and value, along with the given timestamp. get(string key, int timestamp) Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev . If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string (\"\"). Example 1: Input: inputs = [\"TimeMap\",\"set\",\"get\",\"get\",\"set\",\"get\",\"get\"], inputs = [[],[\"foo\",\"bar\",1],[\"foo\",1],[\"foo\",3],[\"foo\",\"bar2\",4],[\"foo\",4],[\"foo\",5]] Output: [null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"] Explanation: TimeMap kv;kv.set(\"foo\", \"bar\", 1); // store the key \"foo\" and value \"bar\" along with timestamp = 1kv.get(\"foo\", 1); // output \"bar\"kv.get(\"foo\", 3); // output \"bar\" since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie \"bar\"kv.set(\"foo\", \"bar2\", 4);kv.get(\"foo\", 4); // output \"bar2\"kv.get(\"foo\", 5); //output \"bar2\" Example 2: Input: inputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"], inputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]] Output: [null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"] Note: All key/value strings are lowercase. All key/value strings have length in the range [1, 100] The timestamps for all TimeMap.set operations are strictly increasing. 1 TimeMap.set and TimeMap.get functions will be called a total of 120000times (combined) per test case. Difficulty:Medium Category: Solution Solution: HashTable + Map class TimeMap { public: /** Initialize your data structure here. */ TimeMap() {} void set(string key, string value, int timestamp) { s_[key].emplace(timestamp, std::move(value)); } string get(string key, int timestamp) { auto m = s_.find(key); if (m == s_.end()) return \"\"; auto it = m->second.upper_bound(timestamp); if (it == begin(m->second)) return \"\"; return prev(it)->second; } private: unordered_map> s_; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-69-Sqrt-x-3.html":{"url":"Leetcode-69-Sqrt-x-3.html","title":"Sqrt x 3(LC.69)","keywords":"","body":"Leetcode 69. Sqrt(x) Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Difficulty:Easy Category:Math, Binary-Search Solution Solution 1: Binary Search Time Complexity: O(log n), Space Complexity: O(1) class Solution { public: int mySqrt(int x) { if (x Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-33-Search-In-Rotated-Sorted-Array.html":{"url":"Leetcode-33-Search-In-Rotated-Sorted-Array.html","title":"Search In Rotated Sorted Array(LC.33)","keywords":"","body":"Leetcode 33. Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Solution Solution 1: Binary Search 二分查找, 确定左右边界, 如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了，代码如下： Time complexity: O(log n) Space complexity: O(1) class Solution { public: int search(vector& nums, int target) { int left = 0, right = nums.size(); while (left != right) { const int mid = left + (right - left) / 2; // Find the Target at the mid index. if (nums[mid] == target) return mid; // There are sorted elements in the left part. if (nums[left] target && nums[left] = target ? left = mid + 1 : right = mid; } } return -1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-81-Search-In-Rotated-Sorted-Array-II.html":{"url":"Leetcode-81-Search-In-Rotated-Sorted-Array-II.html","title":"Search In Rotated Sorted Array II(LC.81)","keywords":"","body":"Question Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? Solution Solution 1: Binary Search 现在数组中允许出现重复数字，这个也会影响我们选择哪半边继续搜索，由于之前那道题不存在相同值，我们在比较中间值和最右值时就完全符合之前所说的规律：如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的。而如果可以有重复值，就会出现来面两种情况，[3 1 1] 和 [1 1 3 1]，对于这两种情况中间值等于最右值时，目标值3既可以在左边又可以在右边，那怎么办么，对于这种情况其实处理非常简单，只要把最右值向左一位即可继续循环，如果还相同则继续移，直到移到不同值为止 Time complexity: O(logn) Space complexity: O(1) Runtime: 8 ms, faster than 100.00% of C++ online submissions for Search in Rotated Sorted Array II. Memory Usage: 8.9 MB, less than 14.56% of C++ online submissions for Search in Rotated Sorted Array II. class Solution { public: bool search(vector& nums, int target) { int left = 0, right = nums.size(); while (left != right) { const int mid = left + (right - left) / 2; // Find the Target at the mid index. if (nums[mid] == target) return true; // There are sorted elements in the left part. if (nums[left] target) { right = mid; } else { left = mid + 1; } } else if (nums[left] == nums[mid]) { left++; } else { // There are sorted elements in the right part. if (nums[mid] = target) { left = mid + 1; } else { right = mid; } } } return false; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array.html":{"url":"Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array.html","title":"Find Minimum in Rotated Sorted Array(LC.153))","keywords":"","body":"Leetcode 153. Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2] Output: 1 Example 2: Input: [4,5,6,7,0,1,2] Output: 0 Difficulty:Medium Category: Analyze 这道题目给的输入有两种情况，有可能输入是旋转有序数组，也有可能是没有旋转的有序输入，这个可以通过比较最后一个元素与第一个元素的大小来判断， 如果第一个元素比最后一个元素小，那就说明这个输入的数组并没有旋转。反之，则表示输入的是一个旋转数组。 Cite: 花花酱 Leetcode 153. Find Minimum in Rotated Sorted Array Solution Binary Search Time Complexity: O(log n), Space Complexity:O(1) class Solution { public: int findMin(vector& nums) { int left = 0, right = nums.size() - 1; if (nums[left] left value, then move the right part search. if (nums[mid] > nums[left]) left = mid; else right = mid; } return min(nums[left], nums[right]); } }; Solution 2: Divide and conquer Time complexity: T(n) = O(1) + T(n/2) = O(log n) class Solution { public: int findMin(vector& num) { return findMin(num, 0, num.size() - 1); } private: int findMin(const vector& num, int l, int r) { // Only 1 or 2 elements if (l + 1 >= r) return min(num[l], num[r]); // Sorted if (num[l] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II.html":{"url":"Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II.html","title":"Find Minimum in Rotated Sorted Array II(LC.154)","keywords":"","body":"Leetcode 154. Find Minimum in Rotated Sorted Array II Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note: This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why? Difficulty:Hard Category: Solution Solution 1: Binary Search class Solution { public: int findMin(vector& nums) { int left = 0, right = nums.size() - 1, ans = nums[0]; if (nums[left] left value, then move the right part search. if (nums[left] nums[mid]) right = mid; else ++left; } return min(ans, min(nums[left], nums[right])); } }; Solution 2: Divide and conquer cite: 花花酱 LeetCode 154. Find Minimum in Rotated Sorted Array II Time complexity: Average: O(log n) Worst: O(n) Space complexity: O(1) // Author: Huahua class Solution { public: int findMin(vector &num) { return findMin(num, 0, num.size()-1); } int findMin(const vector& num, int l, int r) { // One or two elements, solve it directly if (l+1 >= r) return min(num[l], num[r]); // Sorted if (num[l] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-162-Find-Peak-Element.html":{"url":"Leetcode-162-Find-Peak-Element.html","title":"Find Peak Element(LC.162)","keywords":"","body":"Question A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: Input: nums = [1,2,1,3,5,6,4] Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Note: Your solution should be in logarithmic complexity. Difficulty:Medium Category: Solution Solution 1: Line Scan 所谓峰值就是比周围两个数字都大的数字，那么只需要跟周围两个数字比较就可以了。既然要跟左右的数字比较，就得考虑越界的问题，题目中给了nums[-1] = nums[n] = -∞，那么我们其实可以把这两个整型最小值直接加入到数组中，然后从第二个数字遍历到倒数第二个数字，这样就不会存在越界的可能了。由于题目中说了峰值一定存在，那么有一个很重要的corner case. 对于数组中只有一个数字的情况在开头直接判断一下即可. Time complexity: O(n), Space complexity: O(1) class Solution { public: int findPeakElement(vector& nums) { if (nums.size() == 1) return 0; nums.insert(nums.begin(), INT_MIN); nums.push_back(INT_MIN); for (int i = 1; i nums[i - 1] && nums[i] > nums[i + 1]) return i - 1; } return -1; } }; class Solution { public: int findPeakElement(vector& nums) { int n = nums.size(); for (int i = 1; i Solution 2: Binary Search 题目要求是 O(log n) 的时间复杂度，考虑使用类似于二分查找法来缩短时间。由于只是需要找到任意一个峰值，那么我们在确定二分查找折半后中间那个元素后，和紧跟的那个元素比较下大小，如果大于，则说明峰值在前面，如果小于则在后面。这样就可以找到一个峰值了。 class Solution { public: int findPeakElement(vector& A) { // Binary Search int left = 0, right = A.size() - 1; while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-852-Peak-Index-in-a-Mountain-Array.html":{"url":"Leetcode-852-Peak-Index-in-a-Mountain-Array.html","title":"Peak Index in a Mountain Array(LC.852)","keywords":"","body":"Question Let's call an array A a mountain if the following properties hold: A.length >= 3 There exists some 0 such that A[0] A[i+1] > ... > A[A.length - 1] Given an array that is definitely a mountain, return any i such that A[0] A[i+1] > ... > A[A.length - 1]. Example 1: Input: [0,1,0] Output: 1 Example 2: Input: [0,2,1,0] Output: 1 Note: 3 0 A is a mountain, as defined above. Difficulty:Easy Category:Binary-Search Analyze 这是一道 easy 题目， 可以通过线扫描，找到最大的顶点数值， 也可以通过Binary Search 的方式在 log n 的时间内找到。 Solution Solution 1: Line Scan Time Complexity: O(n), Space Complexity: O(1) class Solution { public: int peakIndexInMountainArray(vector& A) { for (int i = 1; i Solution 2: Binary Search Time complexity: O(log n), Space Complexity: O(1) class Solution { public: int peakIndexInMountainArray(vector& A) { // Binary Search int left = 0, right = A.size(); while (left A[mid + 1]) right = mid; // For the left part else left = mid + 1; } return left; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-74-Search-a-2D-Matrix.html":{"url":"Leetcode-74-Search-a-2D-Matrix.html","title":"Search a 2D Matrix","keywords":"","body":"Question Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Difficulty:Medium Category:Array, Binary-Search Solution 这道题要求搜索一个二维矩阵，由于给的矩阵是有序, 可以考虑采用 Binary Search Solution: Binary Search Time complexity: O(log(row*col)), Space complexity: O(1) class Solution { public: bool searchMatrix(vector>& matrix, int target) { if (matrix.empty()) return false; if (target matrix.back().back()) return false; const int row = matrix.size(), col = matrix[0].size(); int left = 0, right = row * col; // Binary Search: No repeat elements. while (left Follow up 如果矩阵的每一行的行内是有序的，　但是每一行的数字并不能保证比前一行的最后一个元素大，但是对应列的元素比上一行是要大的。 [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Leetcode 240. Search a 2D Matrix II Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix.html":{"url":"Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix.html","title":"Kth Smallest Element in a Sorted Matrix(LC.378)","keywords":"","body":"Leetcode 378. Kth Smallest Element in a Sorted Matrix Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, return 13. Note:You may assume k is always valid, 1 ≤ k ≤ n2. Difficulty:Medium Category:Binary-Search, Heap Solution Cite:Kth Smallest Element in a Sorted Matrix 有序矩阵中第K小的元素 求有序矩阵中第K小的元素. 这道题中的矩阵并不是完全有序的，行之间可能并不有序，所以是当前行的最后一个元素并不一定会小于下一行的首元素。这就不能够简单的利用二叉搜索来求解了。但是可以使用变化的二叉搜索来求解。 由于矩阵左上角的数字一定是最小的，而右下角的数字一定是最大的，所以这个是我们搜索的范围，然后我们算出中间数字mid，由于矩阵中不同行之间的元素并不是严格有序的，所以我们要在每一行都查找一下mid，我们使用upper_bound，这个函数是查找第一个大于目标数的元素，如果目标数在比该行的尾元素大，则upper_bound返回该行元素的个数，如果目标数比该行首元素小，则upper_bound返回0, 我们遍历完所有的行可以找出中间数是第几小的数，然后k比较，进行二分查找，left和right最终会相等，并且会变成数组中第k小的数字 Solution 1: Binary Search Time complexity: O(n log(n) * log(max – min)), Space complexity: O(1) class Solution { public: int kthSmallest(vector>& matrix, int k) { int row = matrix.size(), col = matrix[0].size(); int left = matrix[0][0], right = matrix[matrix.size() - 1][matrix[0].size() - 1] + 1; while (left & A, int val) { int l = 0, r = A.size(); while (l val ? r = m : l = m + 1; } return l; } }; 在上面的代码里面，我们可以考虑使用STL提供的upper_bound函数，而不是自己去写。 cnt += upper_bound(x.begin(), x.end(), mid) - x.begin(); 或： cnt += (s = distance(begin(x), upper_bound(begin(x), begin(x) + s, mid))); 优化：Time complexity: O(n log(max – min)), Space complexity: O(1) 我们并不用对每一行都做二分搜索法, 每列是有序的，我们可以利用这个性质，从数组的左下角开始查找，如果比目标值小，我们就向右移一位，而且我们知道当前列的当前位置的上面所有的数字都小于目标值，那么cnt += i+1，反之则向上移一位，这样我们也能算出cnt的值。其余部分跟上面的方法相同 class Solution { public: int kthSmallest(vector>& matrix, int k) { int left = matrix[0][0], right = matrix.back().back(); while (left >& matrix, int target) { int n = matrix.size(), i = n - 1, j = 0, res = 0; while (i >= 0 && j Solution 2: Priority_Queue 我们使用一个最大堆，然后遍历数组每一个元素，将其加入堆，根据最大堆的性质，大的元素会排到最前面，然后我们看当前堆中的元素个数是否大于k，大于的话就将首元素去掉，循环结束后我们返回堆中的首元素即为所求. Time complexity: O(m n log(mn)) Space complexity: O(m n) class Solution { public: int kthSmallest(vector>& matrix, int k) { priority_queue q; for (int i = 0; i k) q.pop(); } } return q.top(); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-668-Kth-Smallest-Number-in-Multiplication-Table.html":{"url":"Leetcode-668-Kth-Smallest-Number-in-Multiplication-Table.html","title":"Kth Smallest Number in Multiplication Table(LC.668)","keywords":"","body":"Question Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table? Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-thsmallest number in this table. Example 1: **Input:** m = 3, n = 3, k = 5 **Output:** **Explanation:** The Multiplication Table: 1 2 3 2 4 6 3 6 9 The 5-th smallest number is 3 (1, 2, 2, 3, 3). Example 2: **Input:** m = 2, n = 3, k = 6 **Output:** **Explanation:** The Multiplication Table: 1 2 3 2 4 6 The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6). Note: The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n] Difficulty:Hard Category: Analyze 在矩阵中使用二分搜索 这道题目的难度在于数据规模非常巨大(Range: [1, 30000]),这就要求我们需要使用到Binary 搜索来解决这个问题. 如果使用暴力搜索的方式的话,拿这道题目肯定内存是不够使用的. The memory can't enough for us to generate the table. We need to build this problem in O(n*log n) Each line, the elements have beed sorted, so we can choose the binary search in this case. In this case, we can use the x/i as the number which can compare with the other element in a new row. Solution Solution 1: Binary Search 因为矩阵的每一行都是有序的，并且在这个矩阵中，min = 左上角的数字, max = 右下角的数字. 这就是我们需要搜索的范围了，我们可以根据这两个数值，计算得mid = left + (right - left) / 2. 由于矩阵中不同行之间的元素并不是严格有序的，所以我们要在每一行都查找一下mid，由于乘法表每行都是连续数字1，2，3...乘以当前行号（从1开始计数），所以我们甚至不需要在每行中使用二分查找，而是直接定位出位置。 class Solution { public: int findKthNumber(int m, int n, int k) { int left = 0, right = m * n + 1; while(left = k) right = mid; else left = mid + 1; } return left; } private: int rowLessCount(int& m, int& n, int mid) { int count = 0; // Count the number for the row // Don't ust the i == 0, so this question, i = 1 && i cite: Kth Smallest Number in Multiplication Table 乘法表中的第K小的数字 我们可以在统计小于mid的数字的方法进行优化，不用逐行统计。而是从左下角的数字开始统计，如果该数字小于mid，说明该数字及上方所有数字都小于mid，cnt　加上　i个，然后向右移动一位继续比较。如果当前数字小于mid了，那么向上移动一位，直到横纵方向有一个越界停止． class Solution { public: int findKthNumber(int m, int n, int k) { int left = 1, right = m * n; while (left = 1 && j 再快一点，使用除法来快速定位新的j值，然后迅速算出当前行的小于mid的数的个数，然后快速更新i的值 class Solution { public: int findKthNumber(int m, int n, int k) { int left = 1, right = m * n; while (left = 1 && j n * i) ? n + 1 : (mid / i + 1); cnt += (j - t) * i; i = mid / j; } if (cnt Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-719-Find-K-th-Smallest-Pair-Distance.html":{"url":"Leetcode-719-Find-K-th-Smallest-Pair-Distance.html","title":"Find K th Smallest Pair Distance","keywords":"","body":"Leetcode 719. Find K th Smallest Pair Distance 题目：给你一个数组，返回所有数对中，绝对值差第k小的值。 Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. Example 1: Input: nums = [1,3,1] k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -> 2 (1,1) -> 0 (3,1) -> 2 Then the 1st smallest distance pair is (1,1), and its distance is 0. Note: 2 . 0 . 1 . Difficulty:Hard Category:Array, Binary-Search, Heap Solution Solution 1: Binary Search Time Complexity: O(n log n), Space complexity: O(1) class Solution { public: int smallestDistancePair(vector& nums, int k) { std::sort(nums.begin(), nums.end()); int n = nums.size(); int left = 0, right = nums.back() - nums.front(); while (left = k ? right = mid: left = mid + 1; } return left; } private: // Count how many distance less that target int count(vector& nums, int& target) { int n = nums.size(); int j = 0, cnt = 0; for (int i = 0; i Solution 2: Bucket Sort 使用暴力搜索的方式，是会超出时间的，我们采用桶排序的思路来求解这个问题，使用每个距离作为桶的标号，这样我们可以很容易得到每一个距离有多少个元素对。 排序数组(也可以不排序) 循环扫描所有的元素，將求得的所有距离全部放入对应的桶计数中 依次从小到达计算第 k-th smallest distance. Time complexity: O(n^2), Space complexity: O(max_d) class Solution { public: int smallestDistancePair(vector& nums, int k) { sort(nums.begin(), nums.end()); const int max_d = nums.back(); vector rec(max_d + 1, 0); const int n = nums.size(); for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-786-K-th-Smallest-Prime-Fraction.html":{"url":"Leetcode-786-K-th-Smallest-Prime-Fraction.html","title":"K th Smallest Prime Fraction","keywords":"","body":"Leetcode 786. K th Smallest Prime Fraction A sorted list A contains 1, plus some number of primes. Then, for every p What is the K-th smallest fraction considered? Return your answer as an array of ints, where answer[0] = p and answer[1] = q. Examples: Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3. The third fraction is 2/5. Input: A = [1, 7], K = 1 Output: [1, 7] Note: A will have length between 2 and 2000. Each A[i] will be between 1 and 30000. K will be between 1 and A.length * (A.length - 1) / 2. Difficulty:Hard Category:Binary-Search, Heap Analyze 在Leetcode里面有好几个类似的题目是利用了Binary-Search的方式去查找第k小的数. 根据input的数据大小,确定使用的方法是Binary-search. Solution Solution 1: Binary Search Time complexity: O(n*C) C class Solution { public: vector kthSmallestPrimeFraction(vector& A, int K) { const int n = A.size(); double left = 0, right = 1.0; vector ans(2, 0); while (left K) right = mid; else left = mid; } return {}; } private: int count(vector& A, double& target, vector& ans) { int n = A.size(), cnt = 0; double max_f = 0.0; for (int i = 0, j = 1; i target * A[j]) ++j; if (n == j) break; cnt += (n - j); const double f = static_cast(A[i]) / A[j]; // Found the last biggest one element in this search if (f > max_f) { ans[0] = A[i]; ans[1] = A[j]; max_f = f; } } return cnt; } }; Solution 2: Priority Queue Cite:K-th Smallest Prime Fraction 第K小的质分数 输入是一个有序数组，里面是1和一些质数，说是对于任意两个数，都可以组成一个 [0, 1] 之间分数，让我们求第K小的分数是什么。由于数组是有序的，所以最小的分数肯定是由第一个数字和最后一个数字组成的，而接下来第二小的分数我们就不确定是由第二个数字和最后一个数字组成的，还是由第一个数字跟倒数第二个数字组成的。我们的想法是用一个最小堆来存分数，那么每次取的时候就可以将最小的分数取出来，由于前面说了，我们不能遍历所有的分数都存入最小堆，那么我们怎么办呢，我们可以先存n个，哪n个呢？其实就是数组中的每个数字都和最后一个数字组成的分数。由于我们需要取出第K小的分数，那么我们在最小堆中取K个分数就可以了，第一个取出的分数就是那个由第一个数字和最后一个数字组成的最小的分数，然后就是精髓所在了，我们此时将分母所在的位置前移一位，还是和当前的分子组成新的分数，这里即为第一个数字和倒数第二个数字组成的分数，存入最小堆中，那么由于之前我们已经将第二个数字和倒数第一个数字组成的分数存入了最小堆，所以不用担心第二小的分数不在堆中，这样每取出一个分数，我们都新加一个稍稍比取出的大一点的分数，这样我们取出了第K个分数即为所求 class Solution { public: vector kthSmallestPrimeFraction(vector& A, int K) { priority_queue>> q; for (int i = 0; i 另外一种书写方式： class Solution { public: vector kthSmallestPrimeFraction(vector& A, int K) { double left = 0, right = 1; int p = 0, q = 1, cnt = 0, n = A.size(); while (true) { double mid = left + (right - left) / 2.0; cnt = 0; p = 0; for (int i = 0, j = 0; i mid * A[j]) ++j; cnt += n - j; if (j Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-778-Swim-in-Rising-Water.html":{"url":"Leetcode-778-Swim-in-Rising-Water.html","title":"Swim in Rising Water(LC.778)","keywords":"","body":"Leetcode 778. Swim in Rising Water On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j). Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim. You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)? Example 1: Input: [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0. You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid. Example 2: Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation: 0 1 2 3 4 24 23 22 21 5 12 13 14 15 16 11 17 18 19 20 10 9 8 7 6 The final route is marked in bold. We need to wait until time 16 so that (0, 0) and (4, 4) are connected. Note: 2 . grid[i][j] is a permutation of [0, ..., N*N - 1]. Difficulty:Hard Category: Solution 这道题目输入是一个二维数组，当成一个水池，不同的数字代表了在水池里面台阶的高度。然后水面高度不断的上升，判断在水面高度上升到最低的高度，可以从左上角到达右下角。 Solution 1: Binary Search + BFS 使用二分搜索，以子函数作为判断关系进行搜索 由于题目中给定了数字的范围，那么二分搜索法的左右边界就有了，然后我们计算一个中间值mid，调用子函数来看这个水面高度下能否到达右下角，如果不能的话，说明水面高度不够，则 left = mid+1，如果能到达的话，有可能水面高度过高了，则right = mid，最终会到达的临界点就是能到达右下角的最低水面高度。那么来看子函数怎么写，其实就是个迷宫遍历问题，我们可以使用BFS或者DFS，这里使用了stack辅助的迭代形式的DFS来遍历，当然我们也可以使用queue辅助的迭代形式的BFS来遍历，都一样，如果在mid的水面高度下，遍历到了右下角，则返回true，否则返回false， // grid[i][j] is a permutation of [0, ..., N*N - 1], so we can try to use binary search to solve this problem. class Solution { public: int swimInWater(vector>& grid) { int n = grid.size(); int left = grid[0][0], right = n * n; while (left >& grid, int mid) { int n = grid.size(); unordered_set visited{0}; vector> dirs{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; stack st{{0}}; while (!st.empty()) { int row = st.top() / n, col = st.top() % n; st.pop(); if (row == n - 1 && col == n - 1) return true; for (auto dir : dirs) { int new_row = row + dir[0], new_col = col + dir[1]; if (new_row = n || new_col = n || visited.count(new_row * n + new_col) || grid[new_row][new_col] > mid) continue; st.push(new_row * n + new_col); visited.insert(new_row * n + new_col); } } return false; } }; 另外一种写法： Cite- 花花酱 LeetCode 778. Swim in Rising Water Time complexity: O(2 logn * n^2), Space complexity: O(n^2) class Solution { public: int swimInWater(vector>& grid) { const int n = grid.size(); auto hasPath = [&grid, n](int t) { if (grid[0][0] > t) return false; queue q; vector seen(n * n); vector dirs{1, 0, -1, 0, 1}; q.push(0); while (!q.empty()) { const int x = q.front() % n; const int y = q.front() / n; q.pop(); if (x == n - 1 && y == n - 1) return true; for (int i = 0; i = n || ty >= n || grid[ty][tx] > t) continue; const int key = ty * n + tx; if (seen[key]) continue; seen[key] = 1; q.push(key); } } return false; }; int left = 0; int right = n * n; while (left Solution 2: BFS 我们每次都使用当前的最低位置进行遍历，并使用最小堆来记录数据，每次先处理高度低的地方，如果当前位置以及是最右下角的话，我们就返回当前的水面高度。使用unordered_set visited{0};作为标记，如果当前可以扩展的元素的四周，如果未越界其并没有被访问过，则将其标记为已访问。 Time complexity: O(n), Space complexity: O(1). Runtime: 28 ms, faster than 56.25% of C++ online submissions for Swim in Rising Water. Memory Usage: 11.8 MB, less than 52.63% of C++ online submissions for Swim in Rising Water. class Solution { public: int swimInWater(vector>& grid) { int ans = 0, n = grid.size(); unordered_set visited{0}; // Set the directions vector> dirs{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; // Compare function auto cmp = [](pair& a, pair& b) { return a.first > b.first; }; priority_queue, vector>, decltype(cmp)> q(cmp); q.push({grid[0][0], 0}); // while (!q.empty()) { int row = q.top().second / n, col = q.top().second % n; ans = max(ans, grid[row][col]); q.pop(); if (row == n - 1 && col == n - 1) return ans; for (auto& dir : dirs) { int new_row = row + dir[0], new_col = col + dir[1]; if (new_row = n || new_col = n || visited.count(new_row * n + new_col)) continue; visited.insert(new_row * n + new_col); q.push({grid[new_row][new_col], new_row * n + new_col}); } } return ans; } }; Solution 3: DP + DFS 使用一个二维数组dp，其中 dp[i][j] 表示到达 (i, j) 位置所需要的最低水面高度，均初始化为整型数最大值. 我们的递归函数函数需要知道当前的位置 (x, y)，还有当前的水高cur，同时传入grid数组和需要不停更新的dp数组，如果当前位置越界了，或者是当前水高和 grid[x][y] 中的较大值大于等于 dp[x][y] 了，直接跳过，因为此时的dp值更小，不需要被更新了。否则 dp[x][y] 更新为较大值，然后对周围四个位置调用递归函数继续更新dp数组，最终返回右下位置的dp值即可. Runtime: 6712 ms, faster than 5.73% of C++ online submissions for Swim in Rising Water. Memory Usage: 752.5 MB, less than 5.26% of C++ online submissions for Swim in Rising Water. class Solution { public: int swimInWater(vector>& grid) { int n = grid.size(); dirs = vector>{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; vector> dp(n, vector(n, INT_MAX)); helper(grid, 0, 0, grid[0][0], dp); return dp[n - 1][n - 1]; } private: vector> dirs; void helper(vector>& grid, int row, int col, int cur, vector>& dp) { int n = grid.size(); if (row = n || col = n || max(cur, grid[row][col]) >= dp[row][col]) return; dp[row][col] = max(cur, grid[row][col]); // Deal with four directions for (auto dir : dirs) helper(grid, row + dir[0], col + dir[1], dp[row][col], dp); } }; Solution 4: Dijkstra’s Algorithm Time complexity: O(n^2*logn), Space complexity: O(n^2) class Solution { public: int swimInWater(vector>& grid) { const int n = grid.size(); priority_queue> q; // {-time, y * N + x} q.push({-grid[0][0], 0 * n + 0}); vector seen(n * n); vector dirs{-1, 0, 1, 0, -1}; seen[0 * n + 0] = 1; while (!q.empty()) { auto node = q.top(); q.pop(); int t = -node.first; int x = node.second % n; int y = node.second / n; if (x == n - 1 && y == n - 1) return t; for (int i = 0; i = n || ty >= n) continue; if (seen[ty * n + tx]) continue; seen[ty * n + tx] = 1; q.push({-max(t, grid[ty][tx]), ty * n + tx}); } } return -1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-875-Koko-Eating-Bananas.html":{"url":"Leetcode-875-Koko-Eating-Bananas.html","title":"Koko Eating Bananas(LC.875)","keywords":"","body":"Leetcode 875. Koko Eating Bananas Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours. Example 1: Input: piles = [3,6,7,11], H = 8 Output: 4 Example 2: Input: piles = [30,11,23,4,20], H = 5 Output: 30 Example 3: Input: piles = [30,11,23,4,20], H = 6 Output: 23 Note: 1 piles.length 1 Difficulty:Medium Category: Solution Koko　吃香蕉的速度是 K , 吃香蕉的最大速度去所有香蕉堆里面的最大值就好，所以有left = 1, right = *max_element(piles.begin(), piles.end()) + 1; 其中最右边的值是可以不选取的，为此我们计算按照这个取得的中间速度计算 kolo能不能在这个中间速度mid内吃完香蕉。如果吃完的时间花费小于限制的时间，那我们就减下吃香蕉的速度，反之就增加吃香蕉的速度。 Solution 1: Binary Search Time complexity: O(log max_speed), Space complexity: O(1) class Solution { public: int minEatingSpeed(vector& piles, int H) { // 1) [l, r) -- This is the range for the number of piles int left = 1, right = *max_element(piles.begin(), piles.end()) + 1; while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-793-Preimage-Size-of-Factorial-Zeroes-Function.html":{"url":"Leetcode-793-Preimage-Size-of-Factorial-Zeroes-Function.html","title":"Preimage Size of Factorial Zeroes Function","keywords":"","body":"Question Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K. Example 1: Input: K = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes. Example 2: Input: K = 5 Output: 0 Explanation: There is no x such that x! ends in K = 5 zeroes. Note: K will be an integer in the range [0, 10^9]. Difficulty:Hard Category:Binary-Search Solution class Solution { public: int preimageSizeFZF(int K) { return int(getNumber(K) - getNumber(K - 1)); } private: long getNumber(int k) { long left = 0, right = LONG_MAX; while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-174-Dungeon-Game.html":{"url":"Leetcode-174-Dungeon-Game.html","title":"Dungeon Game(LC.175)","keywords":"","body":"Leetcode 174. Dungeon Game The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN. Note: The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. Difficulty:Hard Category:Binary-Search, Dynamic-Programming Solution Solutions 1: DP Time complexity: O(mn), Space complexity: O(mn) -> O(n) Space complexity: O(mn) class Solution { public: int calculateMinimumHP(vector>& dungeon) { const int m = dungeon.size(); const int n = dungeon[0].size(); // hp[y][x]: min hp required to reach bottom right (P). vector> hp(m + 1, vector(n + 1, INT_MAX)); hp[m][n - 1] = hp[m - 1][n] = 1; for (int y = m - 1; y >= 0; --y) for (int x = n - 1; x >= 0; --x) hp[y][x] = max(1, min(hp[y + 1][x], hp[y][x + 1]) - dungeon[y][x]); return hp[0][0]; } }; Space complexity: O(n) class Solution { public: int calculateMinimumHP(vector>& dungeon) { const vector>& d = dungeon; const int m = d.size(); const int n = d[0].size(); // hp[x][y] is the lowest hp required to reach the P position vector> hp(m + 1, vector(n + 1, INT_MAX)); hp[m][n - 1] = hp[m - 1][n] = 1; for (int x = m - 1; x >= 0; --x) { for (int y = n - 1; y >= 0; --y) { // the hp must bigger than 1 hp[x][y] = max(1, min(hp[x + 1][y], hp[x][y + 1]) - d[x][y]); } } return hp[0][0]; } }; Solution 2: Binary Search Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-911-Online-Election.html":{"url":"Leetcode-911-Online-Election.html","title":"Online Election","keywords":"","body":"Question In an election, the i-th vote was cast for persons[i] at time times[i]. Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins. Example 1: Input: [\"TopVotedCandidate\",\"q\",\"q\",\"q\",\"q\",\"q\",\"q\"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]] Output: [null,0,1,1,0,0,1] Explanation: At time 3, the votes are [0], and 0 is leading. At time 12, the votes are [0,1,1], and 1 is leading. At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) This continues for 3 more queries at time 15, 24, and 8. Note: 1 0 times is a strictly increasing array with all elements in [0, 10^9]. TopVotedCandidate.q is called at most 10000 times per test case. TopVotedCandidate.q(int t) is always called with t >= times[0]. Difficulty:Medium Category:Binary-Search Analyze Understand Question 一次选举中,在time[i]的时候会投票给person[i],然后求在t时刻得票最多的候选人. 如果存在票数相等的情况,就选择最新获得投票的候选人. Solution // Time complexity: Constructor O(n), Query: O(logn) // Space complexity: O(n) class TopVotedCandidate { public: // the i-th person at the times[i] time vote the person[i] TopVotedCandidate(vector persons, vector times) { vector votes(persons.size() + 1, 0); int last_lead = persons.front(); for (int i = 0; i = votes[last_lead]) last_lead = persons[i]; // The i-th vote at time times[i] lead_[times[i]] = last_lead; } } int q(int t) { return prev(lead_.upper_bound(t))->second; } private: // time -> leader (IN this time, who lead this vote) map lead_; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-278-First-Bad-Version.html":{"url":"Leetcode-278-First-Bad-Version.html","title":"First Bad Version","keywords":"","body":"Leetcode 278. First Bad Version 题目大意：给你一个API查询版本是否坏了，让你找出第一个坏掉的版本。 You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true Then 4 is the first bad version. Difficulty:Easy Category:Binary-Search Solution Solution 1: Brute Force Time Complexity: O(n) TLE Space Complexity: O(1) // Runtime: 1864 ms, faster than 9.83% of C++ online submissions for First Bad Version. // Memory Usage: 8.2 MB, less than 41.34% of C++ online submissions for First Bad Version. bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { for (int i = n; i > 0; --i) { if (isBadVersion(i)) continue; return i + 1 > n ? n : i + 1; }v return 1; } }; Solution 2: Binary Search Time Complexity: O(log n) Space Complexity: O(1) // Forward declaration of isBadVersion API. bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { int left = 1, right = n; while (left Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-17-Letter-Combinations-of-a-Phone-Number.html":{"url":"Leetcode-17-Letter-Combinations-of-a-Phone-Number.html","title":"Letter Combinations of a Phone Number(LC.17)","keywords":"","body":"Leetcode 17. Letter Combinations of a Phone Number 题目大意：给你一串电话号码，输出可以由这串电话号码打出的所有字符串。 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. Difficulty:Medium Category: Solution Solution 1: DFS class Solution { public: vector letterCombinations(string digits) { if (digits.empty()) return {}; vector ans; string cur; string dict[] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; letterCombinationsDFS(digits, dict, 0, cur, ans); return ans; } void letterCombinationsDFS(const string& digits, string dict[], int index, string& out, vector& ans) { if (index == digits.length()) { ans.emplace_back(out); return; } for (char c : dict[digits[index] - '0']) { out.push_back(c); letterCombinationsDFS(digits, dict, index + 1, out, ans); out.pop_back(); } } }; Solution 2: BSF 这一种解法来自于: 花花酱 LeetCode 17. Letter Combinations of a Phone Number 在这一种解法里面, 使用到了一种API. ans.swap(temp) , 可以用来交换两个 vector. 在这里需要的是將 ans 付一个初值， 这样才能够进入循环进行计算 for (char& digit : digits) class Solution { public: vector letterCombinations(string digits) { if (digits.empty()) return {}; vector ans = {\"\"}; string dict[] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; for (char& digit : digits) { vector temp; for (string s : ans) { for (char& c : dict[digit - '0']) { temp.emplace_back(s + c); } } ans.swap(temp); } return ans; } }; 必须在最开始给ans一个初始化的数值, 这样它才可以进入到循环里面,否则一直输出的都是空值. vector ans = {\"\"}; Update 03/01/2019 Review (BSF: 10 mins, DFS: 8mins) Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-77-Combinations.html":{"url":"Leetcode-77-Combinations.html","title":"Combinations(LC.77)","keywords":"","body":"Question Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] Solution // Runtime: 100 ms, faster than 78.48% of C++ online submissions for Combinations. // Memory Usage: 11.9 MB, less than 100.00% of C++ online submissions for Combinations. class Solution { public: vector> combine(int n, int k) { vector> res; vector temp; res.reserve(n * (n - 1) / 2); temp.reserve(k); findcombine(n, k, 1, temp, res); return res; } void findcombine(int upper, int nums, int index, vector& temp, vector>& res) { if (nums == 0) res.emplace_back(temp); for (int i = index; i Solution 1: DFS // Runtime: 104 ms, faster than 71.52% of C++ online submissions for Combinations. // Memory Usage: 11.7 MB, less than 100.00% of C++ online submissions for Combinations. class Solution { public: vector> combine(int n, int k) { vector> ans; vector out; ans.reserve(k); combineDFS(n, k, 1, out, ans); return ans; } private: void combineDFS(int n, int k, int index, vector& out, vector>& ans) { if (k == 0) { ans.emplace_back(out); return; } for (int i = index; i Updated 03/01/2019 Review(BFS: 5 mins) Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-39-Combination-Sum.html":{"url":"Leetcode-39-Combination-Sum.html","title":"Combination Sum(LC.39)","keywords":"","body":"Question Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] Solution class Solution { public: vector> combinationSum(vector& candidates, int target) { vector> res; vector temp; findcombinationSum(candidates, target, 0, temp, res); return res; } void findcombinationSum(vector& candidates, int target, int index, vector& temp, vector>& res) { if (target Solution 1: DFS 这种解法的难点在于要保证没有重复数据的情况出现, 这就要求, 不能有后面的数字又重新来前面的数据来计算和的情况. // Runtime: 20 ms, faster than 75.37% of C++ online submissions for Combination Sum. // Memory Usage: 10.3 MB, less than 100.00% of C++ online submissions for Combination Sum. class Solution { public: vector> combinationSum(vector& candidates, int target) { if (candidates.empty()) return {{}}; sort(candidates.begin(), candidates.end()); vector> ans; vector out; combinationSumDFS(candidates, target, 0, out, ans); return ans; } void combinationSumDFS(vector& candidates, int target, int index, vector& out, vector>& ans) { if (target == 0) { ans.emplace_back(out); return; } if (target 这道题目也可以不先排序也是可以的的, 能够得到一样的结果 // Runtime: 20 ms, faster than 75.37% of C++ online submissions for Combination Sum. // Memory Usage: 10.3 MB, less than 100.00% of C++ online submissions for Combination Sum. class Solution { public: vector> combinationSum(vector& candidates, int target) { if (candidates.empty()) return {{}}; vector> ans; vector out; combinationSumDFS(candidates, target, 0, out, ans); return ans; } void combinationSumDFS(vector& candidates, int target, int index, vector& out, vector>& ans) { if (target == 0) { ans.emplace_back(out); return; } if (target 在循环计算的时候可以换一种处理方式 for (int i = index; i target) break; out.push_back(candidates[i]); combinationSumDFS(candidates, target - candidates[i], i, out, ans); out.pop_back(); } updated 03/01/2019 Review (BFS: 8mins) Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-40-Combination-Sum-II.html":{"url":"Leetcode-40-Combination-Sum-II.html","title":"Combination Sum II(LC.40)","keywords":"","body":"Question Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ] Solution 里面注意去掉重复元素的方式： if (i > index && candidates[i] == candidates[i - 1]) continue; class Solution { public: vector> combinationSum2(vector& candidates, int target) { vector> res; vector temp; sort(candidates.begin(), candidates.end()); findcombinationSum(candidates, target, 0, temp, res); return res; } void findcombinationSum(vector& candidates, int target, int index, vector& temp, vector>& res) { if (target index && candidates[i] == candidates[i - 1]) continue; temp.emplace_back(candidates[i]); findcombinationSum(candidates, target - candidates[i], i + 1, temp, res); temp.pop_back(); } } }; Solution 2: DFS 这道题目的变化, 就是不能够重复使用元素, 如果出现重复的情况, 要去掉 class Solution { public: vector> combinationSum2(vector& candidates, int target) { vector> ans; sort(candidates.begin(), candidates.end()); vector out; combinationSum2DFS(candidates, target, 0, out, ans); return ans; } private: void combinationSum2DFS(vector& c, int target, int index, vector& out, vector>& ans) { if (target == 0) { ans.emplace_back(out); return; } for (int i = index; i index && c[i] == c[i - 1]) continue; if (c[i] > target) break; out.emplace_back(c[i]); combinationSum2DFS(c, target - c[i], i + 1, out, ans); out.pop_back(); } } }; Updated 03/01/2019 Review(BFS, 6mins) Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-216-Combination-Sum-III.html":{"url":"Leetcode-216-Combination-Sum-III.html","title":"Combination Sum III(LC.216)","keywords":"","body":"Question Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] Solution class Solution { public: vector> combinationSum3(int k, int n) { vector> res; vector temp; res.reserve(3); findcombination(n, k, 1, temp, res); return res; } void findcombination(int n, int k, int nums, vector &temp, vector> &res) { if (n Solution 1 : DFS class Solution { public: vector> combinationSum3(int k, int n) { vector> ans; vector out; combinationSum3DFS(k, n, 1, out, ans); return ans; } private: void combinationSum3DFS(int k, int target, int index, vector& out, vector>& ans) { if (out.size() == k) { if (target == 0) ans.emplace_back(out); return; } for (int i = index; i Updated 03/01/2019 Review(BFS: 8mins) Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-78-Subsets.html":{"url":"Leetcode-78-Subsets.html","title":"Subsets(LC.78)","keywords":"","body":"Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Difficulty:Medium Category: Analyze 求子集集合的问题，我们可以每次处理一个元素，将当前的元素加到之前存在的所有子集里面，这样能够很方便的处理。 需要提前压进去一个空集 Solution Solution 1 : DFS // Runtime: 8 ms, faster than 100.00% of C++ online submissions for Subsets. // Memory Usage: 9 MB, less than 100.00% of C++ online submissions for Subsets. class Solution { public: vector> subsets(vector& nums) { if (nums.empty()) return {{}}; sort(nums.begin(), nums.end()); vector> ans; vector out; ans.emplace_back(out); subsetsDFS(nums, 0, out, ans); return ans; } private: void subsetsDFS(vector& nums, int index, vector& out, vector>& ans) { if (index == nums.size()) return; for (int i = index; i Solution 2: BFS // Non-recursion class Solution { public: vector > subsets(vector &S) { vector > res(1); sort(S.begin(), S.end()); for (int i = 0; i Updated 03/01/2019 Review(BFS: 5mins) Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-90-Subset-II.html":{"url":"Leetcode-90-Subset-II.html","title":"Subset II(LC.90)","keywords":"","body":"Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] Difficulty:Medium Category: Analyze 这道题目在78 Subsets的基础上添加了处理重复元素的部分，所以在这个位置需要对重复元素进程处理，需要保证不能有重复的子集出现在回答中。 solution Solution 1 : DFS class Solution { public: vector> subsetsWithDup(vector& nums) { if (nums.empty()) return {{}}; vector> ans; sort(nums.begin(), nums.end()); vector out; ans.emplace_back(out); subsetsWithDupDFS(nums, 0, out, ans); return ans; } private: void subsetsWithDupDFS(vector& nums, int index, vector& out, vector>& ans) { if (index == nums.size()) return; for (int i = index; i index && nums[i] == nums[i - 1]) continue; out.emplace_back(nums[i]); ans.emplace_back(out); subsetsWithDupDFS(nums, i + 1, out, ans); out.pop_back(); } } }; updated 03/01/2019 Review(BFS 6mins) Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-22-Generate-Parentheses.html":{"url":"Leetcode-22-Generate-Parentheses.html","title":"Generate Parentheses","keywords":"","body":"Question Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] solution // Runtime: 16 ms, faster than 49.46% of C++ online submissions for Generate Parentheses. // Memory Usage: 17.4 MB, less than 100.00% of C++ online submissions for Generate Parentheses. class Solution { public: vector generateParenthesis(int n) { vector ans; generateParenthesisDFS(n, n, \"\", ans); return ans; } private: void generateParenthesisDFS(int left_n, int right_n, string out, vector& ans) { if (left_n > right_n) return; if (left_n == 0 && right_n == 0) { ans.emplace_back(out); } else { if (left_n > 0) generateParenthesisDFS(left_n - 1, right_n, out + \"(\", ans); if (right_n > 0) generateParenthesisDFS(left_n, right_n - 1, out + \")\", ans); } } }; 在 DFS 的函数中， 我们尽量不要使用太多的局部变量， 这样会造成栈的使用空间较多。 对上面的代码， 优化如下： // Runtime: 12 ms, faster than 92.06% of C++ online submissions for Generate Parentheses. // Memory Usage: 14 MB, less than 100.00% of C++ online submissions for Generate Parentheses. class Solution { public: vector generateParenthesis(int n) { vector ans; string out; generateParenthesisDFS(n, n, out, ans); return ans; } private: void generateParenthesisDFS(int left_n, int right_n, string& out, vector& ans) { if (left_n + right_n == 0) { ans.emplace_back(out); return; } if (left_n > right_n) return; if (left_n > 0) { generateParenthesisDFS(left_n - 1, right_n, out += \"(\", ans); out.pop_back(); } if (right_n > 0) { generateParenthesisDFS(left_n, right_n - 1, out += \")\", ans); out.pop_back(); } } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-79-Word-Search.html":{"url":"Leetcode-79-Word-Search.html","title":"Word Search(LC.79","keywords":"","body":"Question Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Difficulty:Medium Category: Array, Backtracking Analyze This problem have these features: Begin with each element and try to find the whole words begin with it. For the wordsearch recursion function, deal with the constraint function firstly. After that, call this function for its' up, down, left and right element in order to find the next element. Constraint Condition: If board is empty, then the function return false; If the wordsearch function doesn't find the word in the board, then return fasle. Solution // Solution: Recursion // runtime: 32ms class Solution { public: bool exist(vector>& board, string word) { if (board.empty()) return false; int m = board.size(), n = board[0].size(); for (int i = 0; i >& b, string& w, int d, int x, int y) { if (x Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-212-Word-Search-II.html":{"url":"Leetcode-212-Word-Search-II.html","title":"Word Search II(LC.212)","keywords":"","body":"Question Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Difficulty:Hard Category:Backtracking, Trie Analyze This question is similar with the Leetcode 79: Word Search, I reused the wordsearch recursion function in that problem and change the loop in the findWords to search for each words. As a result, the runtime around 800ms. Solution // Runtime: 780ms class Solution { public: vector findWords(vector>& board, vector& words) { unordered_set rec; vector ans; if (board.empty()) return {}; int m = board.size(), n = board[0].size(); for (int i = 0; i >& b, string& w, int d, int x, int y) { if (x Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-131-Palindrome-Partitioning.html":{"url":"Leetcode-131-Palindrome-Partitioning.html","title":"Palindrome Partitioning","keywords":"","body":"Question Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Difficulty:Medium Category:Backtracking Solution class Solution { public: vector> partition(string s) { vector out; vector> res; partitionDFS(s, 0, out, res); return res; } void partitionDFS(string s, int start, vector& out, vector>& res) { if (start == s.size()) { res.emplace_back(out); return; } for (int i = start; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-132-Palindrome-Partitioning-II.html":{"url":"Leetcode-132-Palindrome-Partitioning-II.html","title":"Palindrome Partitioning II","keywords":"","body":"Question Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example: Input: \"aab\" Output: 1 Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut. Difficulty:Hard Category:Dynamic-Programming Solution Solution 1: Memory Limit Exceeded class Solution { public: int minCut(string s) { vector out; vector> res; int res_min = INT_MAX; partitionDFS(s, 0, out, res); for (auto t : res) { int len_cut = t.size() - 1; res_min = min(res_min, len_cut); } return res_min; } void partitionDFS(string s, int start, vector& out, vector>& res) { if (start == s.size()) { res.emplace_back(out); return; } for (int i = start; i 果然不能简单的照搬另外一道题目来轻微修改就能够得到结果的。 Solution2 class Solution { public: int minCut(string s) { // const int n = s.size(); int f[n + 1]; bool p[n][n]; fill_n(&p[0][0], n * n, false); for (int i = 0; i = 0; --i) { for (int j = i; j Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-93-Restore-IP-Addresses.html":{"url":"Leetcode-93-Restore-IP-Addresses.html","title":"Restore IP Addresses","keywords":"","body":"Question Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: \"25525511135\" Output: [\"255.255.11.135\", \"255.255.111.35\"] Solution class Solution { public: vector restoreIpAddresses(string s) { vector res; digit_to_ip(s, 4, \"\", res); return res; } void digit_to_ip(string s, int n, string out, vector& res) { // If the n = 0, then this is the last one. Don't do anything. if(n==0) { if( s.empty() ) res.push_back(out); // std::cout 0, to get each substring by recursion for(int i = 1; i = i && isVaild( s.substr(0, i))) { // std::cout 3 || (s.size() > 1 && s[0] == '0') ) return false; int ipsubaddr = atoi(s.c_str()); return ipsubaddr = 0; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-62-Unique-Paths.html":{"url":"Leetcode-62-Unique-Paths.html","title":"Unique Paths","keywords":"","body":"Question A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: Right -> Right -> Down Right -> Down -> Right Down -> Right -> Right Example 2: Input: m = 7, n = 3 Output: 28 Difficulty:Medium Category:Array, Dynamic-Programming Solution Solution 1: Recursive(递归) Time Limit Exceeded 首先我们想到的是使用递归来求解该问题, 对于矩阵中的格子(i, j)，假设从(1, 1)到它的路径数量为path(i, j), 递归公式为 path(i, j) = path(i-1, j) + path(i, j-1). 很好理解，因为机器人只能向右或向下运动，因此它只能是从(i-1, j)或(i, j-1) 运动到(i, j)的，所以路径数量也就是到达这两个格子的路径数量之和。而递归终止条件是 m == 0 || n == 0. class Solution { public: int uniquePaths(int m, int n) { if (m == 0 || n == 0) return 0; if (m == 1 && n == 1) return 1; return uniquePaths(m, n - 1) + uniquePaths(m - 1, n); } }; Solution 2: DP Buttom-Up Dynamic Programming 转变为动态规划来求解, 使用 f[i]表示在每一行的第 i 个位置可能存在的前进路线的方式, 这就可以使用 f[j] = f[j] + f[j - 1]; 来表示在每一行的第 j 个位置的路径可能数量. class Solution { public: int uniquePaths(int m, int n) { vector f(n, 0); f[0] = 1; for (unsigned int i = 0; i 上面不使用 vector也是可以的, 可使用数组. int f[n]; fill_n(&f[0], n, 0); Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-63-Unique-Paths-II.html":{"url":"Leetcode-63-Unique-Paths-II.html","title":"Unique Paths II","keywords":"","body":"Question A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Difficulty:Medium Category:Array, Dynamic-Programming Analyze As the above picture, the only way to move to spot (r, c) is by moving to one of the adjacent spots (r-1, c) or (r, c-1). So, we need to find a path to either (r-1, c) or (r, c- 1). How do we find a path to those spots? To find a path to (r-1, c) or (r, c - 1), we neet to move to one of its adjacent cells. However, it may come from (r-2, c), (r-1, c-1) , (r-1, c-1) and (r, c-2). And the (r-1, c-1) will be used twice. Work backwards. Starting from the last cell, we try to find a path to each of its adjacent cells. Use recursive. Solution Solution: DP class Solution { public: int uniquePathsWithObstacles(vector>& obstacleGrid) { if (obstacleGrid.empty()) return 0; const int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if (obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1]) return 0; vector f(n, 0); f[0] = obstacleGrid[0][0] ? 0 : 1; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-980-Unique-Paths-III.html":{"url":"Leetcode-980-Unique-Paths-III.html","title":"Unique Paths III","keywords":"","body":"Question On a 2-dimensional grid, there are 4 types of squares: 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once. Example 1: **Input:** [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] **Output:** 2 **Explanation:** We have the following two paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) Example 2: **Input:** [[1,0,0,0],[0,0,0,0],[0,0,0,2]] **Output:** 4 **Explanation:** We have the following four paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3) Example 3: **Input:** [[0,1],[2,0]] **Output:** 0 **Explanation:** There is no path that walks over every empty square exactly once. Note that the starting and ending square can be anywhere in the grid. Note: 1 Difficulty:Hard Category:Dynamic-Programming, Backtracking Analyze 这是一道周赛的题目, 参考了讨论区的解法 使用DFS来完成这道题目. Solution Solution 1: 使用DFS完成 class Solution { public: int uniquePathsIII(vector>& grid) { if (grid.empty()) return 0; int x_1 = 0, y_1 = 0, t_steps = 0; for (int i = 0; i >& g, int x, int y, int steps, int t_steps) { if (x = g[0].size() || g[x][y] == -1) return 0; if (g[x][y] == 2) { return steps == t_steps ? 1 : 0; } g[x][y] = -1; int paths = pathsearch(g, x + 1, y, steps + 1, t_steps) + pathsearch(g, x - 1, y, steps + 1, t_steps) + pathsearch(g, x, y + 1, steps + 1, t_steps) + pathsearch(g, x, y - 1, steps + 1, t_steps); g[x][y] = 0; return paths; } }; Solution 2: 动态规划 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-200-Number-of-Islands.html":{"url":"Leetcode-200-Number-of-Islands.html","title":"Number of Islands(LC.200)","keywords":"","body":"Leetcode 200. Number of Islands Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3 Difficulty:Medium Category: Analyze 题目大意：统计岛屿的数量，就是求矩阵中连续1区域的个数。 用深度优先搜索DFS来解，我们需要建立一个visited数组用来记录某个位置是否被访问过，对于一个为‘1’且未被访问过的位置，我们递归进入其上下左右位置上为‘1’的数，将其周围所有的 1 都换成 0. Solution Solution 1: DFS Cite: LeetCode 200. Number of Islands Use DFS to find a connected component (an island) and mark all the nodes to 0. Time complexity: O(mn) Space complexity: O(mn) class Solution { public: int numIslands(vector>& grid) { if (grid.empty()) return 0; int m = grid.size(); int n = grid[0].size(); int ans = 0; for (int y = 0; y >& grid, int x, int y, int m, int n) { if (x = n || y >= m || grid[y][x] == '0') return; // Change all the grid[y][x] to '0' grid[y][x] = '0'; dfs(grid, x + 1, y, m, n); dfs(grid, x - 1, y, m, n); dfs(grid, x, y + 1, m, n); dfs(grid, x, y - 1, m, n); } }; 另外，也可以单独建立一个数组来做统计的情况： class Solution { public: int numIslands(vector > &grid) { if (grid.empty() || grid[0].empty()) return 0; int m = grid.size(), n = grid[0].size(), res = 0; vector > visited(m, vector(n, false)); for (int i = 0; i > &grid, vector > &visited, int x, int y) { if (x = grid.size()) return; if (y = grid[0].size()) return; if (grid[x][y] != '1' || visited[x][y]) return; visited[x][y] = true; numIslandsDFS(grid, visited, x - 1, y); numIslandsDFS(grid, visited, x + 1, y); numIslandsDFS(grid, visited, x, y - 1); numIslandsDFS(grid, visited, x, y + 1); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-489-Robot-Room-Cleaner.html":{"url":"Leetcode-489-Robot-Room-Cleaner.html","title":"Robot Room Cleaner(LC.489)","keywords":"","body":"Leetcode 489. Robot Room Cleaner Given a robot cleaner in a room modeled as a grid. Each cell in the grid can be empty or blocked. The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees. When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell. Design an algorithm to clean the entire room using only the 4 given APIs shown below. interface Robot { // returns true if next cell is open and robot moves into the cell. // returns false if next cell is obstacle and robot stays on the current cell. boolean move(); // Robot will stay on the same cell after calling turnLeft/turnRight. // Each turn will be 90 degrees. void turnLeft(); void turnRight(); // Clean the current cell. void clean(); } Example: Input: room = [ [1,1,1,1,1,0,1,1], [1,1,1,1,1,0,1,1], [1,0,1,1,1,1,1,1], [0,0,0,1,0,0,0,0], [1,1,1,1,1,1,1,1] ], row = 1, col = 3 Explanation: All grids in the room are marked by either 0 or 1. 0 means the cell is blocked, while 1 means the cell is accessible. The robot initially starts at the position of row=1, col=3. From the top left corner, its position is one row below and three columns right. Notes: The input is only given to initialize the room and the robot's position internally. You must solve this problem \"blindfolded\". In other words, you must control the robot using only the mentioned 4 APIs, without knowing the room layout and the initial robot's position. The robot's initial position will always be in an accessible cell. The initial direction of the robot will be facing up. All accessible cells are connected, which means the all cells marked as 1 will be accessible by the robot. Assume all four edges of the grid are all surrounded by wall. Difficulty:Medium Category: Analyze Cite: Robot Room Cleaner 扫地机器人 回归题目，给了我们一个扫地机器人，给了4个API函数可供我们调用，具体实现不用我们操心，让我们实现打扫房间cleanRoom函数。给的例子中有房间和起始位置的信息，但是代码中却没有，摆明是不想让我们被分心。想想也是，难道我们在给扫地机器人编程时，还必须要知道用户的房间信息么？当然不能够啦，题目中也说了让我们盲目 Blindfolded 一些，所以就盲目的写吧。既然是扫地，那么肯定要记录哪些位置已经扫过了，所以肯定要记录位置信息，由于不知道全局位置，那么只能用相对位置信息了。初始时就是(0, 0)，然后上下左右加1减1即可。位置信息就放在一个 HashSet 中就可以了，同时为了方便，还可以将二维坐标编码成一个字符串。我们采用递归DFS来做，初始化位置为(0, 0)，然后建一个上下左右的方向数组，使用一个变量dir来从中取数。在递归函数中，我们首先对起始位置调用clean函数，因为题目中说了起始位置是能到达的，即是为1的地方。然后就要把起始位置加入visited。然后我们循环四次，因为有四个方向，由于递归函数传进来的dir是上一次转到的方向，那么此时我们dir加上i，为了防止越界，对4取余，就是我们新的方向了，然后算出新的位置坐标newX和newY。此时先要判断visited不含有这个新位置，即新位置没有访问过，还要调用 move 函数来确定新位置是否可以到达，若这两个条件都满足的话，我们就对新位置调用递归函数。注意递归函数调用完成后，我们要回到调用之前的状态，因为这里的robot是带了引用号的，是全局通用的，所以要回到之前的状态。回到之前的状态很简单，因为这里的机器人的运作方式是先转到要前进的方向，才能前进。那么我们后退的方法就是，旋转180度，前进一步，再转回到原来的方向。同理，我们在按顺序试上->右->下->左的时候，每次机器人要向右转一下，因为move函数只能探测前方是否能到达，所以我们必须让机器人转到正确的方向，才能正确的调用move函数。如果用过扫地机器人的童鞋应该会有影响，当前方有障碍物的时候，机器人圆盘会先转个方向，然后再继续前进，这里要实现的机制也是类似的 Solution Solution 1: DFS + Backtracking class Solution { public: vector> dirs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; void cleanRoom(Robot& robot) { // record the visited positions unordered_set visited; helper(robot, 0, 0, 0, visited); } private: void helper(Robot& robot, int x, int y, int dir, unordered_set& visited) { robot.clean(); visited.insert(to_string(x) + \"-\" + to_string(y)); for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-55-Jump-Game.html":{"url":"Leetcode-55-Jump-Game.html","title":"Jump Game","keywords":"","body":"Question Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Difficulty:Medium Category:Array, Greedy Solution class Solution { public: bool canJump(vector& nums) { int target_step = 1; for (int i = 0; target_step = target_step) break; target_step = max(target_step, nums[i] + i + 1); } return target_step >= nums.size(); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-45-Jump-Game-II.html":{"url":"Leetcode-45-Jump-Game-II.html","title":"Jump Game II","keywords":"","body":"Question Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. Difficulty:Hard Category:Greedy, Array Solution // TODO: Try to use other method to solve this problem. class Solution { public: int jump(vector& nums) { // 1. If size() = nums.size() - 1) return step; // Move one step, there will add a new right positon. if (new_right > right) right = new_right; } left = old_right + 1; } return 0; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-121-Best-Time-to-Buy-and-Sell-Stock.html":{"url":"Leetcode-121-Best-Time-to-Buy-and-Sell-Stock.html","title":"Best Time to Buy and Sell Stock","keywords":"","body":"Leetcode 121. Best Time to Buy and Sell Stock 题目大意: 给你一只股票每天的价格，如果只能做一次交易（一次买进一次卖出）问你最多能赚多少钱。 Say you have an array for which the i_th element is the price of a given stock on day _i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Solution class Solution { public: int maxProfit(vector& prices) { if (prices.empty()) return 0; int preMin = prices[0], curMax = 0, maxPrice = 0; for (int i = 0; i curMax) { curMax = prices[i]; maxPrice = max(maxPrice, curMax - preMin); } if (prices[i] Solution 1: DP 只需要遍历一次数组，用一个变量记录遍历过数中的最小值，然后每次计算当前值和这个最小值之间的差值最为利润，然后每次选较大的利润来更新。当遍历完成后当前利润即为所求 Time Complexity: O(n) Space Complexity: O(1) class Solution { public: int maxProfit(vector& prices) { int res = 0, buy = INT_MAX; for (int price : prices) { buy = min(buy, price); res = max(res, price - buy); } return res; } }; Solution 2: Maximum Subarray question class Solution { public: int maxProfit(vector& prices) { int n = prices.size(); if (n gains(n - 1, 0); for (int i = 1; i & nums) { vector f(nums.size()); f[0] = nums[0]; for (int i = 1; i Relative Problems Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-122-Best-Time-To-Buy-and-Sell-Stock-II.html":{"url":"Leetcode-122-Best-Time-To-Buy-and-Sell-Stock-II.html","title":"Best Time To Buy and Sell Stock II","keywords":"","body":"Question Say you have an array for which the i_th element is the price of a given stock on day _i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Solution class Solution { class Solution { public: int maxProfit(vector& prices) { if (prices.empty()) return 0; int maxPrice = 0; for (int i = 1; i prices[i - 1]) maxPrice += prices[i] - prices[i - 1]; } return maxPrice; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-123-Best-Time-To-buy-and-sell-Stock-III.html":{"url":"Leetcode-123-Best-Time-To-buy-and-sell-Stock-III.html","title":"Best Time To buy and sell Stock III","keywords":"","body":"Question Say you have an array for which the i_th element is the price of a given stock on day _i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. Difficulty:Hard Category:Dynamic-Programming Analyze 思路参考博客, 在这道题目中我们使用了两个变量： local, 其中local[i][j]表示了在第i天达到j次交易数的时候，能够达到的最大利润。（并且最后一次交易必须发生在第i天） global, 其中global[i][j]表示在第i天达到j次交易的最大利润（这里不限制交易的位置） local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff) global[i][j] = max(local[i][j], global[i - 1][j]) 所以局部第j次交易的最大利润就是： 上一天的第j-1次交易的全局最大值+昨天到今天大约0的差值 Vs 上一天交易j次的局部最大利润+昨天到今天的价格差值。 ‘global[i - 1][j - 1] + max(diff, 0)’这种情况就是，昨天交易得到的全局最大值+今天和昨天的差价，如果差价为负数，那么就加上的是0 所谓的全局最大利润：global[i][j] = max(local[i][j], global[i - 1][j])就是今天的局部最大利润，或者昨天的第‘j’次交易的最大利润（这说明昨天到今天没有利润的） Solution class Solution { public: int maxProfit(vector &prices) { if (prices.empty()) return 0; int n = prices.size(), g[n][3] = {0}, l[n][3] = {0}; for (int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-11-Container-With-Most-Water.html":{"url":"Leetcode-11-Container-With-Most-Water.html","title":"Container With Most Water","keywords":"","body":"Container with the Most Water Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Difficulty:Medium Category:Math Analyze 只需要定义i和j两个指针分别指向数组的左右两端，然后两个指针向中间搜索，每移动一次算一个值并和之前的结果比较取较大值. (ps.容器装水量: 是找出左右两个边缘中较小的那个乘以两边缘的距离) Solution class Solution { public: int maxArea(vector& height) { int res = 0, i = 0, j = height.size() - 1; while (i height[j] ? --j : ++i; } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-134-Gas-Station.html":{"url":"Leetcode-134-Gas-Station.html","title":"Gas Station","keywords":"","body":"Question There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1: Input: gas = [1,2,3,4,5] cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. Example 2: Input: gas = [2,3,4] cost = [3,4,3] Output: -1 Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. Difficulty:Medium Category:Greedy Solution class Solution { public: int canCompleteCircuit(vector& gas, vector& cost) { int j = -1, total = 0; for (int i = 0, sum = 0; i = 0 ? j + 1 : -1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-583-Delete-Operation-for-Two-Strings.html":{"url":"Leetcode-583-Delete-Operation-for-Two-Strings.html","title":"Delete Operation for Two Strings(LC.583)","keywords":"","body":"Question Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. Example 1: Input: \"sea\", \"eat\" Output: 2 Explanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\". Note: The length of given words won't exceed 500. Characters in given words can only be lower-case letters. Difficulty:Medium Category:String Solution class Solution { public: int minDistance(string word1, string word2) { const size_t m = word1.length(); const size_t n = word2.length(); int f[m + 1][n + 1]; for (size_t i = 0; i Related Question Leetcode 72. Edit Distance Leetcode 712. Minimum ASCII Delete Sum for Two Strings Leetcode 583. Delete Operation for Two Strings Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-712-Minimum-ASCII-Delete-Sum-for-Two-Strings.html":{"url":"Leetcode-712-Minimum-ASCII-Delete-Sum-for-Two-Strings.html","title":"Minimum ASCII Delete Sum for Two Strings(LC.712)","keywords":"","body":"Question Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: Input: s1 = \"sea\", s2 = \"eat\" Output: 231 Explanation: Deleting \"s\" from \"sea\" adds the ASCII value of \"s\" (115) to the sum. Deleting \"t\" from \"eat\" adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this. Example 2: Input: s1 = \"delete\", s2 = \"leet\" Output: 403 Explanation: Deleting \"dee\" from \"delete\" to turn the string into \"let\", adds 100[d]+101[e]+101[e] to the sum. Deleting \"e\" from \"leet\" adds 101[e] to the sum. At the end, both strings are equal to \"let\", and the answer is 100+101+101+101 = 403. If instead we turned both strings into \"lee\" or \"eet\", we would get answers of 433 or 417, which are higher. Note: 0 . All elements of each string will have an ASCII value in [97, 122]. Difficulty:Medium Category: Solution class Solution { public: int minimumDeleteSum(string s1, string s2) { const size_t m = s1.length(); const size_t n = s2.length(); int f[m + 1][n + 1]; f[0][0] = 0; for (size_t i = 1; i Related Question Leetcode 72. Edit Distance Leetcode 712. Minimum ASCII Delete Sum for Two Strings Leetcode 583. Delete Operation for Two Strings Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-120-Triangle.html":{"url":"Leetcode-120-Triangle.html","title":"Triangle","keywords":"","body":"Question Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. Difficulty:Medium Category:Array, Dynamic-Programming Solution class Solution { public: int minimumTotal(vector>& triangle) { for (int i = triangle.size() - 2; i >= 0; --i) { for (int j = 0; j Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-53-Maximum-Subarray.html":{"url":"Leetcode-53-Maximum-Subarray.html","title":"Maximum Subarray","keywords":"","body":"Question Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Difficulty:Easy Category:Array, Divide-and-Conquer, Dynamic-Programming Analyze 这道题目是求解最大的连续子序列和，依次处理每个元素： 如果当前元素加上之前的和 如果得到的临时数值比之前的最大值还要大，那么就替换这个数值 解决方案：如Solution1 Solution Time complexity: O(n), Space Complexity: O(1) class Solution { public: int maxSubArray(vector& nums) { int ans = INT_MIN, temp = 0; for (int& num : nums) { temp = max(temp + num, num); ans = max(temp, ans); } return ans; } }; Solution 2: Divide and Conquer Cite: Maximum Subarray 最大子数组 题目还要求我们用分治法Divide and Conquer Approach来解，这个分治法的思想就类似于二分搜索法，我们需要把数组一分为二，分别找出左边和右边的最大子数组之和，然后还要从中间开始向左右分别扫描，求出的最大值分别和左右两边得出的最大值相比较取最大的那一个 class Solution { public: int maxSubArray(vector& nums) { if (nums.empty()) return 0; return helper(nums, 0, (int)nums.size() - 1); } int helper(vector& nums, int left, int right) { if (left >= right) return nums[left]; int mid = left + (right - left) / 2; int lmax = helper(nums, left, mid - 1); int rmax = helper(nums, mid + 1, right); int mmax = nums[mid], t = mmax; for (int i = mid - 1; i >= left; --i) { t += nums[i]; mmax = max(mmax, t); } t = mmax; for (int i = mid + 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-85-Maximal-Rectangle.html":{"url":"Leetcode-85-Maximal-Rectangle.html","title":"Maximal Rectangle","keywords":"","body":"Question Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Difficulty:Hard Category:Array, Hash-Table, Dynamic-Programming, Stack Analyze 这到题目是在二位矩阵上面求解最大的矩形面积。 方案一：Solution 1: 这一道题目可以在原来的Largest Rectangle in Histogram的基础上来完成. 每一行向上的部分看成是一个直方图，我们只需要对每一行计算一次直方图的数值，就可以了 输入的矩阵有多少行，就计算多少次直方图的数值 Solution class Solution { public: int maximalRectangle(vector>& matrix) { if (matrix.empty()) return 0; int res = 0, m = matrix.size(), n = matrix[0].size(); vector height; for (int i = 0; i & heights) { int res = 0; std::stack s; heights.emplace_back(0); for (int i = 0; i heights[s.top()]) { s.push(i++); } else { int tmp = s.top(); s.pop(); res = max(res, heights[tmp] * (s.empty() ? i : i - s.top() - 1)); } } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-198-House-Robber.html":{"url":"Leetcode-198-House-Robber.html","title":"House Robber","keywords":"","body":"Question 题目大意: 相当于在一列数组中取出一个或多个不相邻数，使其和最大 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Difficulty:Easy Category:Dynamic-Programming Solution Solution 1: DP 维护一个一位数组 dp，其中 dp[i] = 到 i 位置时不相邻数能形成的最大和，那么状态转移方程怎么写呢，我们先拿一个简单的例子来分析一下，比如说 nums 为 {3, 2, 1, 5}，那么我们来看我们的dp数组应该是什么样的，首先dp[0]=3没啥疑问，再看dp[1]是多少呢，由于3比2大，所以我们抢第一个房子的3，当前房子的2不抢，所以dp[1]=3，那么再来看dp[2]，由于不能抢相邻的，所以我们可以用再前面的一个的dp值加上当前的房间值，和当前房间的前面一个dp值比较，取较大值当做当前dp值，所以我们可以得到状态转移方程dp[i] = max(num[i] + dp[i - 2], dp[i - 1]), 由此看出我们需要初始化dp[0]和dp[1]，其中dp[0]即为num[0]，dp[1]此时应该为max(num[0], num[1]) class Solution { public: int rob(vector& nums) { if (nums.empty()) return 0; int n = nums.size(); vector dp(n, 0); for (int i = 0; i 1 ? dp[i - 2] : 0) + nums[i], i > 0 ? dp[i - 1] : 0); return dp.back(); } }; 优化空间复杂度 O(n) ---> O(1), 定义两个变量 robEven 和 robOdd, 其中的 robEven 表示只抢劫偶数的房子,而 robOdd 表示只抢劫奇数房子. 在遍历的时候, 不断更新这两个变量. 这种奇偶数分开更新的方式可以保证数组的最大和的数字并不相邻. class Solution { public: int rob(vector &nums) { int robEven = 0, robOdd = 0, n = nums.size(); for (int i = 0; i 另外一种方式,抢当前房子或不抢当前房子: class Solution { public: int rob(vector &nums) { int rob = 0, notRob = 0, n = nums.size(); for (int i = 0; i Solution 2: Recursion + Memorization Time complexity: O(n), Space complexity: O(n) class Solution { public: int rob(vector& nums) { const int n = nums.size(); m_ = vector(n, -1); return rob(nums, n - 1); } private: vector m_; int rob(const vector& nums, int i) { if (i = 0) return m_[i]; m_[i] = max(rob(nums, i - 2) + nums[i], rob(nums, i - 1)); return m_[i]; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-139-Word-Break.html":{"url":"Leetcode-139-Word-Break.html","title":"Word Break","keywords":"","body":"Question Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\", \"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\". Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: false Difficulty:Medium Category:Dynamic-Programming Solution Solution１:Error--Time Limit Exceeded---DFS // 时间复杂度：　O(２＾ｎ) // 空间复杂度：　Ｏ(n) class Solution { public: bool wordBreak(string s, vector& wordDict) { unordered_set dict(wordDict.begin(), wordDict.end()); return dfs(s, dict, 0, 0); } bool dfs(const string& s, unordered_set& dict, size_t start, size_t cur) { // 1) Output node if (cur == s.size()) { if (dict.find(s.substr(start, cur - start + 1)) != dict.end()) return true; else return false; } if (dict.find(s.substr(start, cur - start + 1)) != dict.end()) if (dfs(s, dict, cur + 1, cur + 1)) return true; if (dfs(s, dict, start, cur + 1)) return true; return false; } }; Solution 2: 动态规划: DP // Runtime: 4ms // f[i] is mean the word can divide at the i index position. class Solution { public: bool wordBreak(string s, vector& wordDict) { unordered_set w_(wordDict.begin(), wordDict.end()); int len = s.size(); vector f(len + 1, false); f[0] = true; for (int i = 1; i = 0; --j) { if (f[j] && w_.find(s.substr(j, i - j)) != w_.end()) { f[i] = true; break; } } } return f[len]; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-97-Interleaving-String.html":{"url":"Leetcode-97-Interleaving-String.html","title":"Interleaving String","keywords":"","body":"Question Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\" Output: true Example 2: Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\" Output: false Difficulty:Hard Category:String, Dynamic-Programming Analyze 这一道题目先判断前提条件是否符合： 字符串s1和字符串s2的长度之和必须等于字符串s3的长度。， 并且如果s1和s2是空值的时候，直接返回true。这道题目使用动态规划来求解。 设状态f[i][j] 表示s1[0,i]和s2[0,j]能够组合匹配s3[0,i+j]。 如果s1的最后一个字符=s3的最后一个字符，那么f[i][j] = f[i-1][j] 如果s2的最后一个字符=s3的最后一个字符，那么f[i][j] = f[i][j-1] 这就可以得到状态变化公式为： f[i][j] = (s1[i - 1] == s3 [i + j - 1] && f[i - 1][j]) || (s2[j - 1] == s3 [i + j - 1] && f[i][j - 1]); 几个主要部分： 初始化状态记录的二维数组， 使用s1.length（）+1的长度初始化行数，使用s2.length()+1的长度初始化每行的数据个数 vector> f(s1.length() + 1, vector(s2.length() + 1, true)); 对二维数组f进行边界初始化：f[0][j]和f[i][0], 在这里对f[i][0]初始化的时候只需要判断上一个状态f[i-1][0]的状态和s1[i-1] == s3[i-1]就可以了。 对f[0][j]初始化的时候只需要判断上一个状态f[0][j-1]和s2[j-1] == s3[j-1]即可。(继续判断下一个元素是否相等的必要条件是上一个的状态是true)。(注明：这里对f[0][0]直接使用初始的True即可) for (unsigned int i = 1; i Solution // f[i][j] = (s1[i - 1] == s3 [i + j - 1] && f[i - 1][j]) || (s2[j - 1] == s3 [i + j - 1] && f[i][j - 1]); class Solution { public: bool isInterleave(string s1, string s2, string s3) { if (s3.length() != s1.length() + s2.length()) return false; vector> f(s1.length() + 1, vector(s2.length() + 1, true)); for (unsigned int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-91-Decode-Ways.html":{"url":"Leetcode-91-Decode-Ways.html","title":"Decode Ways","keywords":"","body":"Leetcode 91. Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: \"12\" Output: 2 Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: Input: \"226\" Output: 3 Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Difficulty:Medium Category:String, Dynamic-Programming Solution Solution 1: DP 建立一位dp数组，长度比输入数组长多多2，全部初始化为1，因为斐波那契数列的前两项也为1，然后从第三个数开始更新，对应数组的第一个数。对每个数组首先判断其是否为0，若是将改为dp赋0，若不是，赋上一个dp值，此时相当如加上了dp[i - 1], 然后看数组前一位是否存在，如果存在且满足前一位不是0，且和当前为一起组成的两位数不大于26，则当前dp值加上dp[i - 2], 至此可以看出来跟斐波那契数组的递推式一样. Use f[n] = how many ways for the 0 to n: If s[n] != 0, f[n] = f[n-1] + f[n-2]; (s[n-1] and s[n] have the number 10 - 26) If s[n] == 0, f[n] = f[n-2] Time complexity: O(n) Space complexity: O(n) class Solution { public: int numDecodings(string s) { if (s.empty() || (s.length() > 1 && s[0] == '0')) return 0; // Set dp vector and the edge value vector f(s.length() + 1, 0); f[0] = 1; for (size_t i = 1; i = 2 && (s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] 来源于博客：Decode Ways 解码方法 如果是 O (n) 的空间复杂度， 也可以使用下面的这种写法： class Solution { public: int numDecodings(string s) { if (s.length() == 0) return 0; return ways(s, 0, s.length() - 1); } private: int ways(const string& s, int l, int r) { if (m_ways.count(l)) return m_ways[l]; if (s[l] == '0') return 0; if (l >= r) return 1; // Single digit or empty. int w = ways(s, l + 1, r); const int prefix = (s[l] - '0') * 10 + (s[l + 1] - '0'); if (prefix m_ways; }; 我们再来看一种空间复杂度为O(1)的解法，我们用两个变量c1, c2来分别表示 s[i-1] 和 s[i-2] 的解码方法，然后我们从 i = 1 开始遍历，也就是字符串的第二个字符，我们判断如果当前字符为'0'，说明当前字符不能单独拆分出来，只能和前一个字符一起，我们先将c1赋为0，然后我们看前面的字符，如果前面的字符是1或者2时，我们就可以更新c1 = c1 + c2，然后c2 = c1 - c2，其实c2赋值为之前的c1，如果不满足这些条件的话，那么c2 = c1 Time complexity: O(n) Space complexity: O(1) class Solution { public: int numDecodings(string s) { if (s.empty() || s.front() == '0') return 0; int c1 = 1, c2 = 1; for (int i = 1; i 另外一种写法： class Solution { public: int numDecodings(string s) { if (s.empty() || s[0] == '0') return 0; if (s.length() == 1) return 1; const int n = s.length(); int w1 = 1; int w2 = 1; for (int i = 1; i = 10 && num Solution 2: Brute Force 该解法来源于博客：花花酱 LeetCode 91. Decode Ways Time complexity: O(n^2) Space complexity: O(n^2) // Author: Huahua // Runtime: 6 ms class Solution { public: int numDecodings(string s) { if (s.length() == 0) return 0; m_ways[\"\"] = 1; return ways(s); } private: int ways(const string& s) { if (m_ways.count(s)) return m_ways[s]; if (s[0] == '0') return 0; if (s.length() == 1) return 1; int w = ways(s.substr(1)); const int prefix = stoi(s.substr(0, 2)); if (prefix m_ways; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-115-Distinct-Subsequences.html":{"url":"Leetcode-115-Distinct-Subsequences.html","title":"Distinct Subsequences","keywords":"","body":"Question Given a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not). Example 1: Example 2: Difficulty:Hard Category:String, Dynamic-Programming Solution // eg. f(i, j) = f(i − 1, j) // f(i, j) = f(i − 1, j) + f(i − 1, j − 1) class Solution { public: int numDistinct(string s, string t) { int m = t.length(), n = s.length(); int f[m + 1][n + 1]; for (size_t i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-464-Can-I-Win.html":{"url":"Leetcode-464-Can-I-Win.html","title":"Can I Win","keywords":"","body":"Question In the \"100 game,\" two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins. What if we change the game so that players cannot re-use integers? For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100. Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally. You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300. Example Input: maxChoosableInteger = 10 desiredTotal = 11 Output: false Explanation: No matter which integer the first player choose, the first player will lose. The first player can choose an integer from 1 up to 10. If the first player choose 1, the second player can only choose integers from 2 up to 10. The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal. Same with other integers chosen by the first player, the second player will always win. Difficulty:Medium Category:Dynamic-Programming, Minimax Analyze 有一个博弈论相关的方式，使用递归，每次走最好的一步，默认对手也走最好的一步. 这道题目需要求解第一个player有没有机会取得胜利，但是这可能会让另外一个player没有机会胜利的情况也是返回true的。 要求： 一个数字只能使用一次， 范围是1-15 For example: 根据上图中，我们可以得到，在这道题目中可能存在的情况是2^m中情况，但你第一个用户开始的时候，就面临这些情况，我们在这道题目中使用vector r_来记录在你面临的每一种情况下，你所能够取得的情况r_ = vector(1 。 所以每次递归给对方的就是，你选择了这一个数字，然后把更新之后的状态给对方，如果对方尝试完所有的数据之后都不能够胜利，那么就是你获得胜利了： if (!canIWin(m, d - (i + 1), s | (1 当然，如果对方在每一种情况下面都是可以取得胜利的话，那就是失败了，返回false // current player lose r_[s] = -1; return false; Solution // Solution: Recursion with memoization //Time complexity: O(2^M) //Space complexity: O(2^M) // Runtimes: 20ms class Solution { public: bool canIWin(int maxChoosableInteger, int desiredTotal) { int& m = maxChoosableInteger; int& d = desiredTotal; // Boundary Conditions. if (d (1 r_; // If you begin with the state(s), can you win this game in this state; bool canIWin(const int m, const int d, const int s) { // Last person have been win this game if (d Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-42-Trapping-Rain-Water.html":{"url":"Leetcode-42-Trapping-Rain-Water.html","title":"Trapping Rain Water","keywords":"","body":"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Difficulty:Hard Category: Analyze 这道收集雨水的题跟之前的那道 Largest Rectangle in Histogram 直方图中最大的矩形 有些类似，但是又不太一样，我们先来看一种方法，这种方法是基于动态规划Dynamic Programming的，我们维护一个一维的dp数组，这个DP算法需要遍历两遍数组，第一遍遍历dp[i]中存入i位置左边的最大值，然后开始第二遍遍历数组，第二次遍历时找右边最大值，然后和左边最大值比较取其中的较小值，然后跟当前值A[i]相比，如果大于当前值，则将差值存入结果，代码如下： Solution Solution 1: DP class Solution { public: int trap(vector& height) { int res = 0, left_max = 0, right_max = 0; vector diff(height.size(), 0); // Get the left max_hight // For i, the left heightes is the left_max; for (int i = 0; i = 0; --i) { // Find the min for the left_max and right_max, and // use this height as the diff value; diff[i] = min(right_max, diff[i]); right_max = max(right_max, height[i]); if (diff[i] > height[i]) res += diff[i] - height[i]; } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-300-Longest-Increasing-Subsequence.html":{"url":"Leetcode-300-Longest-Increasing-Subsequence.html","title":"Longest Increasing Subsequence","keywords":"","body":"Question Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note: There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? Difficulty:Medium Category:Dynamic-Programming, Binary-Search Solution Solution 1: DP 解题思路来源于博客：花花酱 LeetCode 300. Longest Increasing Subsequence 具有的特性： 解决方案的流程示意图： // Runtimes: 32ms class Solution { public: int lengthOfLIS(vector& nums) { if (nums.empty()) return 0; int n = nums.size(); vector f(n, 1); // f[i] 表示前面的元素可以组合得到的最长的元素之和 for (int i = 1; i nums[j]) f[i] = max(f[i], f[j] + 1); return *std::max_element(f.begin(), f.end()); } }; Solution 2: 递归方案 解题思路： class Solution { public: int lengthOfLIS(vector& nums) { if (nums.empty()) return 0; const int n = nums.size(); f_ = vector(n, 0); int ans = 0; for (int i = 0; i f_; int LIS(const vector& nums, int r) { if (r == 0) return 1; if (f_[r] > 0) return f_[r]; int ans = 1; for (int i = 0; i nums[i]) { ans = max(ans, LIS(nums, i) + 1); } } f_[r] = ans; return f_[r]; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-303-Range-Sum-Query-Immutable.html":{"url":"Leetcode-303-Range-Sum-Query-Immutable.html","title":"Range Sum Query Immutable","keywords":"","body":"Question Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3 Note: You may assume that the array does not change. There are many calls to sumRange function. Difficulty:Easy Category:Dynamic-Programming Solution Solution 1: 直接使用求解的方式 class NumArray { public: NumArray(vector nums) { nums_ = std::move(nums); } int sumRange(int i, int j) { int sum = 0; for (int m = i; m nums_; }; /** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(i,j); */ 运行时间： 108ms 这个的时间复杂度是非常高的了： O(m*n) 空间复杂度：O(n) 优化，进行预处理 Solution 2: DP Times: O(n) + m*O(1) = O(n+m) Spaces: O(n) Runtime: 28ms class NumArray { public: NumArray(vector nums) : sums_(nums) { if (nums.empty()) return; for (int i = 1; i sums_; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-312-Burst-Balloons.html":{"url":"Leetcode-312-Burst-Balloons.html","title":"Burst Balloons","keywords":"","body":"Question Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note: You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 Example: Input: [3,1,5,8] Output: 167 **Explanation:** nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 315 + 358 + 138 + 181 = 167 Difficulty:Hard Category:Dynamic-Programming, Divide-And-Conquer Solution class Solution { public: int maxCoins(vector& nums) { const int n = nums.size(); nums.insert(nums.begin(), 1); nums.push_back(1); // c[i][j] = maxCoin(nums[i:j+1]) vector> c(n + 2, vector(n + 2, 0)); for (int l = 1; l Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-241-Different-Ways-to-Add-Parentheses.html":{"url":"Leetcode-241-Different-Ways-to-Add-Parentheses.html","title":"Different Ways to Add Parentheses","keywords":"","body":"Question Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: Input: \"2-1-1\" Output: [0, 2] Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: Input: \"2*3-4*5\" Output: [-34, -14, -10, -10, 10] Explanation: (2(3-(45))) = -34 ((23)-(45)) = -14 ((2(3-4))5) = -10 (2((3-4)5)) = -10 (((23)-4)5) = 10 Difficulty:Medium Category:DP, Divide-and-Conquer Analyze 寻找一个位置，对表达式进行分割，要求分割的位置是在各个操作符的地方。下面的图片来自于博客：花花酱 LeetCode 241. Different Ways to Add Parentheses Solution // Author: Huahua namespace leetcode { int add(int a, int b) { return a + b; } int minus(int a, int b) { return a - b; } int multiply(int a, int b) { return a * b; } } // namespace leetcode class Solution { public: vector diffWaysToCompute(string input) { return ways(input); } private: unordered_map> m_; const vector& ways(const string& input) { if (m_.count(input)) return m_[input]; vector res; for (int i = 0; i & l = ways(left); const vector& r = ways(right); std::function f; switch (op) { case '+': f = leetcode::add; break; case '-': f = leetcode::minus; break; case '*': f = leetcode::multiply; break; } for (int a : l) for (int b : r) res.emplace_back(f(a, b)); } } if (res.empty()) res.emplace_back(std::stoi(input)); m_[input] = res; return m_[input]; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-964-Least-Operators-to-Express-Number.html":{"url":"Leetcode-964-Least-Operators-to-Express-Number.html","title":"Least Operators to Express Number","keywords":"","body":"Question Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3. When writing such an expression, we adhere to the following conventions: The division operator (/) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happens before addition and subtraction. It's not allowed to use the unary negation operator (-). For example, \"x - x\" is a valid expression as it only uses subtraction, but \"-x + x\" is not because it uses negation. We would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used. Example 1: Input: x = 3, target = 19 Output: 5 Explanation: 3 3 + 3 3 + 3 / 3. The expression contains 5 operations. Example 2: Input: x = 5, target = 501 Output: 8 Explanation: 5 5 5 5 - 5 5 * 5 + 5 / 5. The expression contains 8 operations. Example 3: Input: x = 100, target = 100000000 Output: 3 Explanation: 100 100 100 * 100. The expression contains 3 operations. Note: 2 1 Difficulty:Hard Category:Dynamic-Programming, Math Analyze 分析思路参考了博客： 花花酱 LeetCode 964. Least Operators to Express Number 该题目具有的性质： 因为最后求解的1 ，因此最后一定是一个整数，所以中间的正数和负数所需要的操作符号个数的相同的，因此我们仅仅考虑绝对值的情况就好了。 最后的操作符个数就是使用的x的个数减去1，相当于是最前面可以没有符号，后面的各个元素都是一个元素对应了一个符号（可能是+， -， *, /). 只有在一种情况下能够得到1，那就是x/x 如何计算得到最合适的： 搜索方式的解答过程如下图所示： 动态规划的解答方式如下图所示： Solution Solution 1: set 使用set来保存所有的中间值，利用了set可以將key进行排序存储的特殊性，每一次都处理最小的元素，这样就可以最快的找到最短的方式得到结果 class Solution { public: int leastOpsExpressTarget(int x, int target) { set> q_set; unordered_set res; q_set.emplace(0, target); while (!q_set.empty()) { const auto it = begin(q_set); const int temp_count = it->first; const int temp_target = it->second; q_set.erase(it); if (temp_target == 0) return temp_count - 1; if (res.count(temp_target)) continue; res.insert(temp_target); int n = log(temp_target) / log(x); int next_target_l = temp_target - pow(x, n); q_set.emplace(temp_count + (n == 0 ? 2 : n), next_target_l); int next_target_r = pow(x, n + 1) - temp_target; q_set.emplace(temp_count + n + 1, next_target_r); } return -1; } }; Solution 2: heap 第二种方式来自于博客文章：花花酱 LeetCode 964. Least Operators to Express Number，基本的实现思路没有变化。 class Solution { public: int leastOpsExpressTarget(int x, int target) { priority_queue, vector>, greater>> q; unordered_set s; q.emplace(0, target); while (!q.empty()) { const int c = q.top().first; const int t = q.top().second; q.pop(); if (t == 0) return c - 1; if (s.count(t)) continue; s.insert(t); int n = log(t) / log(x); int l = t - pow(x, n); q.emplace(c + (n == 0 ? 2 : n), l); int r = pow(x, n + 1) - t; q.emplace(c + n + 1, r); } return -1; } }; Solution 3: DP --- Runtime error class Solution { public: int leastOpsExpressTarget(int x, int target) { return dp(x, target); } private: unordered_map res_map; int dp(int x, int target) { if (target == 0) return 0; if (target Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-337-House-Robber-III.html":{"url":"Leetcode-337-House-Robber-III.html","title":"House Robber III","keywords":"","body":"Question The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Difficulty:Medium Category:Tree, Depth-First-Search Solution // Runtime: 1276ms 7.41% class Solution { public: int rob(TreeNode* root) { if (!root) return 0; int val = root->val; if (root->left) val += rob(root->left->left) + rob(root->left->right); if (root->right) val += rob(root->right->left) + rob(root->right->right); int val2 = rob(root->left) + rob(root->right); return max(val, val2); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-746-Min-Cost-Climbing-Stairs.html":{"url":"Leetcode-746-Min-Cost-Climbing-Stairs.html","title":"Min Cost Climbing Stairs","keywords":"","body":"Question On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. Difficulty:Easy Category:Array, Dynamic Programming Solution Solution 1: DP 这道题目不是求步数，而是每个台阶上都有一个cost，让我们求爬到顶端的最小cost是多少。这道题目还是用 Dynamic Programming 来做。这里我们定义一个一维的dp数组，其中dp[i] = 爬到第i层的最小cost，然后我们来想dp[i]如何推导。我们来思考一下如何才能到第i层呢？是不是只有两种可能性，一个是从第i-2层上直接跳上来，一个是从第i-1层上跳上来。不会再有别的方法，所以我们的dp[i]只和前两层有关系，所以可以写做如下： dp[i] = min(dp[i- 2] + cost[i - 2], dp[i - 1] + cost[i - 1]) 最后我们返回最后一个数字dp[n]即可，参见代码如下： class Solution { public: int minCostClimbingStairs(vector& cost) { int len = cost.size(); vector vec_cost(len + 1, 0); for (int i = 2; i 对空间复杂度进行优化,dp[i]仅仅依赖前面两个的值dp[i-1], dp[i-2]，所以我们不必把整个dp数组都记录下来，只需用两个变量 prev 和 cur 来记录前两个值，然后不停的用新得到的值来覆盖它们就好了。我们初始化 prev = 0, cur = 0，然后遍历 cost 数组. 优化之后空间复杂度 O(n) --> O(1) class Solution { public: int minCostClimbingStairs(vector& cost) { int prev = 0, cur = 0; for (int& c : cost) { int temp = cur; cur = min(prev, cur) + c; prev = temp; } return min(prev, cur); } }; Solution 2: Recursive class Solution { public: int minCostClimbingStairs(vector& cost) { unordered_map memo; return helper(cost, cost.size(), memo); } int helper(vector& cost, int i, unordered_map& memo) { if (memo.count(i)) return memo[i]; if (i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-674-Longest-Continuous-Increasing-Subsequence.html":{"url":"Leetcode-674-Longest-Continuous-Increasing-Subsequence.html","title":"Longest Continuous Increasing Subsequence","keywords":"","body":"Question Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray). Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1. Note: Length of the array will not exceed 10,000. Difficulty:Easy Category:Array, DP Solution Solution 1: 动态规划求解 class Solution { public: int findLengthOfLCIS(vector& nums) { if (nums.empty()) return 0; vector res(nums.size(), 1); for (int i = 1; i nums[i - 1]) res[i] = res[i - 1] + 1; } int max_res = 1; for (int i : res) max_res = max(max_res, i); return max_res; } }; Solution 2: 优化 class Solution { public: int findLengthOfLCIS(vector& nums) { if (nums.empty()) return 0; int cur = 1; int ans = 1; for (int i = 1; i nums[i - 1]) { ++cur; ans = max(cur, ans); } else cur = 1; } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-64-Minimum-Path-Sum.html":{"url":"Leetcode-64-Minimum-Path-Sum.html","title":"Minimum Path Sum","keywords":"","body":"Question Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Difficulty:Medium Category:Array, Dynamic-Programming Solution // f[i][j]=min(f[i-1][j], f[i][j-1])+grid[i][j] class Solution { public: int minPathSum(vector>& grid) { if (grid.empty()) return 0; const unsigned int m = grid.size(), n = grid[0].size(); int f[m][n]; f[0][0] = grid[0][0]; for (unsigned int i = 1; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-70-Climbing-Stairs.html":{"url":"Leetcode-70-Climbing-Stairs.html","title":"Climbing Stairs","keywords":"","body":"Question You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step Difficulty:Easy Category:DP Analyze 假设f(n)表示爬到n阶阶梯，的不同方法数量，为了爬到第n阶阶梯，有两种情况： 从第n-1阶前进1步 从第n-1阶前进2步 所以这就可以得到：f(n) = f(n-1) + f(n-2) 这就是一个斐波那契数列，所以这一个题目相当于是求解第n个参数的数值。 方案二： 斐波那契数列的第n项计算公式为： Solution Solution 1: Top-Down Dynamic Programming(Or Memoization) class Solution { public: int climbStairs(int n) { vector rec(n + 1, 0); return climbStairs(n, rec); } private: int climbStairs(int n, vector& rec) { if (n Buttom-Up Dynamic Programming class Solution { public: int climbStairs(int n) { if (n = 0; vector rec(n, 1);　// rec[0] = 1, rec[1] = 1 for (int i = 2; i We don't need the meno[n], we use a, b: class Solution { public: int climbStairs(int n) { int prev = 0; int cur = 1; for (int i = 1; i Solution 2:使用公式直接计算 class Solution { public: int climbStairs(int n) { const double s = sqrt(5); return floor((pow((1 + s) / 2, n + 1) + pow((1 - s) / 2, n + 1)) / s + 0.5); } }; Other Question 如果將这个题目稍微修改一下: Triple Step: A child is running up a staircase with n steps and can hop either 1 step, 2 steps, or 3 steps at a time. Implement a method to count how many possible ways the child can run up the stairs. Let's think about: What is the lastest step that is done: The very last step: 3-step hop, a 2-step hop, or 1-step hop. How many ways then are there to get up to the n-th step? We can get up to the n-th step by any of the following. Going to the (n -1)-st step and hopping 1 step; Goint to the (n-2)nd step and hopping 2 steps; Going to the (n-3)rd step and hopping 3 steps; Then, We just need to add the number of these paths together. Solution Solution 1: Brute Force Solution First, the fairly straightforward algorithm to implement recursively, followed logic: countWays(n-1) + countWays(n-2) + countWays(n-3) There is a quesiton: what is countWays(0)? Is it 1 or ) It's a lot earier to define it as 1. Implementation code. int countWays(int n) { if(n Like the Fibonacci problem, the runtime of this algorithm is exponential($O(3^n)$). Solution 2: Add Memoization in this Solution 1 The previous solution for countWays is called many times for the same values, which is unnecessary. We need to fix it. class Solution { public: int climbStairs(int n) { vector rec(n + 1, -1); return countWays(n, rec); } private: int countWays(int n, vector& rec) { if (n -1) { return rec[n]; } else { rec[n] = climbStairs(n - 1, rec) + climbStairs(n - 2, rec) + climbStairs(n - 3, rec); return rec[n]; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-357-Count-Numbers-with-Unique-Digits.html":{"url":"Leetcode-357-Count-Numbers-with-Unique-Digits.html","title":"Count Numbers with Unique Digits","keywords":"","body":"Question Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x Example: Input: 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 ≤ x 11,22,33,44,55,66,77,88,99 Difficulty:Medium Category:Math, Dynamic-Programming, Backtracking Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-967-Numbers-With-Same-Consecutive-Differences.html":{"url":"Leetcode-967-Numbers-With-Same-Consecutive-Differences.html","title":"Numbers With Same Consecutive Differences","keywords":"","body":"Question Return all non-negative integers of length N such that the absolute difference between every two consecutive digits is K. Note that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid. You may return the answer in any order. Example 1: Input: N = 3, K = 7 Output: [181,292,707,818,929] Explanation: Note that 070 is not a valid number, because it has leading zeroes. Example 2: Input: N = 2, K = 1 Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98] Note: 1 0 Difficulty:Medium Category: Solution 1 class Solution { public: vector numsSameConsecDiff(int N, int K) { vector ans; if (N == 1) ans.emplace_back(0); for (int i = 1; i & ans) { if (N == 0) { ans.emplace_back(num); return; } int last = num % 10; if (last + K = 0 & K > 0) { int cur = last - K; numsSameConsecDiff(num * 10 + cur, N - 1, K, ans); } } }; Solution 2 typedef long long ll; typedef vector VI; typedef pair PII; #define REP(i, s, t) for (int i = (s); i numsSameConsecDiff(int _N, int _K) { N = _N; K = _K; VI ans; if (N == 1) { REP(i, 0, 10) ans.push_back(i); return ans; } REP(s, 1, 10) solve(1, s, s, ans); return ans; } private: void solve(int i, int ld, int val, VI &ans) { // DFS return value if (i == N) { ans.push_back(val); return; } REP(t, 0, 2) { // Two situation in this loop // - or + int d = t == 0 ? ld + K : ld - K; if (K == 0 && t == 1) continue; if (0 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-973-K-Closest-Points-to-Origin.html":{"url":"Leetcode-973-K-Closest-Points-to-Origin.html","title":"K Closest Points to Origin","keywords":"","body":"Question We have a list of points on the plane. Find the K closest points to the origin (0, 0). (Here, the distance between two points on a plane is the Euclidean distance.) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.) Example 1: Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) Example 2: Input: points = [[3,3],[5,-1],[-2,4]], K = 2 Output: [[3,3],[-2,4]] (The answer [[-2,4],[3,3]] would also be accepted.) Note: 1 -10000 -10000 Difficulty:Easy Category:Math, Divide-And-Conquer, Sort Solution bool comp(vector a, vector b) { return a[0] * a[0] + a[1] * a[1] > kClosest(vector>& points, int K) { sort(points.begin(), points.end(), comp); vector> p(points.begin(), points.begin() + K); return p; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-726-Number-of-Atoms.html":{"url":"Leetcode-726-Number-of-Atoms.html","title":"Number of Atoms","keywords":"","body":"Question Given a chemical formula (given as a string), return the count of each atom. An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name. 1 or more digits representing the count of that element may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible. Two formulas concatenated together produce another formula. For example, H2O2He3Mg4 is also a formula. A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas. Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. Example 1: Input: formula = \"H2O\" Output: \"H2O\" Explanation: The count of elements are {'H': 2, 'O': 1}. Example 2: Input: formula = \"Mg(OH)2\" Output: \"H2MgO2\" Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}. Example 3: Input: formula = \"K4(ON(SO3)2)2\" Output: \"K4N2O14S4\" Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}. Note: All atom names consist of lowercase letters, except for the first character which is uppercase. The length of formula will be in the range [1, 1000]. formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem. Difficulty:Hard Category:Hash-Table, Stack, Recursion Analyze 题目描述： 给你一个分子方程式，返回去每个原子的个数（判断化学式是否是符合题目含义的）。 思路： 使用Map存储每个部分得到的ATOM和‘Count’ Solution 递归的方案 // Solution: Recursion // Time complexity: O(n) // Space complexity: O(n) // Runtime: 4ms class Solution { public: string countOfAtoms(string formula) { int i = 0; string ans; for (const auto& atom : countAtoms(formula, i)) { ans += atom.first; if (atom.second > 1) ans += to_string(atom.second); } return ans; } private: map countAtoms(string& formula, int& i) { map counts; while (i != formula.length()) { if (formula[i] == '(') { // Do Something to get name and number // Dealwith the information between `(` and `)` const auto& counts_ = countAtoms(formula, ++i); const int count = getCount(formula, i); for (auto& k : counts_) { counts[k.first] += k.second * count; } } else if (formula[i] == ')') { ++i; // Finish one Parentntheses, return the counts for this parentntheses return counts; } else { const string& name = getName(formula, i); counts[name] += getCount(formula, i); } } return counts; } const string getName(string& formula, int& i) { string name; while (isalpha(formula[i]) && (name.empty() || islower(formula[i]))) name += formula[i++]; return name; } const int getCount(string& formula, int& i) { string count_str; while (isdigit(formula[i])) count_str += formula[i++]; return count_str.empty() ? 1 : std::stoi(count_str); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-621-Task-Scheduler.html":{"url":"Leetcode-621-Task-Scheduler.html","title":"Task Scheduler","keywords":"","body":"Question Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. You need to return the least number of intervals the CPU will take to finish all the given tasks. Example: **Input:** tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2 **Output:** 8 **Explanation:** A -> B -> idle -> A -> B -> idle -> A -> B. Note: The number of tasks is in the range [1, 10000]. The integer n is in the range [0, 100]. Difficulty:Medium Category:Array, Greedy, Queue Solution class Solution { public: int leastInterval(vector& tasks, int n) { vector count(26, 0); for (const char& t : tasks) ++count[t - 'A']; const int max_count = *max_element(count.begin(), count.end()); size_t ans = (max_count - 1) * (n + 1); ans += count_if(count.begin(), count.end(), [max_count](int x) { return x == max_count; }); return max(tasks.size(), ans); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-729-My-Calendar-I.html":{"url":"Leetcode-729-My-Calendar-I.html","title":"My Calendar I","keywords":"","body":"Question Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking. Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start . A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.) For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) Example 1: MyCalendar(); MyCalendar.book(10, 20); // returns true MyCalendar.book(15, 25); // returns false MyCalendar.book(20, 30); // returns true Explanation: The first event can be booked. The second can't because time 15 is already booked by another event. The third event can be booked, as the first event takes every time less than 20, but not including 20. Note: The number of calls to MyCalendar.book per test case will be at most 1000. In calls to MyCalendar.book(start, end), start and endare integers in the range [0, 10^9]. Difficulty:Medium Category:Array, Range, Binary-Search Analyze Understanding the Problem, some requirments for this problem: A new event can be added if adding the event will not cause a double booking. The range [start, end) Solution class MyCalendar { public: MyCalendar() {} bool book(int start, int end) { for (const auto& event : booked_) { int e_start = event.first, e_end = event.second; if (max(e_start, start) > booked_; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-551-Student-Attendance-Record-I.html":{"url":"Leetcode-551-Student-Attendance-Record-I.html","title":"Student Attendance Record I","keywords":"","body":"Question You are given a string representing an attendance record for a student. The record only contains the following three characters: 'A' : Absent. 'L' : Late. 'P' : Present. A student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late). You need to return whether the student could be rewarded according to his attendance record. Example 1: Input: \"PPALLP\" Output: True Example 2: Input: \"PPALLL\" Output: False Solution class Solution { public: bool checkRecord(string s) { int absent_nums = 0, late_con = 0; for(int i = 0; i 1) return false; late_con = 0; }else if (s[i] == 'L'){ if (++late_con > 2) return false; } else late_con = 0; } return true; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-609-Find-Duplicate-File-in-System.html":{"url":"Leetcode-609-Find-Duplicate-File-in-System.html","title":"Find Duplicate File in System","keywords":"","body":"Question Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. A group of duplicate files consists of at least two files that have exactly the same content. A single directory info string in the input list has the following format: \"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\" It means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory. The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: \"directory_path/file_name.txt\" Example 1: Input: [\"root/a 1.txt(abcd) 2.txt(efgh)\", \"root/c 3.txt(abcd)\", \"root/c/d 4.txt(efgh)\", \"root 4.txt(efgh)\"] Output:[ [\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"] ] Note: No order is required for the final output. You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50]. The number of files given is in the range of [1,20000]. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space. Follow-up beyond contest: Imagine you are given a real file system, how will you search files? DFS or BFS? If the file content is very large (GB level), how will you modify your solution? If you can only read the file by 1kb each time, how will you modify your solution? What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize? How to make sure the duplicated files you find are not false positive? --# Solution Solution 1 class Solution { public: vector> findDuplicate(vector& paths) { vector> res; unordered_set contents; std::multimap mymm; int cnt = 0; for (string s : paths) { string dir_path, content; std::size_t file_begin = s.find_first_of(\" \"); if (file_begin != std::string::npos) dir_path = s.substr(0, file_begin); bool final_file = false; std::size_t file_end = s.find_first_of(\" \", file_begin + 1); if (file_end == std::string::npos) { final_file = true; file_end = s.size(); } while (file_end != std::string::npos) { string path, file; file = s.substr(file_begin + 1, file_end - file_begin - 1); std::size_t content_begin = file.find_first_of(\"(\"); std::size_t content_end = file.find_first_of(\")\", content_begin + 1); path = dir_path + \"/\" + file.substr(0, content_begin); content = file.substr(content_begin + 1, content_end - content_begin - 1); file_begin = file_end; file_end = s.find_first_of(\" \", file_begin + 1); if (final_file == false && file_end == std::string::npos) { final_file = true; file_end = s.size(); } contents.emplace(content); mymm.insert(std::make_pair(content, path)); } } for (const std::string& x : contents) { int dup_nums = mymm.count(x); if (dup_nums > 1) { vector dupfiles; dupfiles.reserve(dup_nums); for (auto it = mymm.equal_range(x).first; it != mymm.equal_range(x).second; ++it) { dupfiles.emplace_back((*it).second); } res.emplace_back(dupfiles); } } return res; } }; Solution 2 class Solution { public: vector> findDuplicate(vector& paths) { vector> res; unordered_set contents; std::multimap mymm; int cnt = 0; for(string s : paths) { string dir_path, content, file; istringstream stream(s); stream >> dir_path; while(stream >> file){ string path; std::size_t content_begin = file.find_first_of(\"(\"); std::size_t content_end = file.find_first_of(\")\", content_begin+1); path = dir_path +\"/\"+ file.substr(0, content_begin); content = file.substr(content_begin+1, content_end-content_begin-1); contents.emplace(content); mymm.insert(std::make_pair(content, path)); } for (const std::string& x: contents) { int dup_nums = mymm.count(x); if( dup_nums > 1){ vector dupfiles; dupfiles.reserve(dup_nums); for (auto it=mymm.equal_range(x).first; it!=mymm.equal_range(x).second; ++it) { dupfiles.emplace_back((*it).second); } res.emplace_back(dupfiles); } } return res; } }; Solution 3 Copy from Find Duplicate File in System 在系统中寻找重复文件 class Solution { public: vector> findDuplicate(vector& paths) { vector> res; unordered_map> m; for (string path : paths) { istringstream is(path); string pre = \"\", t = \"\"; is >> pre; while (is >> t) { int idx = t.find_last_of('('); string dir = pre + \"/\" + t.substr(0, idx); string content = t.substr(idx + 1, t.size() - idx - 2); m[content].push_back(dir); } } for (auto a : m) { if (a.second.size() > 1)res.push_back(a.second); } return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-736-Parse-Lisp-Expression.html":{"url":"Leetcode-736-Parse-Lisp-Expression.html","title":"Parse Lisp Expression","keywords":"","body":"Question You are given a string expression representing a Lisp-like expression to return the integer value of. The syntax for these expressions is given as follows. An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable. Expressions always evaluate to a single integer. (An integer could be positive or negative.) A let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string \"let\", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr. An add-expression takes the form (add e1 e2) where add is always the string \"add\", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2. A mult-expression takes the form (mult e1 e2) where mult is always the string \"mult\", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2. For the purposes of this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names. Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on scope. Evaluation Examples: Input: (add 1 2) Output: 3 Input: (mult 3 (add 2 3)) Output: 15 Input: (let x 2 (mult x 5)) Output: 10 Input: (let x 2 (mult x (let x 3 y 4 (add x y)))) Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3. Input: (let x 3 x 2 x) Output: 2 Explanation: Assignment in let statements is processed sequentially. Input: (let x 1 y 2 x (add x y) (add x y)) Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5. Input: (let x 2 (add (let x 3 (let x 4 x)) x)) Output: 6 Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context of the final x in the add-expression. That final x will equal 2. Input: (let a1 3 b2 (add a1 1) b2) Output 4 Explanation: Variable names can contain digits after the first character. Note: The given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses. The expression is guaranteed to be legal and evaluate to an integer. The length of expression is at most 2000. (It is also non-empty, as that would not be a legal expression.) The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer. Difficulty:Hard Category:String Analyze 嵌套的问题一般使用递归来解决 表达式一般只有三种情况，如上图所示： 数字开头 变量名 括号开头---函数（add, mult, let）,其中的add, mult对应的两个数值 最后的输出就是一个表达式 递归表达式：完整的处理一个表达式，遇到括号，就进入新的表达式 如果读取到括号，那就返回一个表达式的数值。 虽然上面看上去只有两个部分，但是其实有五个expr的处理过程 考虑如何处理scope： 在这一个题目中，变量的名字是可以嵌套的的，这就是在里面的话，是没有办法得到外面的变量数据的的，只能使用内部的变量数据，这就会使得处理过程比较复杂了。在这里可能需要使用到stack的方式，来处理。并且在function call之后的话进行退栈。 Solution // Solution: Recursive parsing // Time complexity: O(n^2) in worst case O(n) in practice // Space complexity: O(n) // Runtime: 4ms class Solution { public: int evaluate(string expression) { scopes_.clear(); int pos = 0; return eval(expression, pos); } private: deque> scopes_; // Function to deal with whole expression int eval(string& exp, int& pos) { scopes_.push_front(unordered_map()); int value = 0; // Deal with the first '(' if (exp[pos] == '(') ++pos; const string token = getToken(exp, pos); if (token == \"add\") { int v1 = eval(exp, ++pos), v2 = eval(exp, ++pos); value = v1 + v2; } else if (token == \"mult\") { int v1 = eval(exp, ++pos), v2 = eval(exp, ++pos); value = v1 * v2; } else if (token == \"let\") { string val; while (exp[pos] != ')') { ++pos; // Pass the space if (exp[pos] == '(') { value = eval(exp, ++pos); break; } // Get a Token: x or number(last express) val = getToken(exp, pos); // This Token is the last express; if (exp[pos] == ')') { if (isalpha(val[0])) { value = getValue(val); } else { // This is a number(int) value = std::stoi(val); } // 处理完了 break; } // 如果最后不是右括号，那么就说明这是一个变量名字 value = scopes_.front()[val] = eval(exp, ++pos); } } else if (isalpha(token[0])) { value = getValue(token); } else { // This is a number(int) value = std::stoi(token); } if (exp[pos] == ')') ++pos; scopes_.pop_front(); return value; } // Get the Important Token: let, add, mul, number, string const string getToken(string& exp, int& pos) { string token; while (pos Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-146-LRU-Cache.html":{"url":"Leetcode-146-LRU-Cache.html","title":"LRU Cache","keywords":"","body":"Question Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 / capacity / ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 Difficulty:Medium Category:Design Analyze 刚开始没看明白要实现什么东西，看了一些LRU缓存器的介绍之后，明白了这就是实现一个LRU(Least Recently Used)最近最少使用的缓存器，这个缓存器有两个函数。 Get函数 Put函数 Get函数：根据输入key获取value,如果没有，那么就返回-1 这个函数可以分为以下几个小的部分去实现： 查找hashmap，如果没有找到就返回-1 如果找到这个数值，那就把对应的在cacheList里面的元素位置换到List的最前面来，实现最近使用的放在最前面，修改了cacheList里面该元素的位置之后，更新Hashmap里面的值 put函数: 插入一对新的(key, value)，如果原缓存器中有该key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。 查找是否当前cacheMap里面存在当前元素 如果没有当前元素： 就检查是否超过的容量，若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值, 也就是删除cacheList里面的最后一个元素 没有当前元素，超出容量的话：删除最少使用的元素; 然后将当前元素插入到cacheList的第一个位置，并设置cacheMap里面的数值。 如果有当前元素：直接通过Hashmap修改元素在List里面的数值，并将这个元素转移到List的最前面。 Solution // Do both operations in O(1) time complexity class LRUCache { public: LRUCache(int capacity) { this->capacity = capacity; } int get(int key) { if (cacheMap.find(key) == cacheMap.end()) return -1; // Update the location of the CacheNode(key, value) // Trasfer the CacheMap[Key] from the cacheList to the cacheList.begin() cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]); cacheMap[key] = cacheList.begin(); return cacheMap[key]->value; } void put(int key, int value) { // 1. If there is a key in the List, then delete it and insert the new one if (cacheMap.find(key) == cacheMap.end()) { if (cacheList.size() == capacity) { // Delete the last element cacheMap.erase(cacheList.back().key); // cacheList.erase(cacheList.back()); cacheList.pop_back(); } cacheList.push_front(CacheNode(key, value)); cacheMap[key] = cacheList.begin(); } else { cacheMap[key]->value = value; cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]); } // 2. If there is no key in the list, then insert it and put it to the begin. // After insert the element, if the new capacity is over than default capacity, // then delete the last one element in the List. } private: struct CacheNode { int key; int value; CacheNode(int k, int v) : key(k), value(v) {} }; list cacheList; unordered_map::iterator> cacheMap; int capacity; }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ class LRUCache{ public: LRUCache(int capacity) { cap = capacity; } int get(int key) { auto it = m.find(key); if (it == m.end()) return -1; l.splice(l.begin(), l, it->second); return it->second->second; } void put(int key, int value) { auto it = m.find(key); if (it != m.end()) l.erase(it->second); l.push_front(make_pair(key, value)); m[key] = l.begin(); if (m.size() > cap) { int k = l.rbegin()->first; l.pop_back(); m.erase(k); } } private: int cap; list> l; unordered_map>::iterator> m; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-385-Mini-Parser.html":{"url":"Leetcode-385-Mini-Parser.html","title":"Mini Parser","keywords":"","body":"Question Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ]. Example 1: Given s = \"324\", You should return a NestedInteger object which contains a single integer 324. Example 2: Given s = \"[123,[456,[789]]]\", Return a NestedInteger object containing a nested list with 2 elements: An integer containing value 123. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789. Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-537-Complex-Number-Multiplication.html":{"url":"Leetcode-537-Complex-Number-Multiplication.html","title":"Complex Number Multiplication","keywords":"","body":"Question Given two strings representing two complex numbers. You need to return a string representing their multiplication. Note i2 = -1 according to the definition. Example 1: Input: \"1+1i\", \"1+1i\" Output: \"0+2i\" Explanation: (1 + i) (1 + i) = 1 + i2 + 2 i = 2i, and you need convert it to the form of 0+2i. Example 2: Input: \"1+-1i\", \"1+-1i\" Output: \"0+-2i\" Explanation: (1 - i) (1 - i) = 1 + i2 - 2 i = -2i, and you need convert it to the form of 0+-2i. Note: The input strings will not have extra blank. The input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form. Solution class Solution { public: string complexNumberMultiply(string a, string b) { std::string res; int a1, a2, b1, b2, r1, r2; int len_a = a.size(), len_b = b.size(); auto p1 = a.find_last_of(\"+\"), p2 = b.find_last_of(\"+\"); a1 = stoi(a.substr(0, p1)); b1 = stoi(b.substr(0, p2)); a2 = stoi(a.substr(p1 + 1, len_a - p1 - 1)); b2 = stoi(b.substr(p2 + 1, len_b - p2 - 1)); r1 = a1 * b1 - a2 * b2; r2 = a1 * b2 + a2 * b1; res = to_string(r1) + \"+\" + to_string(r2) + \"i\"; return res; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-539-Minimum-Time-Difference.html":{"url":"Leetcode-539-Minimum-Time-Difference.html","title":"Minimum Time Difference","keywords":"","body":"Question Given a list of 24-hour clock time points in \"Hour:Minutes\" format, find the minimum minutes difference between any two time points in the list. Example 1: Input: [\"23:59\",\"00:00\"] Output: 1 Note: The number of time points in the given list is at least 2 and won't exceed 20000. The input time is legal and ranges from 00:00 to 23:59. Solution class Solution { public: int findMinDifference(vector& timePoints) { int min; vector times; for (string t : timePoints) { int idx = t.find_last_of(':'); string hour = t.substr(0, idx); string minutes = t.substr(idx + 1, t.size() - idx - 1); int time = std::stoi(hour) * 60 + std::stoi(minutes); times.emplace_back(time); } std::sort(times.begin(), times.end()); for (auto i : times) std::cout Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-553-Optimal-Division.html":{"url":"Leetcode-553-Optimal-Division.html","title":"Optimal Division","keywords":"","body":"Question Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis. Example: Input: [1000,100,10,2] Output: \"1000/(100/10/2)\" Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in \"1000/((100/10)/2)\" are redundant, since they don't influence the operation priority. So you should return \"1000/(100/10/2)\". Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2 Note: The length of the input array is [1, 10]. Elements in the given array will be in range [2, 1000]. There is only one optimal division for each test case. Solution class Solution { public: string optimalDivision(vector& nums) { if (nums.size() == 0) return \"\"; string res = to_string(nums[0]); if (nums.size() == 1) return res; else if (nums.size() == 2) { res = res + \"/\" + to_string(nums[1]); } else { res = res + \"/(\" + to_string(nums[1]); for (int i = 2; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-567-Permutation-in-String.html":{"url":"Leetcode-567-Permutation-in-String.html","title":"Permutation in String","keywords":"","body":"Question Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string. Example 1: Input:s1 = \"ab\" s2 = \"eidbaooo\" Output:True Explanation: s2 contains one permutation of s1 (\"ba\"). Example 2: Input: s1= \"ab\" s2 = \"eidboaoo\" Output: False Note: The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000]. Solution class Solution { public: bool checkInclusion(string s1, string s2) { int n1 = s1.size(), n2 = s2.size(); vector vec1(127), vec2(127); for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-657-Robot-Return-To-Origin.html":{"url":"Leetcode-657-Robot-Return-To-Origin.html","title":"Robot Return To Origin","keywords":"","body":"Question There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0)after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is \"facing\" is irrelevant. \"R\" will always make the robot move to the right once, \"L\" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move. Example 1: Input: \"UD\" Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. Example 2: Input: \"LL\" Output: false Explanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves. Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-673-Number-of-Longest-Increasing-Subsequence.html":{"url":"Leetcode-673-Number-of-Longest-Increasing-Subsequence.html","title":"Number of Longest Increasing Subsequence","keywords":"","body":"Question Given an unsorted array of integers, find the number of longest increasing subsequence. Example 1: Input: [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7]. Example 2: Input: [2,2,2,2,2] Output: 5 Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5. Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int. Difficulty:Medium Category:Dynamic-Programming Solution Solution 1:　递归 参考博客：花花酱 LeetCode 673. Number of Longest Increasing // Runtime: 80ms class Solution { public: int findNumberOfLIS(vector& nums) { if (nums.empty()) return 0; const int n = nums.size(); f_ = vector(n, 0); c_ = vector(n, 0); // max_len must be difined in local, it will changed in the count function int max_len = 0; for (int i = 0; i c_; vector f_; int count(const vector& nums, int n) { if (n == 0) return 1; if (c_[n] > 0) return c_[n]; int max_len = LIS(nums, n); int total_count = 0; for (int i = 0; i nums[i] && LIS(nums, i) == max_len - 1) { total_count += count(nums, i); } } 　　 //如果数量为０，那就是在之前找不到一个子集，所以就只能使用这一个数字作为１，就是单个元素的情况 if (total_count == 0) { total_count = 1; } c_[n] = total_count; return c_[n]; } int LIS(const vector& nums, int r) { if (r == 0) return 1; if (f_[r] > 0) return f_[r]; int ans = 1; for (int i = 0; i nums[i]) { ans = max(ans, LIS(nums, i) + 1); } } f_[r] = ans; return f_[r]; } }; Solution 2: 动态规划 nums[j]) { if (f[j] + 1 > f[i]) { f[i] = f[j] + 1; c[i] = c[j]; } else if (f[j] + 1 == f[i]) { c[i] += c[j]; } --> // Solution2: Dynamic-Programming // Runtime: 32ms class Solution { public: int findNumberOfLIS(vector& nums) { if (nums.empty()) return 0; int n = nums.size(); vector f(n, 1); vector c(n, 1); // f[i] 表示前面的元素可以组合得到的最长的元素之和 for (int i = 1; i nums[j]) { if (f[j] + 1 > f[i]) { f[i] = f[j] + 1; //新的解，但是数量却没有变化的 c[i] = c[j]; } else if (f[j] + 1 == f[i]) { //之前的最长子序列加一的长度和现在的长度相等，那么就表示可以把之前的子序列的长度归入到这里面进行统计 c[i] += c[j]; } } int max_len = *std::max_element(f.begin(), f.end()); int ans = 0; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-717-1-bit-and-2-bit-characters.html":{"url":"Leetcode-717-1-bit-and-2-bit-characters.html","title":"1 bit and 2 bit characters","keywords":"","body":"Question We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input: bits = [1, 0, 0] Output: True Explanation: The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: Input: bits = [1, 1, 1, 0] Output: False Explanation: The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note: 1 . bits[i] is always 0 or 1. -# Solution class Solution { public: bool isOneBitCharacter(vector& bits) { int i = 0; while (i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-724-Find-Pivot-Index.html":{"url":"Leetcode-724-Find-Pivot-Index.html","title":"Find Pivot Index","keywords":"","body":"Question Given an array of integers nums, write a method that returns the \"pivot\" index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example 1: Input: nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs. Example 2: Input: nums = [1, 2, 3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement. Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000]. -# Solution class Solution { public: int pivotIndex(vector& nums) { int sum = 0, curSum = 0; for (int i : nums) sum += i; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-747-Largest-Number-At-Least-Twice-Of-Others.html":{"url":"Leetcode-747-Largest-Number-At-Least-Twice-Of-Others.html","title":"Largest Number At Least Twice Of Others","keywords":"","body":"Question In a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x, 6 is more than twice as big as x. The index of value 6 is 1, so we return 1. Example 2: Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn't at least as big as twice the value of 3, so we return -1. Note: nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99]. -# Solution class Solution { public: int dominantIndex(vector& nums) { int preMax = 0, curMax = 0, maxIndex = 0; for (int i = 0; i curMax) { maxIndex = i; preMax = curMax; curMax = nums[i]; } else if (nums[i] > preMax) preMax = nums[i]; } return curMax >= 2 * preMax ? maxIndex : -1; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-788-Rotated-Digits.html":{"url":"Leetcode-788-Rotated-Digits.html","title":"Rotated Digits","keywords":"","body":"Question X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? Example: Input: 10 Output: 4 Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9. Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. Note: N will be in range [1, 10000]. Analyze Solution class Solution { public: int rotatedDigits(int N) { int res = 0; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-890-Find-And-Replace-Pattern.html":{"url":"Leetcode-890-Find-And-Replace-Pattern.html","title":"Find And Replace Pattern","keywords":"","body":"Question You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern. You may return the answer in any order. Example 1: Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\" Output: [\"mee\",\"aqq\"] Explanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter. Note: 1 1 Solution class Solution { public: vector findAndReplacePattern(vector& words, string pattern) { vector res; for (auto w : words) { string s = w; vector vec(127), vec_p(127); for (char c : pattern) vec_p[c] = 1; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-739-Daily-Temperatures.html":{"url":"Leetcode-739-Daily-Temperatures.html","title":"Leetcode 739. Daily Temperatures","keywords":"","body":"Question Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0]. Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100]. Difficulty:Medium Category:Hash-Table, Stack Solution // So slow class Solution { public: vector dailyTemperatures(vector& t) { int n = t.size(); for (int i = 0; i t[i]) { t[i] = j - i; break; } if (j == n - 1) t[i] = 0; } } return t; } }; Solution 2 来源于讨论区: Link class Solution { public: vector dailyTemperatures(vector& temps) { int n = temps.size(); vector waits(n, 0); vector next(101, INT_MAX); // next day with with certain temperature. for (int i = n - 1; i >= 0; i--) { int earliest = INT_MAX; for (int t = temps[i] + 1; t Solution 3 还没有看懂的解法: Link-time-and-O(1)-space-(beats-99.13)) vector dailyTemperatures(vector& temperatures) { vector res(temperatures.size()); for (int i = temperatures.size() - 1; i >= 0; --i) { int j = i + 1; while (j 0) j = res[j] + j; else j = temperatures.size(); } // either j == size || temperatures[j] > temperatures[i] if (j Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-503-Next-Greater-Element-II.html":{"url":"Leetcode-503-Next-Greater-Element-II.html","title":"Leetcode 503. Next Greater Element II","keywords":"","body":"Question Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number. Example 1: Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2. Note: The length of given array won't exceed 10000. Difficulty:Medium Category:Stack Analyze 这里的输入数组是一个循环数组, 我们首先想到的是循环遍历数组, 每一个元素向后找到第一个比它大的元素, 找到第一个之后就停止. Solution class Solution { public: vector nextGreaterElements(vector& nums) { int n = nums.size(); vector ans(n, -1); for (int i = 0; i nums[i]) { ans[i] = nums[j % n]; break; } } } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:14 "},"Leetcode-636-Exclusive-Time-of-Functions.html":{"url":"Leetcode-636-Exclusive-Time-of-Functions.html","title":"Leetcode 636. Exclusive Time of Functions","keywords":"","body":"Question Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions. Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function. A log is a string has this format : function_id:start_or_end:timestamp. For example, \"0:start:0\" means function 0 starts from the very beginning of time 0. \"0:end:0\" means function 0 ends to the very end of time 0. Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id. Example 1: Input: n = 2 logs = [\"0:start:0\", \"1:start:2\", \"1:end:5\", \"0:end:6\"] Output:[3, 4] Explanation: Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5. Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time. Note: Input logs will be sorted by timestamp, NOT log id. Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0. Two functions won't start or end at the same time. Functions could be called recursively, and will always end. 1 Difficulty:Medium Category: Analyze 题目大意：给你一些函数的起始/终止时间的日志，让你输出每个函数的总运行时间。假设单核单线程，支持递归函数。 Notes: 输入的日志数据是按照时间戳排序的, 而不是日志的进程ID号码 输出的结果需要按照函数的ID号码进行排序 两个函数不能够开始和结束在同一个时间的. 函数是可以递归调用的, 并且一定能够结束 1 Solution Using Stack // Runtime: 16 ms, faster than 95.40% of C++ online submissions for Exclusive Time of Functions. // Memory Usage: 827.4 KB, less than 11.11% of C++ online submissions for Exclusive Time of Functions. class Solution { public: vector exclusiveTime(int n, vector& logs) { vector ans(n, 0); stack sta; int pretime = 0; for (auto& s : logs) { int f1 = s.find(\":\"), f2 = s.find_last_of(\":\"); int idx = stoi(s.substr(0, f1)), time = stoi(s.substr(f2 + 1)); string type = s.substr(f1 + 1, f2 - f1 - 1); if (!sta.empty()) ans[sta.top()] += time - pretime; pretime = time; if (type == \"start\") sta.push(idx); else { ++ans[sta.top()]; sta.pop(); ++pretime; } } return ans; } }; 优化, 参考了网上博客文章: 可以使用sscanf函数, 一次得到三个变量的数值. // Runtime: 16 ms, faster than 95.40% of C++ online submissions for Exclusive Time of Functions. // Memory Usage: 827.4 KB, less than 11.11% of C++ online submissions for Exclusive Time of Functions. class Solution { public: vector exclusiveTime(int n, vector& logs) { vector ans(n, 0); stack sta; int idx = 0, time = 0; char type[10]; int pretime = 0; for (auto& s : logs) { sscanf(s.c_str(), \"%d:%[^:]:%d\", &idx, type, &time); if (!sta.empty()) ans[sta.top()] += time - pretime; pretime = time; if (type[0] == 's') sta.push(idx); else { ++ans[sta.top()]; sta.pop(); ++pretime; } } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-975-Odd-Even-Jump.html":{"url":"Leetcode-975-Odd-Even-Jump.html","title":"Leetcode 975. Odd Even Jump","keywords":"","body":"Question You are given an integer array A. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps. You may from index i jump forward to index j (with i ) in the following way: During odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that A[i] and A[j] is the smallest possible value. If there are multiple such indexes j, you can only jump to the smallest such index j. During even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that A[i] >= A[j] and A[j] is the largest possible value. If there are multiple such indexes j, you can only jump to the smallest such index j. (It may be the case that for some index i, there are no legal jumps.) A starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.) Return the number of good starting indexes. Example 1: Input: [10,13,12,14,15] Output: 2 Explanation: From starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can't jump any more. From starting index i = 1 and i = 2, we can jump to i = 3, then we can't jump any more. From starting index i = 3, we can jump to i = 4, so we've reached the end. From starting index i = 4, we've reached the end already. In total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps. Example 2: Input: [2,3,1,1,4] Output: 3 Explanation: From starting index i = 0, we make jumps to i = 1, i = 2, i = 3: During our 1st jump (odd numbered), we first jump to i = 1 because A[1] is the smallest value in (A[1], A[2], A[3], A[4]) that is greater than or equal to A[0]. During our 2nd jump (even numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in (A[2], A[3], A[4]) that is less than or equal to A[1]. A[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3. During our 3rd jump (odd numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in (A[3], A[4]) that is greater than or equal to A[2]. We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good. In a similar manner, we can deduce that: From starting index i = 1, we jump to i = 4, so we reach the end. From starting index i = 2, we jump to i = 3, and then we can't jump anymore. From starting index i = 3, we jump to i = 4, so we reach the end. From starting index i = 4, we are already at the end. In total, there are 3 different starting indexes (i = 1, i = 3, i = 4) where we can reach the end with some number of jumps. Example 3: Input: [5,1,3,4,2] Output: 3 Explanation: We can reach the end from starting indexes 1, 2, and 4. Note: 1 0 Difficulty:Medium Category: Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-985-Sum-of-Even-Numbers-After-Queries.html":{"url":"Leetcode-985-Sum-of-Even-Numbers-After-Queries.html","title":"Leetcode 985. Sum of Even Numbers After Queries","keywords":"","body":"Question We have an array A of integers, and an array queries of queries. For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index]. Then, the answer to the i-th query is the sum of the even values of A. (Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.) Return the answer to all queries. Your answer array should have answer[i] as the answer to the i-th query. Example 1: Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]] Output: [8,6,2,4] Explanation: At the beginning, the array is [1,2,3,4]. After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8. After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6. After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2. After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4. Note: 1 -10000 1 -10000 0 Difficulty:Easy Category: Solution class Solution { public: vector sumEvenAfterQueries(vector& A, vector>& q) { int n = q.size(); vector ans(n, 0); for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-682-Baseball-Game.html":{"url":"Leetcode-682-Baseball-Game.html","title":"Leetcode 682. Baseball Game","keywords":"","body":"Question You're now a baseball game point recorder. Given a list of strings, each string can be one of the 4 following types: Integer (one round's score): Directly represents the number of points you get in this round. \"+\" (one round's score): Represents that the points you get in this round are the sum of the last two validround's points. \"D\" (one round's score): Represents that the points you get in this round are the doubled data of the last validround's points. \"C\" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed. Each round's operation is permanent and could have an impact on the round before and the round after. You need to return the sum of the points you could get in all the rounds. Example 1: Input: [\"5\",\"2\",\"C\",\"D\",\"+\"] Output: 30 Explanation: Round 1: You could get 5 points. The sum is: 5. Round 2: You could get 2 points. The sum is: 7. Operation 1: The round 2's data was invalid. The sum is: 5.Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15. Round 4: You could get 5 + 10 = 15 points. The sum is: 30. Example 2: Input: [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"] Output: 27 Explanation: Round 1: You could get 5 points. The sum is: 5. Round 2: You could get -2 points. The sum is: 3. Round 3: You could get 4 points. The sum is: 7. Operation 1: The round 3's data is invalid. The sum is: 3.Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1. Round 5: You could get 9 points. The sum is: 8. Round 6: You could get -4 + 9 = 5 points. The sum is 13. Round 7: You could get 9 + 5 = 14 points. The sum is 27. Note: The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000. Difficulty:Medium Category: Solution class Solution { public: int calPoints(vector& ops) { int ans = 0, n = ops.size(); vector res; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-761-Special-Binary-String.html":{"url":"Leetcode-761-Special-Binary-String.html","title":"Leetcode 761. Special Binary String","keywords":"","body":"Question Special binary strings are binary strings with the following two properties: The number of 0's is equal to the number of 1's. Every prefix of the binary string has at least as many 1's as 0's. Given a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them. (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.) At the end of any number of moves, what is the lexicographically largest resulting string possible? Example 1: Input: S = \"11011000\" Output: \"11100100\" Explanation: The strings \"10\" [occuring at S[1]] and \"1100\" [at S[3]] are swapped. This is the lexicographically largest string possible after some number of swaps. Note: S has length at most 50. S is guaranteed to be a special binary string as defined above. Difficulty:Medium Category: Analyze 输入,输出都是一个特色的二进制字符串, 需要满足要求为: 字符串中 0 和 1 的个数要相等 任何一个位置, 在前面的 1 的个素都要大于等于前面的 0 的个数. 这里要求我们能够通过交换字符串的方式, 生成字母顺序最大的特色字符串,. Solution class Solution { public: string makeLargestSpecial(string S) { int cnt = 0, i = 0; vector v; string ans = \"\"; for (int j = 0; j ()); for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-990-Satisfiability-of-Equality-Equations.html":{"url":"Leetcode-990-Satisfiability-of-Equality-Equations.html","title":"Leetcode 990. Satisfiability of Equality Equations","keywords":"","body":"Question Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: \"a==b\" or \"a!=b\". Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names. Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations. Example 1: Input: [\"a==b\",\"b!=a\"] Output: false Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations. Example 2: Input: [\"b==a\",\"a==b\"] Output: true Explanation: We could assign a = 1 and b = 1 to satisfy both equations. Example 3: Input: [\"a==b\",\"b==c\",\"a==c\"] Output: true Example 4: Input: [\"a==b\",\"b!=c\",\"c==a\"] Output: false Example 5: Input: [\"c==c\",\"b==d\",\"x!=z\"] Output: true Note: 1 equations[i].length == 4 equations[i][0] and equations[i][3] are lowercase letters equations[i][1] is either '=' or '!' equations[i][2] is '=' Difficulty:Medium Category: Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-962-Maximum-Width-Ramp.html":{"url":"Leetcode-962-Maximum-Width-Ramp.html","title":"Leetcode 962. Maximum Width Ramp","keywords":"","body":"Question Given an array A of integers, a ramp is a tuple (i, j) for which i and A[i] . The width of such a ramp is j - i. Find the maximum width of a ramp in A. If one doesn't exist, return 0. Example 1: Input: [6,0,8,2,1,5] Output: 4 Explanation: The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5. Example 2: Input: [9,8,1,0,1,9,4,0,4,1] Output: 7 Explanation: The maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1. Difficulty:Medium Category: Solution class Solution { public: int maxWidthRamp(vector& A) { vector s; int best = 0; for (int i = 0; i A[i]) s.push_back(i); int l = 0, r = s.size() - 1; int ans = 0; while (l Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-957-Prison-Cells-After-N-Days.html":{"url":"Leetcode-957-Prison-Cells-After-N-Days.html","title":"Leetcode 957. Prison Cells After N Days","keywords":"","body":"Question There are 8 prison cells in a row, and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. (Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.) We describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0. Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.) Example 1: Input: cells = [0,1,0,1,1,0,0,1], N = 7 Output: [0,0,1,1,0,0,0,0] Explanation: The following table summarizes the state of the prison on each day: Day 0: [0, 1, 0, 1, 1, 0, 0, 1] Day 1: [0, 1, 1, 0, 0, 0, 0, 0] Day 2: [0, 0, 0, 0, 1, 1, 1, 0] Day 3: [0, 1, 1, 0, 0, 1, 0, 0] Day 4: [0, 0, 0, 0, 0, 1, 0, 0] Day 5: [0, 1, 1, 1, 0, 1, 0, 0] Day 6: [0, 0, 1, 0, 1, 1, 0, 0] Day 7: [0, 0, 1, 1, 0, 0, 0, 0] Example 2: Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000 Output: [0,0,1,1,1,1,1,0] Note: cells.length == 8 cells[i] is in {0, 1} 1 Discuss Difficulty:Medium Category: Solution class Solution { public: vector prisonAfterNDays(vector& cells, int N) { N = N % 14; if (N == 0) N = 14; for (int i = 1; i temp = cells; for (int j = 0; j Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-994-Rotting-Oranges.html":{"url":"Leetcode-994-Rotting-Oranges.html","title":"Leetcode 994. Rotting Oranges","keywords":"","body":"Question Difficulty:Medium Category: Solution Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:17 "},"Leetcode-689-Maximum-Sum-of-3-Non-Overlapping-Subarrays.html":{"url":"Leetcode-689-Maximum-Sum-of-3-Non-Overlapping-Subarrays.html","title":"Leetcode 689. Maximum Sum of 3 Non Overlapping Subarrays","keywords":"","body":"Question 题目大意：给定正整数数组nums，计算其中不想交的 3 段子数组的最大和。每段子数组的长度为k。 In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum. Each subarray will be of size k, and we want to maximize the sum of all 3*k entries. Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one. Example: Input: [1,2,1,2,6,7,5,1], 2 Output: [0, 3, 5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger. Note: nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3). Difficulty:Hard Category: Array, DP Analyze 解法来源于博客：Maximum Sum of 3 Non-Overlapping Subarrays 三个非重叠子数组的最大和 对于这种求子数组和有关的题目时，一般都需要建立累加和数组，为啥呢，因为累加和数组可以快速的求出任意长度的子数组之和，当然也能快速的求出长度为k的子数组之和。 因为这道题只让我们找出三个子数组，那么我们可以先确定中间那个子数组的位置，这样左右两边的子数组的位置范围就缩小了，中间子数组的起点不能是从开头到结尾整个区间，必须要在首尾各留出k个位置给其他两个数组。一旦中间子数组的起始位置确定了，那么其和就能通过累加和数组快速确定。那么现在就要在左右两边的区间内分别找出和最大的子数组，遍历所有的子数组显然不是很高效，如何快速求出呢，这里我们需要使用动态规划Dynamic Programming的思想来维护两个DP数组left和right. left[i]表示在区间[0, i]范围内长度为k且和最大的子数组的起始位置 right[i]表示在区间[i, n - 1]范围内长度为k且和最大的子数组的起始位置 这两个dp数组各需要一个for循环来更新，left数组都初始化为0，前k个数字没办法，肯定起点都是0，变量total初始化为前k个数字之和，然后从第k+1个数字开始，每次向前取k个，利用累加和数组sums快速算出数字之和，跟total比较，如果大于total的话，那么更新total和left数组当前位置值，否则的话left数组的当前值就赋值为前一位的值。同理对right数组的更新也类似，total初始化为最后k个数字之和，然后从前一个数字向前遍历，如果大于total，更新total和right数组的当前位置，否则right数组的当前值就赋值为后一位的值。一旦left数组和right数组都更新好了，那么就可以遍历中间子数组的起始位置了，然后我们可以通过left和right数组快速定位出左边和右边的最大子数组的起始位置，并快速计算出这三个子数组的所有数字之和，用来更新全局最大值mx，如果mx被更新了的话，记录此时的三个子数组的起始位置到结果res中 Solution Time complexity: O(n) Space complexity: O(n) class Solution { public: vector maxSumOfThreeSubarrays(vector& nums, int k) { int n = nums.size(), mx = INT_MIN; vector sums{0}, res, left(n, 0), right(n, n - k); // 2-DP: left, right // left[i] == the start index with len k which have the biggest sum // right[i] == the start index with len k which have the biggeest sum // Get the cumulative sum for (int num : nums) sums.push_back(sums.back() + num); // Pretreatment for the left dp for (int i = k, total = sums[k] - sums[0]; i total) { left[i] = i + 1 - k; total = sums[i + 1] - sums[i + 1 - k]; } else { left[i] = left[i - 1]; } } // Pretreatment for the right dp for (int i = n - 1 - k, total = sums[n] - sums[n - k]; i >= 0; --i) { if (sums[i + k] - sums[i] >= total) { right[i] = i; total = sums[i + k] - sums[i]; } else { right[i] = right[i + 1]; } } // Main function for (int i = k; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-Interview-Hight-Five.html":{"url":"Leetcode-Interview-Hight-Five.html","title":"Hightest Five(Interview)","keywords":"","body":"Higest Five DescriptionThere are two properties in the node student id and scores, to ensure that each student will have at least 5 points, find the average of 5 highest scores for each person. ExampleGiven results = [[1,91],[1,92],[2,93],[2,99],[2,98],[2,97],[1,60],[1,58],[2,100],[1,61]] Return: Analyze 根据题意，对于每一个id，我们维护一个大小为K的min-heap。一个一个把Record放进去，如果容量超了，就把最小的踢掉。这样heap里永远是最大的K个。全部放完以后，对于每一个id，我们把heap里的Record拿出来算一下平均数。(用 unordered_map> 储存数据，其中的min heap优先队列保持size为5，然后对各自的top 5求平均值) Solution /** * Definition for a Record * class Record { * public: * int id, score; * Record(int id, int score) { * this->id = id; * this->score = score; * } * }; */ class Solution { public: map highFive(vector& results) { int len = results.size(); map, greater>> mp; // id, min-heap map result; // Save all the points for each student for (int i = 0; i 5) mp[studentId].pop(); } // 分别处理每一个学生的成绩 for (auto m : mp) { double sum = 0; while (m.second.size() > 0) { sum += m.second.top(); m.second.pop(); } result[m.first] = sum / 5; // strictly speacking, it needs to check if the student has >= 5 courses } return result; } }; ] Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:19 "},"Leetcode-Interview-Amazon-OA2-K-Nearest-Points.html":{"url":"Leetcode-Interview-Amazon-OA2-K-Nearest-Points.html","title":"K Nearest Points(Interview)","keywords":"","body":"K Nearest Points (K closest points to origin) // K-Nearest Points // 时间复杂度：O(NlogK) // 空间复杂度： O(K) struct Point { double x; double y; Point(double _x, double _y) : x(_x), y(_y) {} }; double squaredDistance(Point a, Point b) { return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y); } typedef bool (*cmp)(Point, Point); Point global_origin = Point(0, 0); bool compare(Point a, Point b) { return squaredDistance(a, global_origin) kNearestPoint(vector points, Point origin, int k) { global_origin = origin; priority_queue, cmp> pq(compare); for (int i = 0; i = k) pq.pop(); } vector res; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:19 "},"Leetcode-Interview-Amazon-OA2-City-Connection.html":{"url":"Leetcode-Interview-Amazon-OA2-City-Connection.html","title":"City Connection(Interview)","keywords":"","body":"City Connection 有一排数据中心，求最小的cost把所有的数据中心连起来 (MST算法) 在写这一篇的时候，这题非常出名，因为16年秋首批爆出的video第三题都是这道。做出来的就能拿到video，价值108k+18k美刀至少，比摸金校尉三人合体都多，做不出来也能免费去西雅图来一圈儿，吃喝减半住宿全免，但群面通过率远低于video，所以为了生存这道题必须跑出来。 题目内容是这样的，给十几个城市供电，连接不同城市的花费不同，让花费最小同时连到所有的边。给出一系列connection类，里面是edge两端的城市名和它们之间的一个cost，找出要你挑一些边，把所有城市连接起来并且总花费最小。不能有环，最后所以城市要连成一个连通块。 不能的话输出空表，最后还要按城市名字排序输出，按照node1来排序,如果一样的话再排node2。 输入: {\"Acity\",\"Bcity\",1} (\"Acity\",\"Ccity\",2} (\"Bcity\",\"Ccity\",3} 输出： (\"Acity\",\"Bcity\",1} (\"Acity\",\"Ccity\",2} 补充一句，test case一共有6个。 解决思路 思路会有很多，我的想法是Kruskal+Union Find，将输入的一群connection类（其实就是边）按照cost从小到大排序(Kruskal算法)，然后遍历。挑出一个connection之后，看一下edge两头的城市属于哪一个团伙(Union Find)。如果落单了就加入，不同团伙就合并，都是落单了就抱团。 最后有两个要求，1.如果MST不存在，那么输出一个空表（应该不是null）。这个可以用union find思想，最后查有几个union，如果大家都是自己人，那么就正常输出，如果大家是1，有零星2了，那就空表了。2.输出要按照城市的名字排序，这个不难，就正常排序就行。 Code //给好的connection class，两个城市名，和一个cost。 import java.util.*; //这句话极度重要 class Connection{ String node1; String node2; int cost; public Connection(String a, String b, int c){ node1 = a; node2 = b; cost = c; } } //下面进入正题 public class City_Connections { private static int unionNum;//这里开个全局变量，不丢人。 //这个static是题目要求的，我自己一般不写，累。 public static ArrayList getLowCost(ArrayList connections){ //先把空的情形挡掉 if (connections == null || connections.size() == 0){ return new ArrayList<>(); } ArrayList result = new ArrayList<>(); Map map = new HashMap<>(); //这里把cost小的往前排。 Collections.sort(connections, new Comparator() { @Override public int compare(Connection o1, Connection o2) { return o1.cost - o2.cost; } }); unionNum = 0; for (Connection c : connections){ String a = c.node1; String b = c.node2; //看城市是不是连过了，要是可以连，那么就在result里面加上 if (union(map, a, b)){ result.add(c); } } //这里要检查一下,是不是所有的城市都属于同一个union String find = connections.get(0).node1; int union = map.get(find); for (String str : map.keySet()){ // 如果我们中出了一个叛徒，返回空表 if (map.get(str) != union){ return new ArrayList<>(); } } //这里最后要求按照城市的名字排序 Collections.sort(result, new Comparator() { @Override public int compare(Connection o1, Connection o2) { if(o1.node1.equals(o2.node1)){ return o1.node2.compareTo(o2.node2); } return o1.node1.compareTo(o2.node1); } }); return result; } private static boolean union(Map map, String a, String b){ if (!map.containsKey(a) && !map.containsKey(b)){ map.put(a, unionNum); map.put(b, unionNum); //这里用了一个新的没用过的数字 unionNum++; return true; } //只有一方落单,那就加入有组织的一方 if (map.containsKey(a) && !map.containsKey(b)){ int aU = map.get(a); map.put(b, aU); return true; } if (!map.containsKey(a) && map.containsKey(b)){ int bU = map.get(b); map.put(a, bU); return true; } //两个人都有团伙的情况。 int aU = map.get(a); int bU = map.get(b); //如果是自己人,那肯定要踢掉,否则成环了 if(aU == bU) return false; //把所有对方的团伙都吃进来 for (String s : map.keySet()) { if (map.get(s) == bU) map.put(s, aU); } return true; } public static void main(String[] args) { ArrayList connections = new ArrayList<>(); //下面的图是个苯环，中间加上了几根，如果想验证空表，去掉几根线就行。 connections.add(new Connection(\"A\",\"B\",6)); connections.add(new Connection(\"B\",\"C\",4)); connections.add(new Connection(\"C\",\"D\",5)); connections.add(new Connection(\"D\",\"E\",8)); connections.add(new Connection(\"E\",\"F\",2)); connections.add(new Connection(\"B\",\"F\",10)); connections.add(new Connection(\"E\",\"C\",9)); connections.add(new Connection(\"F\",\"C\",7)); connections.add(new Connection(\"B\",\"E\",3)); connections.add(new Connection(\"A\",\"F\",16)); //这里就输出一下看看结果。 ArrayList res = getLowCost(connections); for (Connection c : res){ System.out.println(c.node1 + \" -> \" + c.node2 + \" \" + c.cost); } } } 复杂度分析 OA里面的题复杂度就不管了，能跑出来就行。重点关注test case不通过的情况。不过这个复杂度还是O(ElogE)吧，因为有次对所有E(Edge)的排序，算是大头，其他的操作没有比这个多的了。test case只想出孤立两个城市，就是一根connection。如果在connections表里面有个从未出现过的城市，比如铁岭(A-B,C-D,铁岭,法库)，那我是真的没有办法了。 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:25:19 "},"Leetcode-1005-Maximize-Sum-Of-Array-After-K-Negations.html":{"url":"Leetcode-1005-Maximize-Sum-Of-Array-After-K-Negations.html","title":"Leetcode 1005. Maximize Sum Of Array After K Negations","keywords":"","body":"Leetcode 1005. Maximize Sum Of Array After K Negations Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total. (We may choose the same index i multiple times.) Return the largest possible sum of the array after modifying it in this way. Example 1: Input: A = [4,2,3], K = 1 Output: 5 Explanation: Choose indices (1,) and A becomes [4,-2,3]. Example 2: Input: A = [3,-1,0,2], K = 3 Output: 6 Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2]. Example 3: Input: A = [2,-3,-1,5,-4], K = 2 Output: 13 Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4]. Note: 1 1 -100 Difficulty:Easy Category: Solution class Solution { public: int largestSumAfterKNegations(vector& A, int K) { int sum = 0; sort(A.begin(), A.end()); for (int& a : A) { if (K > 0 && a Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-1006-Clumsy-Factorial.html":{"url":"Leetcode-1006-Clumsy-Factorial.html","title":"Leetcode 1006. Clumsy Factorial","keywords":"","body":"Question Normally, the factorial of a positive integer n is the product of all positive integers less than or equal to n. For example, factorial(10) = 10 9 8 7 6 5 4 3 2 * 1. We instead make a clumsy factorial: using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order. For example, clumsy(10) = 10 9 / 8 + 7 - 6 5 / 4 + 3 - 2 * 1. However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right. Additionally, the division that we use is floor division such that 10 * 9 / 8 equals 11. This guarantees the result is an integer. Implement the clumsy function as defined above: given an integer N, it returns the clumsy factorial of N. Example 1: Input: 4 Output: 7 Explanation: 7 = 4 * 3 / 2 + 1 Example 2: Input: 10 Output: 12 Explanation: 12 = 10 9 / 8 + 7 - 6 5 / 4 + 3 - 2 * 1 Note: 1 Difficulty:Medium Category: Solution class Solution { public: int clumsy(int N) { if (N 0; n -= 4) { sum += n; int next = 0; if (n - 1 > 0) next = n - 1; if (n - 2 > 0) next *= n - 2; if (n - 3 > 0) next /= n - 3; sum -= next; } return sum; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-737-Sentence-Similarity-II.html":{"url":"Leetcode-737-Sentence-Similarity-II.html","title":"Leetcode 737. Sentence Similarity II","keywords":"","body":"Question Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar. For example, words1 = [\"great\", \"acting\", \"skills\"] and words2 = [\"fine\", \"drama\", \"talent\"] are similar, if the similar word pairs are pairs = [[\"great\", \"good\"], [\"fine\", \"good\"], [\"acting\",\"drama\"], [\"skills\",\"talent\"]]. Note that the similarity relation is transitive. For example, if \"great\" and \"good\" are similar, and \"fine\" and \"good\" are similar, then \"great\" and \"fine\" are similar. Similarity is also symmetric. For example, \"great\" and \"fine\" being similar is the same as \"fine\" and \"great\" being similar. Also, a word is always similar with itself. For example, the sentences words1 = [\"great\"], words2 = [\"great\"], pairs = [] are similar, even though there are no specified similar word pairs. Finally, sentences can only be similar if they have the same number of words. So a sentence like words1 = [\"great\"] can never be similar to words2 = [\"doubleplus\",\"good\"]. Note: The length of words1 and words2 will not exceed 1000. The length of pairs will not exceed 2000. The length of each pairs[i] will be 2. The length of each words[i] and pairs[i][j] will be in the range [1, 20]. Difficulty:Medium Category: Analyze 这道题目的同义单词之间是具有传递性的，我们首先要做的就是建立这个连通图(同义词)的数据结构，对于每个结点来说，我们要记录所有和其相连的结点，所以我们建立每个结点和其所有相连结点集合之间的映射，比如对于这三个相似对(a, b), (b, c)，和(c, d)，我们让a,b,c到一个集合里面去.(Union Find) Solution Cite: 花花酱 LeetCode 737. Sentence Similarity II Solution 1: Union Find Time complexity: O(|Pairs| + |words1|), Space complexity: O(|Pairs|) class UnionFindSet { public: bool Union(const string& word1, const string& word2) { const string& p1 = Find(word1, true); const string& p2 = Find(word2, true); if (p1 == p2) return false; parents_[p1] = p2; return true; } const string& Find(const string& word, bool create = false) { if (!parents_.count(word)) { if (!create) return word; return parents_[word] = word; } string w = word; while (w != parents_[w]) { parents_[w] = parents_[parents_[w]]; w = parents_[w]; } return parents_[w]; } private: unordered_map parents_; }; class Solution { public: bool areSentencesSimilarTwo(vector& words1, vector& words2, vector>& pairs) { if (words1.size() != words2.size()) return false; UnionFindSet s; for (const auto& pair : pairs) s.Union(pair.first, pair.second); for (int i = 0; i 对上面的方法做一些简单的优化(Optimized)，可以得到： class UnionFindSet { public: UnionFindSet(int n) { parents_ = vector(n + 1, 0); ranks_ = vector(n + 1, 0); for (int i = 0; i ranks_[pv]) { parents_[pv] = pu; } else if (ranks_[pv] > ranks_[pu]) { parents_[pu] = pv; } else { parents_[pu] = pv; ++ranks_[pv]; } return true; } int Find(int id) { if (id != parents_[id]) parents_[id] = Find(parents_[id]); return parents_[id]; } private: vector parents_; vector ranks_; }; class Solution { public: bool areSentencesSimilarTwo(vector& words1, vector& words2, vector>& pairs) { if (words1.size() != words2.size()) return false; UnionFindSet s(pairs.size() * 2); unordered_map indies; // word to index for (const auto& pair : pairs) { int u = getIndex(pair.first, indies, true); int v = getIndex(pair.second, indies, true); s.Union(u, v); } for (int i = 0; i & indies, bool create = false) { auto it = indies.find(word); if (it == indies.end()) { if (!create) return INT_MIN; int index = indies.size(); indies.emplace(word, index); return index; } return it->second; } }; cite: Sentence Similarity II 句子相似度之二 另外一种写法，简化后。这种解法的核心是一个getRoot函数，如果两个元素属于同一个群组的话，调用getRoot函数会返回相同的值。主要分为两部，第一步是建立群组关系，suppose开始时每一个元素都是独立的个体，各自属于不同的群组。然后对于每一个给定的关系对，我们对两个单词分别调用getRoot函数，找到二者的祖先结点，如果从未建立过联系的话，那么二者的祖先结点时不同的，此时就要建立二者的关系。等所有的关系都建立好了以后，第二步就是验证两个任意的元素是否属于同一个群组，就只需要比较二者的祖先结点都否相同啦。是不是有点深度学习的赶脚，先建立模型training，然后再test。哈哈，博主乱扯的，二者并没有什么联系。我们保存群组关系的数据结构，有时用数组，有时用哈希map，看输入的数据类型吧，如果输入元素的整型数的话，用root数组就可以了，如果是像本题这种的字符串的话，需要用哈希表来建立映射，建立每一个结点和其祖先结点的映射。注意这里的祖先结点不一定是最终祖先结点，而最终祖先结点的映射一定是最重祖先结点，所以我们的getRoot函数的设计思路就是要找到最终祖先结点，那么就是当结点和其映射结点相同时返回，否则继续循环，可以递归写，也可以迭代写，这无所谓。注意这里第一行判空是相当于初始化，这个操作可以在外面写，就是要让初始时每个元素属于不同的群组 class Solution { public: bool areSentencesSimilarTwo(vector& words1, vector& words2, vector> pairs) { if (words1.size() != words2.size()) return false; unordered_map m; for (auto pair : pairs) { string x = getRoot(pair.first, m), y = getRoot(pair.second, m); if (x != y) m[x] = y; } for (int i = 0; i & m) { if (!m.count(word)) m[word] = word; return word == m[word] ? word : getRoot(m[word], m); } }; Solution 2: Recursion + DFS Cite: Sentence Similarity II 句子相似度之二 class Solution { public: bool areSentencesSimilarTwo(vector& words1, vector& words2, vector>& pairs) { if (words1.size() != words2.size()) return false; g_.clear(); for (const auto& p : pairs) { g_[p.first].insert(p.second); g_[p.second].insert(p.first); } unordered_set visited; for (int i = 0; i & visited) { if (src == dst) return true; visited.insert(src); for (const auto& next : g_[src]) { if (visited.count(next)) continue; if (dfs(next, dst, visited)) return true; } return false; } unordered_map> g_; }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-734-Sentence-Similarity.html":{"url":"Leetcode-734-Sentence-Similarity.html","title":"Leetcode 734. Sentence Similarity","keywords":"","body":"Leetcode 734. Sentence Similarity 题目大意：输入是两个句子，判断这两个句子是否相似 Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar. For example, \"great acting skills\" and \"fine drama talent\" are similar, if the similar word pairs are pairs = [[\"great\", \"fine\"], [\"acting\",\"drama\"], [\"skills\",\"talent\"]]. Note that the similarity relation is not transitive. For example, if \"great\" and \"fine\" are similar, and \"fine\" and \"good\" are similar, \"great\" and \"good\" are not necessarily similar. However, similarity is symmetric. For example, \"great\" and \"fine\" being similar is the same as \"fine\" and \"great\" being similar. Also, a word is always similar with itself. For example, the sentences words1 = [\"great\"], words2 = [\"great\"], pairs = [] are similar, even though there are no specified similar word pairs. Finally, sentences can only be similar if they have the same number of words. So a sentence like words1 = [\"great\"] can never be similar to words2 = [\"doubleplus\",\"good\"]. Note: The length of words1 and words2 will not exceed 1000. The length of pairs will not exceed 2000. The length of each pairs[i] will be 2. The length of each words[i] and pairs[i][j] will be in the range [1, 20]. Difficulty:Medium Category: Solution Cite: Sentence Similarity 句子相似度 这道题目判定的条件是： 两个句子的单词数要相同 每两个对应的单词要是相似度(题目会给一些相似的单词对，这里说明了单词对的相似具有互逆性但是没有传递性） 这里单词相似是没有传递性，就使得问题变得很容易了，我们只要建立一个单词和其所有相似单词的集合的映射就可以了，比如说如果great和fine类似，且great和good类似，那么就有下面这个映射： great -> {fine, good} 所以我们在逐个检验两个句子中对应的单词时就可以直接去映射中找，注意有可能遇到的单词对时反过来的，比如　fine　和　great，所以我们两个单词都要带到映射中去查找，只要有一个能查找到，就说明是相似的，反之，如果两个都没查找到，说明不相似，直接返回false，参见代码如下： Solution 1: HashTable class Solution { public: bool areSentencesSimilar(vector& words1, vector& words2, vector> pairs) { if (words1.size() != words2.size()) return false; unordered_map> m; for (auto pair : pairs) { m[pair.first].insert(pair.second); } for (int i = 0; i Follow up 如果同义的单词具有传递性，应该怎么处理呢。 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-684-Redundant-Connection.html":{"url":"Leetcode-684-Redundant-Connection.html","title":"Leetcode 684. Redundant Connection","keywords":"","body":"Leetcode 684. Redundant Connection 题目大意：给我们一个无向图，让我们删掉组成环的最后一条边 In this problem, a tree is an undirected graph that is connected and has no cycles. The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u , that represents an undirected edge connecting nodes u and v. Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u . Example 1: Input: [[1,2], [1,3], [2,3]] Output: [2,3] Explanation: The given undirected graph will be like this: 1 / \\ 2 - 3 Example 2: Input: [[1,2], [2,3], [3,4], [1,4], [1,5]] Output: [1,4] Explanation: The given undirected graph will be like this: 5 - 1 - 2 | | 4 - 3 Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array. Difficulty:Medium Category: Solution Solution 1: Union Find Cite: 花花酱 LeetCode 684. Redundant Connection class UnionFindSet { public: UnionFindSet(int n) { parents_ = vector(n + 1, 0); ranks_ = vector(n + 1, 0); for (int i = 0; i ranks_[pv]) { parents_[pv] = pu; } else if (ranks_[pv] > ranks_[pu]) { parents_[pu] = pv; } else { parents_[pu] = pv; ++ranks_[pv]; } return true; } int Find(int id) { if (id != parents_[id]) parents_[id] = Find(parents_[id]); return parents_[id]; } private: vector parents_; vector ranks_; }; class Solution { public: vector findRedundantConnection(vector>& edges) { UnionFindSet s(edges.size()); for (const auto& edge : edges) { if (!s.Union(edge[0], edge[1])) return edge; } return {}; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-695-Max-Area-of-Island.html":{"url":"Leetcode-695-Max-Area-of-Island.html","title":"Leetcode 695. Max Area of Island","keywords":"","body":"Question Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return `6`. Note the answer is not 11, because the island must be connected 4-directionally. Example 2: [[0,0,0,0,0,0,0,0]] Given the above grid, return `0`. Note: The length of each dimension in the given grid does not exceed 50. Difficulty:Medium Category: Analyze Cite: Max Area of Island 岛的最大面积 Solution class Solution { public: int maxAreaOfIsland(vector>& grid) { if (grid.empty()) return 0; int m = grid.size(); int n = grid[0].size(); int ans = 0; for (int y = 0; y >& grid, int x, int y, int m, int n, int& cnt, int& ans) { if (x = n || y >= m || grid[y][x] == 0) return; // Change all the grid[y][x] to '0' ans = max(ans, cnt++); grid[y][x] = 0; dfs(grid, x + 1, y, m, n, cnt, ans); dfs(grid, x - 1, y, m, n, cnt, ans); dfs(grid, x, y + 1, m, n, cnt, ans); dfs(grid, x, y - 1, m, n, cnt, ans); } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:15 "},"Leetcode-841-Keys-and-Rooms.html":{"url":"Leetcode-841-Keys-and-Rooms.html","title":"Leetcode 841. Keys and Rooms","keywords":"","body":"Leetcode 841. Keys and Rooms There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room. Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0). You can walk back and forth between rooms freely. Return true if and only if you can enter every room. Example 1: Input: [[1],[2],[3],[]] Output: true Explanation: We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3. Since we were able to go to every room, we return true. Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2. Note: 1 0 The number of keys in all rooms combined is at most 3000. Difficulty:Medium Category: Solution Solution 1: DFS Time complexity: O(V + E), Space complexity: O(V) class Solution { public: bool canVisitAllRooms(vector>& rooms) { unordered_set visited; dfs(rooms, 0, visited); return visited.size() == rooms.size(); } private: void dfs(const vector>& rooms, int cur, unordered_set& visited) { // Check if we visit the cur room... if (visited.count(cur)) return; visited.insert(cur); for (int nroom : rooms[cur]) dfs(rooms, nroom, visited); } }; Solution 2: Union Find Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:16 "},"Leetcode-1012-Complement-of-Base-10-Integer.html":{"url":"Leetcode-1012-Complement-of-Base-10-Integer.html","title":"Leetcode 1012. Complement of Base 10 Integer","keywords":"","body":"Leetcode 1012. Complement of Base 10 Integer Every non-negative integer N has a binary representation. For example, 5 can be represented as \"101\" in binary, 11 as \"1011\" in binary, and so on. Note that except for N = 0, there are no leading zeroes in any binary representation. The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1. For example, the complement of \"101\" in binary is \"010\" in binary. For a given number N in base-10, return the complement of it's binary representation as a base-10 integer. Example 1: Input: 5 Output: 2 Explanation: 5 is \"101\" in binary, with complement \"010\" in binary, which is 2 in base-10. Example 2: Input: 7 Output: 0 Explanation: 7 is \"111\" in binary, with complement \"000\" in binary, which is 0 in base-10. Example 3: Input: 10 Output: 5 Explanation: 10 is \"1010\" in binary, with complement \"0101\" in binary, which is 5 in base-10. Note: 0 Difficulty:Easy Category: Solution class Solution { public: int bitwiseComplement(int N) { if (N == 0) return 1; s_ = \"\"; string num = toBinary(N); int right = num.size() - 1; int cnt = 1, ans = 0; for (; right >= 0; --right) { if (num[right] == '0') { ans += cnt; } cnt *= 2; } return ans; } private: string s_; string toBinary(int n) { s_ = (n % 2 == 0 ? '0' : '1') + s_; if (n / 2 != 0) { toBinary(n / 2); } return s_; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-1013-Pairs-of-Songs-With-Total-Durations-Divisible-by-60.html":{"url":"Leetcode-1013-Pairs-of-Songs-With-Total-Durations-Divisible-by-60.html","title":"Leetcode 1013. Pairs of Songs With Total Durations Divisible by 60","keywords":"","body":"Question In a list of songs, the i-th song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i with (time[i] + time[j]) % 60 == 0. Example 1: Input: [30,20,150,100,40] Output: 3 Explanation: Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60 Example 2: Input: [60,60,60] Output: 3 Explanation: All three pairs have a total duration of 120, which is divisible by 60. Note: 1 1 Difficulty:Medium Category: Solution class Solution { public: int numPairsDivisibleBy60(vector& time) { int ans = 0; vector vec(61, 0); for (int t : time) { t %= 60; if (t == 0) ans += vec[0]; else ans += vec[60-t]; vec[t]++; } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-1014-Capacity-To-Ship-Packages-Within-D-Days.html":{"url":"Leetcode-1014-Capacity-To-Ship-Packages-Within-D-Days.html","title":"Leetcode 1014. Capacity To Ship Packages Within D Days","keywords":"","body":"Question A conveyor belt has packages that must be shipped from one port to another within D days. The i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days. Example 1: Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5 Output: 15 Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10 Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. Example 2: Input: weights = [3,2,2,4,1,4], D = 3 Output: 6 Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this: 1st day: 3, 2 2nd day: 2, 4 3rd day: 1, 4 Example 3: Input: weights = [1,2,3,1,1], D = 4 Output: 3 Explanation: 1st day: 1 2nd day: 2 3rd day: 3 4th day: 1, 1 Note: 1 1 Discuss Difficulty:Medium Category: Solution class Solution { public: int shipWithinDays(vector& weights, int D) { int left = 0, right = INT_MAX; while (left & weights, int mid, int& max_day) { int sum = 0, cnt = 0; for (int w : weights) { if (w > mid) return false; if (cnt > max_day) return false; sum += w; // if (mid == 5) std::cout mid) { cnt++; sum = w; } } if (sum > 0) cnt++; if (cnt > max_day) return false; return true; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-307-Range-Sum-Query-Mutable.html":{"url":"Leetcode-307-Range-Sum-Query-Mutable.html","title":"Leetcode 307. Range Sum Query Mutable","keywords":"","body":"Leetcode 307. Range Sum Query Mutable 题目大意：给你一个数组，让你求一个范围之内所有元素的和，数组元素可以更改。 Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: Given nums = [1, 3, 5] sumRange(0, 2) -> 9 update(1, 2) sumRange(0, 2) -> 8 Note: The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly. Difficulty:Medium Category: Solution Solution 1: Fenwick Tree (Binary Indexed Tree) 在这道题目中可以考虑使用 Binary Indexed Tree 的数据结构来求解, 这种数据结构可以得到 query, update 的时间复杂度都为 O(log n) Time complexity: init O(nlogn), query: O(logn), update: O(logn) class FenwickTree { public: FenwickTree(int n) : sum_(n + 1, 0) {} void update(int i, int delta) { while (i 0) { sum += sum_[i]; i -= lowbit(i); } return sum; } private: vector sum_; static inline int lowbit(int x) { return x & (-x); } }; class NumArray { public: NumArray(vector nums) : nums_(std::move(nums)), tree_(nums_.size()) { for (int i = 0; i nums_; FenwickTree tree_; }; Brute Force 这道题目直接使用 Brute force 的方式来求解也是可以通过的, 只需要使用一个data来保存当前数组的数据,然后每次 updata 的时候变化数据, sumRange() 的时候求取区间的和, 这样就可以得到结果了. Time complexity: init O(1), update: O(1), sumrange O(j - i) class NumArray { public: NumArray(vector nums) : data(std::move(nums)) {} void update(int i, int val) { data[i] = val; } int sumRange(int i, int j) { int sum = 0; for (int k = i; k data; }; Solution 3: Segment Tree class SegmentTreeNode { public: SegmentTreeNode(int start, int end, int sum, SegmentTreeNode* left = nullptr, SegmentTreeNode* right = nullptr) : start(start), end(end), sum(sum), left(left), right(right) {} SegmentTreeNode(const SegmentTreeNode&) = delete; SegmentTreeNode& operator=(const SegmentTreeNode&) = delete; ~SegmentTreeNode() { delete left; delete right; left = right = nullptr; } int start; int end; int sum; SegmentTreeNode* left; SegmentTreeNode* right; }; class NumArray { public: NumArray(vector nums) { nums_.swap(nums); if (!nums_.empty()) root_.reset(buildTree(0, nums_.size() - 1)); } void update(int i, int val) { updateTree(root_.get(), i, val); } int sumRange(int i, int j) { return sumRange(root_.get(), i, j); } private: vector nums_; std::unique_ptr root_; SegmentTreeNode* buildTree(int start, int end) { if (start == end) { return new SegmentTreeNode(start, end, nums_[start]); } int mid = start + (end - start) / 2; auto left = buildTree(start, mid); auto right = buildTree(mid + 1, end); auto node = new SegmentTreeNode(start, end, left->sum + right->sum, left, right); return node; } void updateTree(SegmentTreeNode* root, int i, int val) { if (root->start == i && root->end == i) { root->sum = val; return; } int mid = root->start + (root->end - root->start) / 2; if (i left, i, val); } else { updateTree(root->right, i, val); } root->sum = root->left->sum + root->right->sum; } int sumRange(SegmentTreeNode* root, int i, int j) { if (i == root->start && j == root->end) { return root->sum; } int mid = root->start + (root->end - root->start) / 2; if (j left, i, j); } else if (i > mid) { return sumRange(root->right, i, j); } else { return sumRange(root->left, i, mid) + sumRange(root->right, mid + 1, j); } } }; Relative questions 博客文章链接: Range Sum Query - Mutable 区域和检索 - 可变 Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-315-Count-of-Smaller-Numbers-After-Self.html":{"url":"Leetcode-315-Count-of-Smaller-Numbers-After-Self.html","title":"Leetcode 315. Count of Smaller Numbers After Self","keywords":"","body":"Question You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Input: [5,2,6,1] Output: [2,1,1,0] **Explanation:** To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. Difficulty:Medium Category: Solution Solution 1: Binary Indexed Tree (Fenwick Tree) Time complexity: O(n log n), Space complexity: O(k), k: # of unique elements class FenwickTree { public: FenwickTree(int n) : sum_(n + 1, 0) {} void update(int i, int delta) { while (i 0) { sum += sum_[i]; i -= lowbit(i); } return sum; } private: vector sum_; static inline int lowbit(int x) { return x & (-x); } }; class Solution { public: vector countSmaller(vector& nums) { // Sort the unique number set sorted(nums.begin(), nums.end()); unordered_map ranks; int rank = 0; for (const int num : sorted) ranks[num] = ++rank; vector ans; FenwickTree tree(ranks.size()); for (int i = nums.size() - 1; i >= 0; --i) { // Check how many numbers are smaller than the current number. // ranks[nums[i]] is the rank in for this number ans.push_back(tree.query(ranks[nums[i]] - 1)); // Increase the count of the rank of current number. tree.update(ranks[nums[i]], 1); } std::reverse(ans.begin(), ans.end()); return ans; } }; Solution 2: Binary Search (插入排序) 从给定数组的最后一个元素开始, 使用二分插入的方式插入建立一个新的数组,这样新的数组就是有序的了,这个时候该数字在新数组中的坐标就是原数组中其右边所有最小数字的个数. class Solution { public: vector countSmaller(vector& nums) { vector temp, ans(nums.size()); for (int i = nums.size() - 1; i >= 0; --i) { // Binary Search int left = 0, right = temp.size(); while (left = nums[i] ? right = mid : left = mid + 1; } ans[i] = right; temp.insert(temp.begin() + right, nums[i]); } return ans; } }; Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-213-House-Robber-II.html":{"url":"Leetcode-213-House-Robber-II.html","title":"Leetcode 213. House Robber II","keywords":"","body":"Question 题目大意: 相当于在一列数组中取出一个或多个不相邻数，使其和最大(考虑收尾是相连接的) You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2: Input: [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Difficulty:Medium Category: Solution Solution 1: DP class Solution { public: int rob(vector& nums) { if (nums.size() & nums, int left, int right) { int robEven = 0, robOdd = 0, n = nums.size(); for (int i = left; i Solution 2 class Solution { public: int rob(vector& nums) { if (nums.size() & nums, int left, int right) { int rob = 0, notRob = 0; for (int i = left; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-1021-Best-Sightseeing-Pair.html":{"url":"Leetcode-1021-Best-Sightseeing-Pair.html","title":"Leetcode 1021. Best Sightseeing Pair","keywords":"","body":"Question 题目大意: 在一个数组中,找到满足一对元素,可以得到一定条件的最大值(和购买股票是一样的题型) Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them. The score of a pair (i ) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them. Return the maximum score of a pair of sightseeing spots. Example 1: Input: [8,1,5,2,6] Output: 11 Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 Note: 2 1 Difficulty:Medium Category: Solution Time complexity: O(n), Space complexity: O(1) class Solution { public: int maxScoreSightseeingPair(vector& A) { int ans = 0, left = INT_MIN; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-1022-Smallest-Integer-Divisible-by-K.html":{"url":"Leetcode-1022-Smallest-Integer-Divisible-by-K.html","title":"Leetcode 1022. Smallest Integer Divisible by K","keywords":"","body":"Question Given a positive integer K, you need find the smallest positive integer N such that N is divisible by K, and Nonly contains the digit 1. Return the length of N. If there is no such N, return -1. Example 1: Input: 1 Output: 1 Explanation: The smallest answer is N = 1, which has length 1. Example 2: Input: 2 Output: -1 Explanation: There is no such positive integer N divisible by 2. Example 3: Input: 3 Output: 3 Explanation: The smallest answer is N = 111, which has length 3. Note: 1 Difficulty:Medium Category: Solution class Solution { public: int smallestRepunitDivByK(int K) { int value = 0, length = 0; for (int i = 0; i Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:12 "},"Leetcode-253-Meeting-Rooms-II.html":{"url":"Leetcode-253-Meeting-Rooms-II.html","title":"Leetcode 253. Meeting Rooms II","keywords":"","body":"Question Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si For example,Given [[0, 30],[5, 10],[15, 20]],return 2. Difficulty:Medium Category: Solution 先把所有的时间区间按照起始时间排序，然后新建一个最小堆，开始遍历时间区间，如果堆不为空，且首元素小于等于当前区间的起始时间，我们去掉堆中的首元素，把当前区间的结束时间压入堆，由于最小堆是小的在前面，那么假如首元素小于等于起始时间，说明上一个会议已经结束，可以用该会议室开始下一个会议了，所以不用分配新的会议室，遍历完成后堆中元素的个数即为需要的会议室的个数 Solution 1: Priority_queue Time complexity: O(n log n), Space complexity: O(n) class Solution { public: int minMeetingRooms(vector &intervals) { sort(intervals.begin(), intervals.end(), [](const Interval &a, const Interval &b) { return a.start , greater> q; for (auto a : intervals) { if (!q.empty() && q.top() Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "},"Leetcode-252-Meeting-Rooms.html":{"url":"Leetcode-252-Meeting-Rooms.html","title":"Leetcode 252. Meeting Rooms(LC.252)","keywords":"","body":"Question Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si For example,Given [[0, 30],[5, 10],[15, 20]],return false. Difficulty:Easy Category: Solution class Solution { public: bool canAttendMeetings(vector &intervals) { sort(intervals.begin(), intervals.end(), [](const Interval &a, const Interval &b) { return a.start Edit by guozetang all right reserved，powered by GitbookFile Modify: 2019-05-02 23:26:13 "}}